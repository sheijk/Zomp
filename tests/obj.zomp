/**

!verify off

* A simple .obj loader

!load libglfw.dylib
!load libGLEW.dylib
*/
!syntax indent

include "opengl20.zomp"
include "glfw.zomp"
include "tests/glutils.zomp"
include "tests/stdio.zomp"

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

macro foo1 a b
  ret ${foo bar}
end

macro if2 cond args...
  ret ${hello #{cond} #{args}}
end

template macro:failUnless cond
  unless #{cond}
    ret ${error expression is false #{cond}}
  end
end

(func void test() (
  (var bool foo true)
  (branch foo a a)
  (label a)
  ))

// macro if2 args...


// [else] if condN then blockN
var bool testN #condN
branch testN trueN falseN
label trueN
#blockN
label falseN

when cond
  onTrue

foreach N:
when #condN
  #blockN
  branch end

label end

macro if2 cond then onTrue remArgs...
  println()

  uniqueId endLabel "if_end"

  var astp code ${seq}

  addChild code ${when #cond
    #onTrue
    branch #endLabel
  end}

  var int currentArg 0
  const int argCount getField(remArgs, childCount)

  while currentArg+3 <= argCount
    var astp econd ast:child(remArgs, currentArg+1)
    var astp eexpr ast:child(remArgs, currentArg+2)

    addChild code ${seq
      when #econd
        #eexpr
        branch #endLabel
      end
    end}

    currentArg = currentArg + 3
  end

  when currentArg+1 < argCount
    var astp elseCode ast:child(remArgs, currentArg+1)

    addChild code elseCode
  end

  addChild code ${label #endLabel}

  ret code
end

func void test()
  if2 4 == 3 then
    printlnString "ok"
  elseif 2 > 3
    printlnString "oh nose!"
  elseif 2 > 1
    printlnString "one more"
  else
    printlnString "teh else"
  end
end

func void test()
  var astp args ${seq
    a > b then
      print true
    else
      print false
    end
  }

  macro:failUnless getField(args, childCount) > 1

  var astp code ${seq}
  var int currentArg 0

  label nextArg

  addChild code ${seq
  }

  addChild code ${label endLabel}

  mret code
end

func void test()
  var int count 0

  ifi count > 10 then
    printlnString "true"
  else
    printlnString "false"
  end
end

macro doStuff
  uniqueId foo "foo"
  mret ${seq
    var int #{foo} 100
    printInt #{foo}
    println()
  end}
end

macro ifi cond onTrue else onFalse
  uniqueId testVar "ifi"
  uniqueId trueLabel "ifi_true"
  uniqueId falseLabel "ifi_false"
  uniqueId continueLabel "ifi_end"

  ret ${seq
    var bool #{testVar} #{cond}
    branch #{testVar} #{trueLabel} #{falseLabel}
    label #{trueLabel}
    #{onTrue}
    branch #{continueLabel}
    label #{falseLabel}
    #{onFalse}
    branch #{continueLabel}
    label #{continueLabel}
  end}
end

ifi true
  printlnInt 100
else
  printlnInt 200
end

func void init()
  if initCalled

  glfwInit()
  glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
  glewInit()
  times 2 glfwPollEvents()
end


(type vertexStream
  (int size)
  ((ptr float) data)
  )

(func void  vertexStream:init (((ptr vertexStream) this) (int size)) (
  (setField this size size)
  (setField this data (malloc float size))
  ))

(type mesh
  (int size)
  (vertexStream positions)
  )

(func (ptr mesh) makeMesh ((int size)) (
  (var (ptr mesh) m (malloc mesh))
  (setField m size size)
  (vertexStream:init (fieldptr m positions) size)
  (ret m)
  ))



(var float angle 0.0)

(func int main () (
  (init)
  
  (glMatrixMode GL_PROJECTION)
  (glLoadIdentity)
  (const double aspect (double.fdiv (int.toDouble windowWidth) (int.toDouble windowHeight)))
  (gluPerspective (int.toDouble 90) aspect 1.0d 100.0d)

  (var float time 0.0)
  
  (var bool running true)
  (while running (
    (assign time  (double.toFloat (glfwGetTime)))
    (assign angle (time *_f 128.0))
    
    (glClearColor 0. 0. 0. 1.)
    (glClear (int.or GL_COLOR_BUFFER_BIT GL_DEPTH_BUFFER_BIT))

    (glMatrixMode GL_MODELVIEW)
    (glLoadIdentity)
    (glTranslatef 0. 1. -4.)
    (glRotatef angle 0. 1. 0.)

    (drawCoordSys 8.0)

    (glfwSwapBuffers)
    (glfwPollEvents)
    (assign running (bool.not (isPressed GLFW_KEY_ESC)))
    ))

  (drawPausedOverlay)
  (glfwSwapBuffers)

  (glfwPollEvents)
  (ret 0)
  ))


(macro dummy foo (
  (if (cstring.equal (getField foo id) "foo")
    (ret `(thanks for all the foo))
    (compiler:error Expected a foo))
  (ret `())
  ))
  


