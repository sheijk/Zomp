/**
 * Testing libcee.zomp
!syntax indent
 */

require "libs/libcee.zomp"
require "libs/unittest.zomp"

var int counter 0

func bool increaseAndRet(bool result)
  counter = counter + 1
  ret result
end

unittest:testCase DefineVar
  x := 10
  y := 1.0
  unittest:assertAll
    x == 10
    y ==_f 1.0
  end
end

struct Point
  int x
  int y
end

struct TestStruct
  int x
  float y
  int* tenints
  TestStruct* next
  Point pt
end

unittest:testCase DotOp
  p := malloc TestStruct
  p.x = 23
  p.y = 7.3

  p.tenints = malloc int 10
  for i 0 10
    p.tenints[i] = i + 1
  end

  // p.next = malloc TestStruct
  // p.next.x = 99

  p.pt.x = 3
  p.pt.y = 7

  unittest:assertAll
    p.x == 23
    p.y ==_f 7.3
    p.tenints[0] == 1
    p.tenints[1] == 2
    p.tenints[2] == 3
    p.tenints[3] == 4
    p.tenints[4] == 5
    p.tenints[5] == 6
    p.tenints[6] == 7
    p.tenints[7] == 8
    p.tenints[8] == 9
    p.tenints[9] == 10
    // p.next.x == 99
    p.pt.x == 3
    p.pt.y == 7
  end
end

struct IntArrays
  int size
  int* a
  Point* points
end

func void IntArrays:init(IntArrays* this, int size)
  this.size = size
  this.a = malloc int size
  this.points = malloc Point size
end

func void IntArrays:delete(IntArrays* this)
  dealloc this.a
  dealloc this.points
  dealloc this
end

unittest:testCase DotArray
  size := 4
  arr := new IntArrays size

  for i 0 size
    arr.a[i] = i + 1
    arr.points[i].x = i * 2
    arr.points[i].y = 1 - i
  end

  unittest:assertAll
    arr.a[0] == 1
    arr.a[1] == 2
    arr.a[2] == 3
    arr.a[3] == 4
    arr.points[0].x == 0
    arr.points[0].y == 1
    arr.points[1].x == 2
    arr.points[1].y == 0
    arr.points[2].x == 4
    arr.points[2].y == -1
    arr.points[3].x == 6
    arr.points[3].y == -2
  end

  IntArrays:delete arr
end

unittest:testCase ArrayDot
  size := 3
  points := malloc Point 3

  for i 0 size
    points[i].x = i
    points[i].y = size - i
  end

  unittest:assertAll
    points[0].x == 0
    points[0].y == 3
    points[1].x == 1
    points[1].y == 2
    points[2].x == 2
    points[2].y == 1
  end

  dealloc points
end

template postop* ptr
  load #ptr
end

unittest:testCase ArrayPtrDot
  size := 3
  points := malloc Point* size
  for i 0 size
    store (points + i) malloc(Point)

    (points + i)**.x = i * i
    (*(points + i))*.y = 10 * i
  end

  unittest:assertAll
    size == 3 // catch resizing without updating test code
    getField(load load(points), x) == 0
    (*(points + 0))*.x == 0
    (points+0)**.x == 0
    (*(points + 0))*.y == 0
    (*(points + 1))*.x == 1
    (*(points + 1))*.y == 10
    (*(points + 2))*.x == 4
    (*(points + 2))*.y == 20
  end

  for i2 0 size
    dealloc *(points + i2)
  end
  dealloc points
end

unittest:testCase For
  sum := 0

  for x 0 10
    sum = sum + x
  end

  unittest:assert (sum == 45)
end

unittest:testCase NestedFor
  sum := 0

  for i 0 10
    for j 4 7
      sum = sum + 1
    end
  end

  unittest:assertAll
    sum == 30
  end
end

func int getValFromSwitch(int x)
  switch (10+x)
    void
  case 10
    ret 1
  case 12
    ret 2
  end

  ret 123
end

unittest:testCase Switch
  unittest:assertAll
    getValFromSwitch 0 == 1
    getValFromSwitch 2 == 2
    getValFromSwitch 99 == 123
  end
end

unittest:testCase LazyOps
  template expectCount num code
    unittest:assert
      counter = 0
      #code
      counter == #num
    end
  end

  expectCount 1 (increaseAndRet false && increaseAndRet true)
  expectCount 2 (increaseAndRet true && increaseAndRet true)
  expectCount 2 (increaseAndRet true && increaseAndRet false)
  expectCount 1 (increaseAndRet true || increaseAndRet false)
  expectCount 2 (increaseAndRet false || increaseAndRet true)
end

unittest:testCase Assign
  floatp := malloc float 2

  floatp* = 1.0
  (ptradd floatp 1)* = 10.0

  unittest:assertAll
    floatp* ==_f 1.0
    load (ptradd floatp 1) ==_f 10.0
  end

  free (cast void* floatp)
end

unittest:testCase Loop
  sum := 0
  count := 0

  loop
    ++count
    sum = sum + count
    if (count > 9)
      break
    end
  end

  unittest:assertAll
    sum == 55
  end
end

unittest:testCase OverloadedFuncs
  onefString := toCString(1.0)
  unless (strncmp(onefString, "1.0", 3) == 0)
    println "Assertion failed"
    printHLine '-' 40
    println "left = " onefString
    println "right = " "1.0*"
    printHLine '-' 40
  end

  fivedString := toCString(5.0d)
  unless (strncmp(fivedString, "5.0", 3) == 0)
    println "Assertion failed"
    printHLine '-' 40
    println "left = " fivedString
    println "right = " "5.0*"
    printHLine '-' 40
  end

  unittest:assertAll
    toCString 10 ==_str "10"
    toCString 'x' ==_str "x"
    toCString true ==_str "true"
    toCString false ==_str "false"
    toCString "foo" ==_str "foo"
  end

  unittest:assertAll
    toInt 10 == 10
    toInt 4.0 == 4
    toInt 8.0d == 8
    toInt true == 1
    toInt false == 0
    toInt 'a' == 97
  end

  unittest:assertAll
    toFloat 16 == 16.0
    toFloat 1.0 == 1.0
    toFloat 2.0d == 2.0
    toFloat true == 1.0
    toFloat false == 0.0
    // not supported:
    // toFloat 'a' == 40.0
  end

  unittest:assertAll
    toDouble 64 == 64.0d
    toDouble 10.0 == 10.0d
    toDouble 7.0d == 7.0d
    toDouble true == 1.0d
    toDouble false == 0.0d
  end

  unittest:assertAll
    toChar 66 == 'B'
    // not supported: bool, float, double
  end
end

unittest:testCase OverloadedOps
  unittest:assertAll
    true == true
    true != false
    false != true
    false == false
  end
end

unittest:testCase MakeStructVar
  p := structlit Point x 10 y 30

  unittest:assertAll
    p.x == 10
    p.y == 30
  end
end

end


unittest:main

