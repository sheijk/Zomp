
* TODO Significant indentation

** Trivial case
   
func int foo a b c
  print a
  print b
  print c

// means the following s-expression:
(func int foo a b c (
  (print a)
  (print b)
  (print c) ))
  
** TODO expressions spanning multiple rows cause problems

*** TODO Problem: we want constructs which span multiple lines (if/then/else, ...)

func void foo(a, b, c)
  some
  impl

But:

if: a > b
  print "yes"
else
  print "no"
end if

*** require terminators for all multi-line expressions?

if a > b
  print 1
else
  print 2
end if // 'if' cannot be emitted here

let foo =
  some complex(calculation)
end

*** Use extra indentation?

if(a > b)
  print 1
 else
  print 2

or

if( a > b )
  then
    print 1
  else
    print 2

*** Change AST?

(foo a)
(bar b)
...
<=> (foo a (bar b ...))

(oneOfThree a)
(twoOfThree b)
(threeOfThree c)
<=> (oneOfThree a (twoOfThree b (threeOfThree c ()))) 

(let x 10)
(use x)
...
<=> (let x 10 (use x ...))

*** have some notation to get rid of end-of-block marker?
let/ foo =
  some complex(calculation)

** DONE How to handle operators at the end of a line?
Solution: just add braces "as usual"

let foo =
    some complex calculation

(let foo = (
     (some complex calculation)
     ))

* TODO operators

(a + b) <=> (op+ a b)

** TODO which operators to support?

*** all common math symbols
+,-,*,/,...

*** custom operators?

*** _id for alternatives (subscript like)
+_f, *_dot

*** any combination?
++, +-, +*, +'
// has precedence like the first component (above all have same precedence as +)
  // conflicts with expectations of c programmers
  // odd/inconvenient precedences: -> has precedence like '-'
// or: all non-standard ops have a default precedence?
  // user needs to know standard operators
  // adding operators to the language later on causes problems

*** latex style operators?
\sum, \concat

*** CAPS operators?
SUM CONCAT

** DONE juxtaposition has highest priority
Solution: yes ;)

foo a + bar b
(op+ (foo a) (bar b))

print 1 + 2
(op+ (print 1) 2)

** TODO require white space between operators and symbols?

(a b)

foo.(a, b)

(/foo a b/)
.(foo a b)

[foo a b]

** TODO Special support for first id of expression?

let foo = bar <=> (op= (let foo) bar)

Allow some syntax for..?
let foo = bar <=> (let (op= foo bar))

*** Where is this needed?

let foo = bar
let a + b = baz

func x + y : int = ...

**** Solve by lisp-style set/=?

macroOverload (op= l r) ...
macroOverload (op= (let $foo) $bar) ...

**** Use a postfix for different parsing?

let! x + y = plus( x, y ) <=> (let (op= (op+ x y) (plus x y)))

**** Reuse foo: notation from significant indent?

let: will not start a multi-line block if next line is not indented?

let: foo = 10
next line
<=>
(let (op= foo 10))
(next line)

problem: ambigous

first: fo bar
second
third
end first

Require

*** Special syntax?

let: foo = bar

*** What about nested expressions?

(foreach (print 10 + 20) ...) <=>
(foreach (print (op+ 10 20)) ...) vs. (foreach (op+ (print 10) 20))



** TODO Operators at the beginning/end of expressions?

(10 +)
(+ 10)

Syntax error?
(op+ 10)?
(+ 10)?
how to differentiate?

** DONE dot notation

// equivalent
2.pow 3
pow 2 3

1.upto 10 codeBlock

* TODO s-expressions versus m-expressions

m(expr, es, sion)
(s expr es sion)

** DONE how to allow both?
Solution: points below

print( 1+2, pow(2, 3) )
print( 1+2, 2.pow 3 )

if (a > 10) then print("biggy")

** DONE where do they conflict?
foo bar ( 3 + 4 )
(foo (bar (+ 3 4)))
(foo bar (+ 3 4))

(foo bar (x) y)

in general:
(expr+ id (id) expr*)

** DONE significant white space?
Solution: Use this to emit warnings

foreach i in subdirs(pwd)
(foreach i in (subdirs pwd)

foreach i in subdirs (pwd)
(foreach i in subdirs (pwd))

add( "10".parseIntBase 20, pow(1, 3+2) )
"10".parseIntBase(20).add(pow(1, 3+2))
(add ("10".parseIntBase 20) (pow 1 (3+2)) )


** DONE different parenthesis?

**** DONE <Angle brackets>
Solution: don't use

Bad, conflicts with a < b, might also be used for templates

<foo arg> <=> foo(arg)

<foo a b c> <=> <foo a b c /foo> <=> foo(a, b, c)

if <a > b> then
  ...


**** DONE {curly braces}
Solution: use. It's nice for C programmers, doesn't hurt etc.
foo {a b} <=> (foo (a b))

** DONE Special handling for (singleId)
Solution: below

Non-ambigous cases:

foo a b <=> (foo a b)
foo(a, b) <=> (foo a b)

Ambiguous cases:

foo(arg) <=> (foo arg) <=> foo arg

foo bar(arg) <=> (foo (bar arg))

foo (a) b <=> error
foo(a, b) c <=> error

** TODO A grammar
Needs work: specify completely, build experimental version in menhir

list<element> ::=
list<element> ::= element list<element>

non-empty-list<element> ::= element
non-empty-list<element> ::= element non-empty-list<element>

comma-list<element> ::=
comma-list<element> ::= comma-list-nonempty<element>
comma-list-nonempty<element> ::= element
comma-list-nonempty<element> ::= element ',' comma-list-nonempty<element>

expr ::= primexpr
expr ::= mexpr
expr ::= sexpr
expr ::= opexpr
expr ::= '(' mexpr ')'
expr ::= '(' sexpr ')'
expr ::= '(' opexpr ')'

primexpr ::= id

mexpr ::= id '(' comma-list<expr> ')'

sexpr ::= id list<sexpr-arg>
sexpr-arg ::= primexpr
sexpr-arg ::= mexpr
sexpr-arg ::= '(' id non-empty-list<expr> ')'

opexpr ::= ...
factor ::= ...
sum ::= ...

**** DONE Operators
Solution: see below

foo bar (3 + 4) <=> (foo bar (+ 3 4)) | (foo (bar (+ 3 4))) ?

Resolution: no special handling:
  foo bar (3 + 4) <=> (foo (bar (+ 3 4)))
  foo bar (+ 3 4) <=> (foo bar (+ 3 4))

Prefer m-expr because sexpr can be used by (op+ a b)

  foo bar (3 + 4) <=> (foo (bar (op+ 3 4)))
  foo bar (op+ 3 4) <=> (foo bar (op+ 3 4))
  foo bar {3 + 3} <=> (foo bar (op+ 3 4))

Still possible to use infix form for sexpr using (macro id x x):
  foo bar id(3 + 4)

**** DONE what happens to parentheses explicitly controlling precedence?
Solution: is part of operator expr

print( 4 * (1+3) )



** Abandoned
*** no mixing?

Solution: see below

ok:
foo bar (baz a b c)
foo( bar, baz a b c )

not ok:
foo bar baz(a,b,c)
  (foo bar baz (op, a b c)) ?
  (foo bar (baz a b c)) ?

print a b (c)
  (print a b (c)) ?
  (print a (b c)) ?

*** might work:
sexpr ::= '('id sexpr*')'
mexpr ::= id'(' comma-delimited-list(mexprArg) ')'
mexprArg ::= mexpr | sexpr

However this will not be possible:
foreach i in subdirs(currentDir)
  block

*** <foo bar> for sexprs conflicts with </> (less/greater)
  // </foo bar/>
  // </foo bar /foo>
  // if <. a > b .>
  // if <. foo bar .foo>


