
* TODO Misc
 
** DONE (foobar) is not parsed different from foobar
   CLOSED: [2008-02-17 Sun 01:23]
See 3rd paragraph

Both will be parsed as { id = "foobar"; args = [] }
This means calling a function with 0 args can't be distinguished from the function as a value

foo bar <=> (op() foo bar)
foo <=> (foo)

Require all function calls to follow the form (call func args*)
Then transform (op() f rest*) into (call f rest*) if f resolves to a function (pointer)
and transform into (jux f rest*) otherwise. Sequences are transformed into (seq a b ...)

*** Conflicts

This will conflict with sequences:

func void foo ()
  f
  1
end

would be (func void foo () (jux f 1))

Resolve using {}?

func void foo {
  f
  1
}

<=> (func void foo () {seq f 1})

* TODO Significant indentation

** Trivial case
   
func int foo a b c
  print a
  print b
  print c

// means the following s-expression:
(func int foo a b c (
  (print a)
  (print b)
  (print c) ))
  
** TODO expressions spanning multiple rows cause problems

*** TODO Problem: we want constructs which span multiple lines (if/then/else, ...)

func void foo(a, b, c)
  some
  impl

But:

if (a > b)
  print "yes"
else
  print "no"
end if

Parsing is ambigous in this case

*** DONE Use a special marker to begin multi-line expressions?
    CLOSED: [2008-01-28 Mon 02:38]

Solution: rejected. Use end markers instead, see below

if: foo
  print 1
  print 2
else
  print 0
end if

*** DONE require terminators for all multi-line expressions?
    CLOSED: [2008-01-28 Mon 02:38]

Solution: accepted.

if a > b
  print 1
else
  print 2
end if // 'if' cannot be emitted here

let foo =
  some complex(calculation)
end


func foo(int a, int b) -> int =
  let foo = 10
  let bar =
    some( long line, in here )
  end

  more code
end func

*** DONE Use extra indentation?

Solution: rejected. Is cumbersome and too far away from other languages

if(a > b)
  print 1
 else
  print 2

or

if( a > b )
  then
    print 1
  else
    print 2

*** DONE Change AST?
    CLOSED: [2008-01-16 Wed 01:31]

Solution: No. Requires to much changes in core language, unclear implications on the toplevel etc.

(foo a)
(bar b)
...
<=> (foo a (bar b ...))

(oneOfThree a)
(twoOfThree b)
(threeOfThree c)
<=> (oneOfThree a (twoOfThree b (threeOfThree c ()))) 

(let x 10)
(use x)
...
<=> (let x 10 (use x ...))

*** TODO have some notation to get rid of end-of-block marker?

let/ foo =
  some complex(calculation)

Where is this needed?
What would the advantage be?

*** TODO How to split a line into multiple lines?

Backslash at end of line?

this is some freaking\
long line

Needs to be indented to same level? Extra level? Ignore indenting?

Allow it to be at beginning of file also?

this is some freaking
\long line

May be indented, everything in front of \ is ignored (useful for strings)

let longString =
  "this be some kewl multi-line text
  \which has a second line
  \and is indented nicely while not
  \having any whitespace at the beginning
  \of it's lines"

** DONE How to handle operators at the end of a line?
Solution: just add braces "as usual"

let foo =
    some complex calculation

(let foo = (
     (some complex calculation)
     ))

* TODO operators

(a + b) <=> (op+ a b)

** TODO which operators to support?

*** TODO ' as operator for implicit conversions like?
    append string1 'char => append string1 (toString char)?

    i + 'f -> i + toInt f ?
    i +' f -> i + toInt f ?

*** TODO is ascii enough or should zomp use unicode (more operators etc.)?
*** TODO all common math symbols

Solution: accepted. Reasons are obvious ;)

+,-,*,/
a ** b <=> power

*** TODO Boolean operators

!, &, |
&&, ||

xor?

*** TODO Parentheses?

() for grouping / flexible
{} for s-expressions
<> for m-expressions

*** DONE custom operators?
    CLOSED: [2008-01-28 Mon 02:58]

Solution: rejected. Makes parsing and reading source harder because the whole context must be known

Allow definition of new operators by the programmer?

*** DONE _id for alternatives (subscript like)
    CLOSED: [2008-01-28 Mon 02:58]

Solution: accepted. Extending the set of operators can be useful in many cases (e.g. *_dot, *_cross for vector dot and cross product etc.)

 +_f, *_dot

*** DONE any combination?
    CLOSED: [2008-01-28 Mon 03:04]

Problem: Will cause conflicts with builtin operators. Consider >> and >* etc. Allowing any operator combination also means no new bultin operators with different precendence can be introduced. Also operator postfixes have similar features without the drawbacks.

++, +-, +*, +'
// has precedence like the first component (above all have same precedence as +)
  // conflicts with expectations of c programmers
  // odd/inconvenient precedences: -> has precedence like '-'
// or: all non-standard ops have a default precedence?
  // user needs to know standard operators
  // adding operators to the language later on causes problems

*** DONE latex style operators?

Solution: maybe later

\sum, \concat

*** DONE CAPS operators?

Solution: rejected. Constants are often spelled in CAPS (OpenGL enums etc.) and interpreting all CAPS identifiers as operators would cause conflicts here

SUM CONCAT
Render them using unicode characters when available?

Might conflict with names of user identifiers like vars and functions. Would require handling all CAPS identifiers as operators. Conflicts with common practice of naming constants in CAPS (like OpenGL does).

** DONE juxtaposition has highest priority

Solution: accepted.

foo a + bar b
(op+ (foo a) (bar b))

print 1 + 2
(op+ (print 1) 2)

** DONE require white space between operators and symbols?
   CLOSED: [2008-01-28 Mon 03:09] 

Solution: rejected. There is no need for it and it interferes with coding styles unnecessarily.

** TODO Special support for first id of expression?
let foo = bar <=> (op= (let foo) bar)

Allow some syntax for..?
let foo = bar <=> (let (op= foo bar))

*** TODO Where is this needed?

let foo = bar
let a + b = baz

func x + y : int = ...

*** TODO Solve by lisp-style set/=?

macroOverload (op= l r) ...
macroOverload (op= (let $foo) $bar) ...

*** TODO Use a postfix for different parsing?

let! x + y = plus( x, y ) <=> (let (op= (op+ x y) (plus x y)))

or

let: x + y = plus( x, y )

Can also be used in nested expressions.

(foreach i in foo (print: i + 1))

*** TODO What about nested expressions?
See above

(foreach (print 10 + 20) ...) <=>
(foreach (print (op+ 10 20)) ...) vs. (foreach (op+ (print 10) 20))

*** TODO Generalize this?

Support Smalltalk style keyword arguments? (in sexprs?)

if: a > 10 then: print yay else: print nay

*** DONE Always give first id extra priority?
Rejected: see list of problems below

    a b + c => (a (op+ b c))

**** Will this cause problems?

Requires using parentheses when it is not needed.

sqrt(5) + sqrt 20

**** Might result in unexpected ASTs

sqr 3 + 4 <=> (sqr (op+ 3 4))

**** Results in different behaviour of left and right expr on operators

sqrt 10 * 2 <=> (sqrt (op* 10 2))

but

10 * sqrt 2 <=> (op* 10 (sqrt 2))

*** DONE Reuse foo: notation from significant indent?
     CLOSED: [2008-01-28 Mon 02:47]

Solution: rejected. foo: notation will not be used for multi line iexprs so this question does not arise anymore

let: will not start a multi-line block if next line is not indented?

let: foo = 10
next line
<=>
(let (op= foo 10))
(next line)

problem: ambigous

first: fo bar
second
third
end first

Require


** DONE Operators at the beginning/end of expressions?
   CLOSED: [2008-01-28 Mon 03:11]

Solution: maybe later. The feature can be added later without causing any conflicts

(10 +)
(+ 10)

Syntax error?
(op+ 10)?
(+ 10)?
how to differentiate?

** TODO dot notation

// equivalent
2.pow 3
pow 2 3

1.upto 10 codeBlock

*** what may be written left and right of dot?

(getPrinter(console)).print(10)

foo.(*funcPtr)(a, b c)

foo.bar.baz(x, y, z)

*** what precedence?

print foo.size 10 <=> (print foo.size 10) | (print (foo.size 10))

Possible solution:
print foo.size() 10 <=> (print (foo.size) 10)
print foo.size 10 <=> (print foo.size 10)

* TODO s-expressions versus m-expressions

m(expr, es, sion)
(s expr es sion)

** DONE how to allow both?
Solution: points below

print( 1+2, pow(2, 3) )
print( 1+2, 2.pow 3 )

if (a > 10) then print("biggy")

** DONE where do they conflict?
foo bar ( 3 + 4 )
(foo (bar (+ 3 4)))
(foo bar (+ 3 4))

(foo bar (x) y)

in general:
(expr+ id (id) expr*)

** DONE significant white space?
Solution: Use this to emit warnings

foreach i in subdirs(pwd)
(foreach i in (subdirs pwd)

foreach i in subdirs (pwd)
(foreach i in subdirs (pwd))

add( "10".parseIntBase 20, pow(1, 3+2) )
"10".parseIntBase(20).add(pow(1, 3+2))
(add ("10".parseIntBase 20) (pow 1 (3+2)) )


** DONE different parenthesis?

**** DONE <Angle brackets>
Solution: don't use

Bad, conflicts with a < b, might also be used for templates

<foo arg> <=> foo(arg)

<foo a b c> <=> <foo a b c /foo> <=> foo(a, b, c)

if <a > b> then
  ...


**** DONE {curly braces}
Solution: use. It's nice for C programmers, doesn't hurt etc.
foo {a b} <=> (foo (a b))

**** TODO Use mexp<angle, braces>?

Support angle brackets which are always parsed as m-expressions to complement the always-sexpr-curly-braces.

Can be used for generics (syntax similar to C++ templates)

class Foo<T1, T2>
  method
end

***** TODO How to resolve conflict with </> (less/greater) operators?

> is interpreted as closing brace after an opening one, else as less
< is interpreted as opening brace if a > follows, else as greater

** DONE Special handling for (singleId)
Solution: below

Non-ambigous cases:

foo a b <=> (foo a b)
foo(a, b) <=> (foo a b)

Ambiguous cases:

foo(arg) <=> (foo arg) <=> foo arg

foo bar(arg) <=> (foo (bar arg))

foo (a) b <=> error
foo(a, b) c <=> error

** TODO A grammar
Needs work: specify completely, build experimental version in menhir

list<element> ::=
list<element> ::= element list<element>

non-empty-list<element> ::= element
non-empty-list<element> ::= element non-empty-list<element>

comma-list<element> ::=
comma-list<element> ::= comma-list-nonempty<element>
comma-list-nonempty<element> ::= element
comma-list-nonempty<element> ::= element ',' comma-list-nonempty<element>

expr ::= primexpr
expr ::= mexpr
expr ::= sexpr
expr ::= opexpr
expr ::= '(' mexpr ')'
expr ::= '(' sexpr ')'
expr ::= '(' opexpr ')'

primexpr ::= id

mexpr ::= id '(' comma-list<expr> ')'

sexpr ::= id list<sexpr-arg>
sexpr-arg ::= primexpr
sexpr-arg ::= mexpr
sexpr-arg ::= '(' id non-empty-list<expr> ')'

opexpr ::= ...
factor ::= ...
sum ::= ...

**** DONE Operators
Solution: see below

foo bar (3 + 4) <=> (foo bar (+ 3 4)) | (foo (bar (+ 3 4))) ?

Resolution: no special handling:
  foo bar (3 + 4) <=> (foo (bar (+ 3 4)))
  foo bar (+ 3 4) <=> (foo bar (+ 3 4))

Prefer m-expr because sexpr can be used by (op+ a b)

  foo bar (3 + 4) <=> (foo (bar (op+ 3 4)))
  foo bar (op+ 3 4) <=> (foo bar (op+ 3 4))
  foo bar {3 + 3} <=> (foo bar (op+ 3 4))

Still possible to use infix form for sexpr using (macro id x x):
  foo bar id(3 + 4)

**** DONE what happens to parentheses explicitly controlling precedence?
Solution: is part of operator expr

print( 4 * (1+3) )



** Abandoned
*** no mixing?

Solution: see below

ok:
foo bar (baz a b c)
foo( bar, baz a b c )

not ok:
foo bar baz(a,b,c)
  (foo bar baz (op, a b c)) ?
  (foo bar (baz a b c)) ?

print a b (c)
  (print a b (c)) ?
  (print a (b c)) ?

*** might work:
sexpr ::= '('id sexpr*')'
mexpr ::= id'(' comma-delimited-list(mexprArg) ')'
mexprArg ::= mexpr | sexpr

However this will not be possible:
foreach i in subdirs(currentDir)
  block

*** <foo bar> for sexprs conflicts with </> (less/greater)
  // </foo bar/>
  // </foo bar /foo>
  // if <. a > b .>
  // if <. foo bar .foo>


