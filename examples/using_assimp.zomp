/**
 * Example demonstrating the use of the assimp library to load 3d scenes
 */

linkclib "libglfw.dylib" "libGLEW.dylib" "assimp.dylib"

require "opengl20.zomp" "glfw.zomp" "libs/glutils.zomp"
require "libs/libcee.zomp"
require "libs/assimp.zomp"
require "libs/mesh.zomp"

/// no hard aborts on assertion errors, please :) + print better messages
macro assert testCode
  isCompare := false
  printF := ast:fromString "internalErrorIn unittest:assert"
  compareF := ast:fromString "internalErrorIn unittest:assert"

  if2 ast:matchesShape(testCode, ${__ ==_f __}) then
    isCompare = true
    printF = ast:fromString "print"
    compareF = ast:fromString "op==_f"
  elseif ast:matchesShape(testCode, ${__ == __})
    isCompare = true
    printF = ast:fromString "print"
    compareF = ast:fromString "op=="
  end

  if2 isCompare then
    uniqueId lvar "lvar"
    uniqueId rvar "rvar"
    l := ast:child(testCode, 0)
    r := ast:child(testCode, 1)
    ret ${
      #lvar := #l
      #rvar := #r
      unless (#compareF #lvar #rvar)
        printHLine '-' 40
        print "Assertion failed\n"
        print "left = "
        #printF #lvar
        println()
        print "right = "
        #printF #rvar
        println()
        ast:print ${#testCode} 0
      end
    end}
  else
    ret ${
      unless #testCode
        printHLine '-' 40
        printlnString "Assertion failed"
        ast:print ${#testCode} 0
      end
    end}
  end

  ret ${}
end

///-----------------------------------------------------------------------------
/// Section: math functions
///-----------------------------------------------------------------------------

func float sqrf(float x)
  x * x
end

///-----------------------------------------------------------------------------
/// Section: vector math
///-----------------------------------------------------------------------------

struct float3
  float x y z
end

func void float3:print(float3* this)
  print "float3(x=" this.x ", y=" this.y ", z=" this.z ")"
end

func float float3:length(float3* this)
  ret sqrtf(sqrf this.x + sqrf this.y + sqrf this.z)
end

//------------------------------------------------------------------------------
// OpenGL utils

func void float3:glVertex(float3* this)
  glVertex3f this.x this.y this.z
end

func void float3:sendLine(float3* start, float3* end)
  float3:glVertex start
  float3:glVertex end
end

///-----------------------------------------------------------------------------
/// Section: geometric data types
///-----------------------------------------------------------------------------

struct AABB
  float3 min max
end

func void AABB:init(AABB* this)
  this.min.x = 0.0
  this.min.y = 0.0
  this.min.z = 0.0
  this.max.x = 0.0
  this.max.y = 0.0
  this.max.z = 0.0
end

func void AABB:print(AABB* this)
  print "AABB(min: x=" this.min.x ", y=" this.min.y ", z=" this.min.z
  print " max: x=" this.max.x ", y=" this.max.y ", z=" this.max.z ")"
end

func void AABB:diagonal(float3* result, AABB* this)
  result.x = this.max.x - this.min.x
  result.y = this.max.y - this.min.y
  result.z = this.max.z - this.min.z
end

macro defineArray type varname values...
  size := values.childCount
  arrayType := ast:fromString "postop[]"
  ast:addChild arrayType type
  ast:addChild arrayType ${#size}

  code := ${
    var #arrayType #varname
  end}

  valnum := 0
  forEachAstChild value values
    ast:addChild code ${zmp:array:set #varname #valnum #value}
    ++valnum
  end

  ret code
end

template postop[] array index
  zmp:array:get #array #index
end

func void AABB:render(AABB* this)
  defineArray float x this.min.x this.max.x
  defineArray float y this.min.y this.max.y
  defineArray float z this.min.z this.max.z

  rendergl GL_LINES
    glColor4f 1. 1. 1. 1.
    for a 0 2
      for b 0 2
        glVertex3f this.min.x y[a] z[b]
        glVertex3f this.max.x y[a] z[b]
        glVertex3f x[a] this.min.y z[b]
        glVertex3f x[a] this.max.y z[b]
        glVertex3f x[a] y[b] this.min.z
        glVertex3f x[a] y[b] this.max.z
      end
    end
  end

  saveAttribs GL_POINT_SIZE
    glPointSize 10.0

    rendergl GL_POINTS
      for xi 0 2
        for yi 0 2
          for zi 0 2
            glColor4f x[xi] y[yi] z[zi] 1.0
            glVertex3f x[xi] y[yi] z[zi]
          end
        end
      end
    end
  end
end

///-----------------------------------------------------------------------------
/// Section: assimp bindings
///-----------------------------------------------------------------------------

func void GLenum:print(GLenum e)
  printInt e
end

func Mesh* aiScene:toMesh(aiScene* this)
  aim := load(ptradd this.mMeshes 0)

  Mesh:define m aim.mNumVertices
    gl_Position GL_FLOAT 3
    gl_Normal GL_FLOAT 3
  end

  VertexStream:copyFromVector3D ptradd(m.streams,0) aim.mVertices
  VertexStream:copyFromVector3D ptradd(m.streams,1) aim.mNormals

  ret m
end

func void Mesh:calcAABB(AABB* result, Mesh* this)
  var AABB bb
  AABB:init &bb

  posStream := this.streams
  positions := cast float* posStream.data

  for vnum 0 posStream*.size
    x := load(positions +_ptr 0)
    y := load(positions +_ptr 1)
    z := load(positions +_ptr 2)

    bb.min.x = float:min bb.min.x x
    bb.min.y = float:min bb.min.y y
    bb.min.z = float:min bb.min.z z
    bb.max.x = float:max bb.max.x x
    bb.max.y = float:max bb.max.y y
    bb.max.z = float:max bb.max.z z

    positions = positions +_ptr 3
  end

  store result bb
end

///-----------------------------------------------------------------------------
/// Section: Application
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if2 bool:not(initCalled) then
    glfwInit()
    glfwOpenWindowHint GLFW_FSAA_SAMPLES 4
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

// avoid writing it over and over, should be part of utils lib
macro mainloop body...
  ret ${
    frameDuration := 0.0
    frameNum := 0
    startTime := double:toFloat glfwGetTime()
    lastTime := startTime
    time := startTime
    running := true

    while running
      autoSetupViewport()
      glfwGetWindowSize &windowWidth &windowHeight
      // aspectRatio := int:toFloat windowWidth / int:toFloat windowHeight
      lastTime = time
      time = double:toFloat glfwGetTime()
      frameDuration = time - lastTime

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = bool:not isPressed(GLFW_KEY_ESC)
      if2 (maxRunTime != 0.0) then
        running = running && (time - startTime < maxRunTime)
      end
      ++frameNum
    end

    endTime := double:toFloat glfwGetTime()
  end}
end

var bool firstRun true

func int objShader()
  varyingSource := "
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    // normal = gl_NormalMatrix * gl_Normal;
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // float brightness = normal.z * 0.5 + 0.5;
    // gl_FragColor = vec4(0.0,1.0,0.0,1.0) * brightness;
    gl_FragColor = vec4(normalize(normal)*0.5 + vec3(0.5), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

macro measureAndReport actionDescr code
  uniqueId startTime "measureAndReport"
  uniqueId stopTime "measureAndReport"

  ret ${
    #startTime := glfwGetTime()
    #code
    #stopTime := glfwGetTime()
    printString #actionDescr
    printString " took "
    printDouble (#stopTime -_d #startTime)
    printChar 's'
    println()
  end}
end

func int main()
  init()

  angle := 0.0

  // sceneFilename := "data/assimp/OBJ/rifle.obj"
  sceneFilename := "data/ModernStructure.3ds"
  loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices

  measureAndReport "Loading scene"
    scene := aiImportFile sceneFilename loadOptions
  end

  if2 (scene ==_ptr nullptr(aiScene)) then
    printString "Error while loading file: "
    printlnString aiGetErrorString()
    ret 0
  end

  if2 (scene.mNumMeshes <= 2) then
    printString "Loaded "
    aiScene:print scene
    flushStdout()
  end

  measureAndReport "Converting to mesh"
    mesh := aiScene:toMesh scene
  end
  aiReleaseImport scene
  if2 isNull(mesh) then
    printlnString "Generated mesh is null"
    ret 0
  end

  Mesh:swapComponents mesh 2 1

  var AABB meshBB
  Mesh:calcAABB &meshBB mesh

  var float3 bbdiag
  AABB:diagonal &bbdiag &meshBB
  meshSize := float3:length &bbdiag

  AABB:print &meshBB
  println()
  print "meshSize = " meshSize
  println()

  if2 ((mesh.streams)*.size < 40) then
    Mesh:printDetailed mesh
  else
    Mesh:print mesh
  end

  maxRunTime := 2.0

  if2 firstRun then
    firstRun = false
    maxRunTime = 0.0
  end

  material := objShader()

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL

  mainloop
    angle = angle + 90.0 * frameDuration

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := int:toDouble windowWidth /_d int:toDouble windowHeight
    gluPerspective 90.0d aspect 1.0d (1.5d *_d float:toDouble meshSize)

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    glTranslatef 0. (meshSize * -0.1) (-0.8 * meshSize)
    glRotatef angle 0. 1. 0.

    drawOrientationGrid()
    glColor4f 1. 0.5 0.0 1.0
    glUseProgram material
    Mesh:render mesh GL_TRIANGLES material
    glUseProgram 0
    AABB:render &meshBB
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  glDeleteProgram material

  ret 0
end



