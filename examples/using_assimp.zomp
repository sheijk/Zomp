/**
 * Example demonstrating the use of the assimp library to load 3d scenes
 */

linkclib "libglfw.dylib" "libGLEW.dylib" "assimp.dylib"

include "libs/libcee.zomp"

include "opengl20.zomp"
include "glfw.zomp"
include "libs/glutils.zomp"

include "libs/assimp.zomp"

/// no hard aborts on assertion errors, please :) + print better messages
macro assert testCode
  isCompare := false
  printF := ast:fromString "internalErrorIn unittest:assert"
  compareF := ast:fromString "internalErrorIn unittest:assert"

  if2 ast:matchesShape(testCode, ${__ ==_f __}) then
    isCompare = true
    printF = ast:fromString "print"
    compareF = ast:fromString "op==_f"
  elseif ast:matchesShape(testCode, ${__ == __})
    isCompare = true
    printF = ast:fromString "print"
    compareF = ast:fromString "op=="
  end

  if2 isCompare then
    uniqueId lvar "lvar"
    uniqueId rvar "rvar"
    l := ast:child(testCode, 0)
    r := ast:child(testCode, 1)
    ret ${
      #lvar := #l
      #rvar := #r
      unless (#compareF #lvar #rvar)
        printHLine '-' 40
        print "Assertion failed\n"
        print "left = "
        #printF #lvar
        println()
        print "right = "
        #printF #rvar
        println()
        ast:print ${#testCode} 0
      end
    end}
  else
    ret ${
      unless #testCode
        printHLine '-' 40
        printlnString "Assertion failed"
        ast:print ${#testCode} 0
      end
    end}
  end

  ret ${}
end

///-----------------------------------------------------------------------------
/// Section: printing utilities
///-----------------------------------------------------------------------------


///-----------------------------------------------------------------------------
/// Section: math functions
///-----------------------------------------------------------------------------

func float sqrf(float x)
  x * x
end

///-----------------------------------------------------------------------------
/// Section: vector math
///-----------------------------------------------------------------------------

struct float3
  float x y z
end

func void float3:print(float3* this)
  print "float3(x=" this.x ", y=" this.y ", z=" this.z ")"
end

func float float3:length(float3* this)
  ret sqrtf(sqrf this.x + sqrf this.y + sqrf this.z)
end

//------------------------------------------------------------------------------
// OpenGL utils

func void float3:glVertex(float3* this)
  glVertex3f this.x this.y this.z
end

func void float3:sendLine(float3* start, float3* end)
  float3:glVertex start
  float3:glVertex end
end

///-----------------------------------------------------------------------------
/// Section: geometric data types
///-----------------------------------------------------------------------------

struct AABB
  float3 min max
end

func void AABB:init(AABB* this)
  this.min.x = 0.0
  this.min.y = 0.0
  this.min.z = 0.0
  this.max.x = 0.0
  this.max.y = 0.0
  this.max.z = 0.0
end

func void AABB:print(AABB* this)
  print "AABB(min: x=" this.min.x ", y=" this.min.y ", z=" this.min.z
  print " max: x=" this.max.x ", y=" this.max.y ", z=" this.max.z ")"
end

func void AABB:diagonal(float3* result, AABB* this)
  result.x = this.max.x - this.min.x
  result.y = this.max.y - this.min.y
  result.z = this.max.z - this.min.z
end

macro defineArray type varname values...
  size := values.childCount
  arrayType := ast:fromString "postop[]"
  ast:addChild arrayType type
  ast:addChild arrayType ${#size}

  code := ${
    var #arrayType #varname
  end}

  valnum := 0
  forEachAstChild value values
    ast:addChild code ${zmp:array:set #varname #valnum #value}
    ++valnum
  end

  ret code
end

template postop[] array index
  zmp:array:get #array #index
end

func void AABB:render(AABB* this)
  defineArray float x this.min.x this.max.x
  defineArray float y this.min.y this.max.y
  defineArray float z this.min.z this.max.z

  rendergl GL_LINES
    glColor4f 1. 1. 1. 1.
    for a 0 2
      for b 0 2
        glVertex3f this.min.x y[a] z[b]
        glVertex3f this.max.x y[a] z[b]
        glVertex3f x[a] this.min.y z[b]
        glVertex3f x[a] this.max.y z[b]
        glVertex3f x[a] y[b] this.min.z
        glVertex3f x[a] y[b] this.max.z
      end
    end
  end

  saveAttribs GL_POINT_SIZE
    glPointSize 10.0

    rendergl GL_POINTS
      for xi 0 2
        for yi 0 2
          for zi 0 2
            glColor4f x[xi] y[yi] z[zi] 1.0
            glVertex3f x[xi] y[yi] z[zi]
          end
        end
      end
    end
  end
end

///-----------------------------------------------------------------------------
/// Section: assimp bindings
///-----------------------------------------------------------------------------

// aiConfig.h


func void GLenum:print(GLenum e)
  printInt e
end

///-----------------------------------------------------------------------------
/// Section: Meshes
///-----------------------------------------------------------------------------

struct VertexStream
  int size
  int components
  cstring name
  GLenum type
  void* data
end

var cstring VertexStream:positionStream "gl_Position"
var cstring VertexStream:normalStream "gl_Normals"

func cstring VertexStream:internalizeDefaultName(cstring streamName)
  if2 (streamName ==_str VertexStream:positionStream) then
    ret VertexStream:positionStream
  elseif (streamName ==_str VertexStream:normalStream)
    ret VertexStream:normalStream
  end

  ret streamName
end

func void VertexStream:init(VertexStream* this, cstring name, int components, int size, GLenum type)
  this.size = size
  this.components = components
  this.name = VertexStream:internalizeDefaultName name
  this.type = type

  if2 (type == GL_FLOAT) then
    this.data = cast void* malloc(float, size * components)
  else
    printString "Warning: unsupported data type: "
    GLenum:print type
    println()
    this.size = 0
    this.components = 0
    this.name = "<error>"
    this.type = GL_INVALID_ENUM
    this.data = nullptr void
  end
end

func void VertexStream:print(VertexStream* this)
  print "VertexStream("
  print "name=" this.name
  if2 (VertexStream:internalizeDefaultName this.name !=_ptr this.name) then
    print " (attention: default name name not internalized)"
  end
  print ", size=" this.size
  print ", components=" this.components
  print ", type=" this.type ")"
end

macro VertexStream:foreach stream type dataPtr code
  uniqueId index "vertexIndex"
  ret ${
    for #index 0 #stream.size
      #dataPtr := ptradd(cast #type* #stream.data, #index * #stream.components)
      #code
    end
  end}
end

func void VertexStream:printDetailed(VertexStream* this)
  VertexStream:foreach this float f
    printString "    "
    for cnum 0 this.components
      printFloat load(f +_ptr cnum)
      printChar ' '
    end
    println()
  end
end

/// A mesh is a collection of vertex streams. Streams will be bound to GLSL
/// vertex attributes of the same name. By convention the first stream will
/// always contain the vertex positions and be called gl_Position
struct Mesh
  int streamCount
  VertexStream* streams
end

template Mesh:init m args...
  error "Cannot use new to define mesh. Use Mesh:define instead"
end

func void Mesh:print(Mesh* this)
  printnl "Mesh"
  print "  streamCount=" this.streamCount
  println()
  for streamnum 0 this.streamCount
    printString "  "
    VertexStream:print ptradd(this.streams, streamnum)
    println()
  end
end

func void Mesh:printDetailed(Mesh* this)
  printlnString "Mesh"
  for snum 0 this.streamCount
    printString "  "
    VertexStream:print (ptradd this.streams snum)
    println()
    VertexStream:printDetailed (ptradd this.streams snum)
  end
end

macro Mesh:define mesh size streams
  streamCount := streams.childCount

  code := ${
    #mesh := malloc Mesh
    #mesh.streamCount = #streamCount
    #mesh.streams = malloc(VertexStream, #streamCount)
  end}

  for streamnum 0 streamCount
    stream := ast:child streams streamnum
    if2 ast:matchesShape(stream, ${_ _ _}) then
      name := ast:child stream 0
      nameQ := cstring:quote name.id
      type := ast:child stream 1
      components := ast:child stream 2
      ast:addChild code ${VertexStream:init (ptradd #mesh.streams #streamnum) #nameQ #components #size #type}
    else
      ret ${error "Expected 'name type components'" stream}
    end
  end

  ret code
end

func void VertexStream:copyFromVector3D(VertexStream* this, aiVector3D* sourceVec_in)
  vertexPtr := cast float* this.data
  sourceVec := sourceVec_in
  for i 0 this.size
    store (vertexPtr +_ptr 0) sourceVec*.x
    store (vertexPtr +_ptr 1) sourceVec*.y
    store (vertexPtr +_ptr 2) sourceVec*.z
    vertexPtr = vertexPtr +_ptr 3
    sourceVec = sourceVec +_ptr 1
  end
end

macro swap a b
  uniqueId t "swap"
  ret ${
    t := #a
    #a = #b
    #b = t
  end}
end

func void VertexStream:swapComponents(VertexStream* this, int from, int to)
  VertexStream:foreach this float ptr
    swap (ptradd ptr to)* (ptradd ptr from)*
  end
end

macro Mesh:foreachStream mesh streamptr code
  uniqueId streamnum "Mesh:foreachStream"
  ret ${
    for #streamnum 0 #mesh.streamCount
      #streamptr := ptradd #mesh.streams #streamnum
      #code
    end
  end}
end

func void Mesh:swapComponents(Mesh* this, int from, int to)
  Mesh:foreachStream this stream
    VertexStream:swapComponents stream from to
  end
end

func Mesh* aiScene:toMesh(aiScene* this)
  aim := load(ptradd this.mMeshes 0)

  Mesh:define m aim.mNumVertices
    gl_Position GL_FLOAT 3
    gl_Normals GL_FLOAT 3
  end

  VertexStream:copyFromVector3D ptradd(m.streams,0) aim.mVertices
  VertexStream:copyFromVector3D ptradd(m.streams,1) aim.mNormals

  ret m
end

func void Mesh:send(Mesh* this)
  positions := cast float* (ptradd this.streams 0)*.data
  normals := cast float* (ptradd this.streams 1)*.data
  for i 0 (this.streams)*.size
    glNormal3fv normals
    glVertex3fv positions
    positions = positions +_ptr 3
    normals = normals +_ptr 3
  end
end

func void Mesh:renderFFP(Mesh* this, GLint mode)
  positions := ptradd this.streams 0
  normals := ptradd this.streams 1

  glEnableClientState GL_VERTEX_ARRAY
  glEnableClientState GL_NORMAL_ARRAY

  glNormalPointer normals.type 0 normals.data
  glVertexPointer 3 positions.type 0 positions.data
  glDrawArrays GL_TRIANGLES 0 positions.size

  glDisableClientState GL_VERTEX_ARRAY
  glDisableClientState GL_NORMAL_ARRAY
end

func void Mesh:render(Mesh* this, GLint mode, GLint shader)
  foundpos := 0
  foundnormals := 0

  //*
  Mesh:foreachStream this stream
    if2 (stream.name ==_ptr VertexStream:positionStream) then
      glEnableClientState GL_VERTEX_ARRAY
      glVertexPointer stream.components stream.type 0 stream.data
      ++foundpos
    elseif (stream.name ==_ptr VertexStream:normalStream)
      glEnableClientState GL_NORMAL_ARRAY
      glNormalPointer stream.type 0 stream.data
      ++foundnormals
    else
      flushGLErrors()
      loc := glGetAttribLocation shader stream.name
      printGLError()
      glEnableVertexAttribArray loc
      glVertexAttribPointer loc stream.size stream.type false 0 stream.data
    end
  end

  glDrawArrays mode 0 (getField (this.streams) size)
  glDisableClientState GL_VERTEX_ARRAY
  glDisableClientState GL_NORMAL_ARRAY

  assert (foundpos == 1)
  assert (foundnormals == 1)

  /*/

  positions := ptradd this.streams 0
  normals := ptradd this.streams 1

  glEnableClientState GL_VERTEX_ARRAY
  glVertexPointer 3 positions.type 0 positions.data

  glEnableClientState GL_NORMAL_ARRAY
  glNormalPointer normals.type 0 normals.data

  glDrawArrays mode 0 positions.size

  glDisableClientState GL_VERTEX_ARRAY
  glDisableClientState GL_NORMAL_ARRAY
  /**/
end

func void Mesh:calcAABB(AABB* result, Mesh* this)
  var AABB bb
  AABB:init &bb

  posStream := this.streams
  positions := cast float* posStream.data

  for vnum 0 posStream*.size
    x := load(positions +_ptr 0)
    y := load(positions +_ptr 1)
    z := load(positions +_ptr 2)

    bb.min.x = float:min bb.min.x x
    bb.min.y = float:min bb.min.y y
    bb.min.z = float:min bb.min.z z
    bb.max.x = float:max bb.max.x x
    bb.max.y = float:max bb.max.y y
    bb.max.z = float:max bb.max.z z

    positions = positions +_ptr 3
  end

  store result bb
end

///-----------------------------------------------------------------------------
/// Section: Application
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if2 bool:not(initCalled) then
    glfwInit()
    glfwOpenWindowHint GLFW_FSAA_SAMPLES 4
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

// avoid writing it over and over, should be part of utils lib
macro mainloop body...
  ret ${
    frameDuration := 0.0
    frameNum := 0
    startTime := double:toFloat glfwGetTime()
    lastTime := startTime
    time := startTime
    running := true

    while running
      autoSetupViewport()
      glfwGetWindowSize &windowWidth &windowHeight
      // aspectRatio := int:toFloat windowWidth / int:toFloat windowHeight
      lastTime = time
      time = double:toFloat glfwGetTime()
      frameDuration = time - lastTime

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = bool:not isPressed(GLFW_KEY_ESC)
      if2 (maxRunTime != 0.0) then
        running = running && (time - startTime < maxRunTime)
      end
      ++frameNum
    end

    endTime := double:toFloat glfwGetTime()
  end}
end

var bool firstRun true

func int objShader()
  varyingSource := "
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    // normal = gl_NormalMatrix * gl_Normal;
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // float brightness = normal.z * 0.5 + 0.5;
    // gl_FragColor = vec4(0.0,1.0,0.0,1.0) * brightness;
    gl_FragColor = vec4(normalize(normal)*0.5 + vec3(0.5), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

macro measureAndReport actionDescr code
  uniqueId startTime "measureAndReport"
  uniqueId stopTime "measureAndReport"

  ret ${
    #startTime := glfwGetTime()
    #code
    #stopTime := glfwGetTime()
    printString #actionDescr
    printString " took "
    printDouble (#stopTime -_d #startTime)
    printChar 's'
    println()
  end}
end

func int main()
  init()

  angle := 0.0

  // sceneFilename := "data/assimp/OBJ/rifle.obj"
  sceneFilename := "data/ModernStructure.3ds"
  loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices

  measureAndReport "Loading scene"
    scene := aiImportFile sceneFilename loadOptions
  end

  if2 (scene ==_ptr nullptr(aiScene)) then
    printString "Error while loading file: "
    printlnString aiGetErrorString()
    ret 0
  end

  if2 (scene.mNumMeshes <= 2) then
    printString "Loaded "
    aiScene:print scene
    flushStdout()
  end

  measureAndReport "Converting to mesh"
    mesh := aiScene:toMesh scene
  end
  aiReleaseImport scene
  if2 isNull(mesh) then
    printlnString "Generated mesh is null"
    ret 0
  end

  Mesh:swapComponents mesh 2 1

  var AABB meshBB
  Mesh:calcAABB &meshBB mesh

  var float3 bbdiag
  AABB:diagonal &bbdiag &meshBB
  meshSize := float3:length &bbdiag

  AABB:print &meshBB
  println()
  print "meshSize = " meshSize
  println()

  if2 ((mesh.streams)*.size < 40) then
    Mesh:printDetailed mesh
  else
    Mesh:print mesh
  end

  maxRunTime := 2.0

  if2 firstRun then
    firstRun = false
    maxRunTime = 0.0
  end

  material := objShader()

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL

  mainloop
    angle = angle + 90.0 * frameDuration

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := int:toDouble windowWidth /_d int:toDouble windowHeight
    gluPerspective 90.0d aspect 1.0d (1.5d *_d float:toDouble meshSize)

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    glTranslatef 0. (meshSize * -0.1) (-0.8 * meshSize)
    glRotatef angle 0. 1. 0.

    drawOrientationGrid()
    glColor4f 1. 0.5 0.0 1.0
    glUseProgram material
    Mesh:render mesh GL_TRIANGLES material
    glUseProgram 0
    AABB:render &meshBB
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  glDeleteProgram material

  ret 0
end



