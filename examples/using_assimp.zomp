/**
 * Example demonstrating the use of the assimp library to load 3d scenes
 */

linkclib "libglfw.dylib" "libGLEW.dylib" "assimp.dylib"

include "libs/libcee.zomp"

include "opengl20.zomp"
include "glfw.zomp"
include "libs/glutils.zomp"


///
/// Declares a function. Use this to prevent emacs indentation in next line :)
///
template funcd rettype nameAndArgs
  func #rettype #nameAndArgs
end

/// no hard aborts on assertion errors, please :) + print better messages
macro assert testCode
  isCompare := false
  printF := ast:fromString "internalErrorIn unittest:assert"
  compareF := ast:fromString "internalErrorIn unittest:assert"

  if2 ast:matchesShape(testCode, ${__ ==_f __}) then
    isCompare = true
    printF = ast:fromString "printFloat"
    compareF = ast:fromString "op==_f"
  elseif ast:matchesShape(testCode, ${__ == __})
    isCompare = true
    printF = ast:fromString "printInt"
    compareF = ast:fromString "op=="
  end

  if2 isCompare then
    uniqueId lvar "lvar"
    uniqueId rvar "rvar"
    l := ast:child(testCode, 0)
    r := ast:child(testCode, 1)
    ret ${
      #lvar := #l
      #rvar := #r
      unless (#compareF #lvar #rvar)
        printHLine '-' 40
        printlnString "Assertion failed"
        printString "left = "
        #printF #lvar
        println()
        printString "right = "
        #printF #rvar
        println()
        ast:print ${#testCode} 0
      end
    end}
  else
    ret ${
      unless #testCode
        printHLine '-' 40
        printlnString "Assertion failed"
        ast:print ${#testCode} 0
      end
    end}
  end

  ret ${}
end

///-----------------------------------------------------------------------------
/// Section: printing utilities
///-----------------------------------------------------------------------------

func void printBits(int bitmask)
  printString "0b"
  for i 0 32
    bitnum := 31 - i
    mask := int:shl 1 bitnum
    bit := int:lshr (bitmask & mask) bitnum
    printInt bit
  end
end

func void printsi(cstring str, int i)
  printString str
  printInt i
end

func void printsf(cstring str, float f)
  printString str
  printFloat f
end

func void printss(cstring s1, cstring s2)
  printString s1
  printString s2
end

///-----------------------------------------------------------------------------
/// Section: math functions
///-----------------------------------------------------------------------------

func float sqrf(float x)
  x *_f x
end

///-----------------------------------------------------------------------------
/// Section: vector math
///-----------------------------------------------------------------------------

struct float3
  float x y z
end

func void float3:print(float3* this)
  printString "float3("
  printsf "x=" this.x
  printsf ", y=" this.y
  printsf ", z=" this.z
  printString ")"
end

func float float3:length(float3* this)
  ret sqrtf(sqrf this.x +_f sqrf this.y +_f sqrf this.z)
end

//------------------------------------------------------------------------------
// OpenGL utils

func void float3:glVertex(float3* this)
  glVertex3f this.x this.y this.z
end

func void float3:sendLine(float3* start, float3* end)
  float3:glVertex start
  float3:glVertex end
end

///-----------------------------------------------------------------------------
/// Section: geometric data types
///-----------------------------------------------------------------------------

struct AABB
  float3 min max
end

func void AABB:init(AABB* this)
  this.min.x = 0.0
  this.min.y = 0.0
  this.min.z = 0.0
  this.max.x = 0.0
  this.max.y = 0.0
  this.max.z = 0.0
end

func void AABB:print(AABB* this)
  printString "AABB("
  printsf "min: x=" this.min.x
  printsf ", y=" this.min.y
  printsf ", z=" this.min.z
  printsf " max: x=" this.max.x
  printsf ", y=" this.max.y
  printsf ", z=" this.max.z
  printString ")"
end

func void AABB:diagonal(float3* result, AABB* this)
  result.x = this.max.x -_f this.min.x
  result.y = this.max.y -_f this.min.y
  result.z = this.max.z -_f this.min.z
end

template pret code
  ast:print #code 0
  ret ${}
end

macro defineArray type varname values...
  size := values.childCount
  arrayType := ast:fromString "postop[]"
  ast:addChild arrayType type
  ast:addChild arrayType ${#size}

  code := ${
    var #arrayType #varname
  end}

  valnum := 0
  forEachAstChild value values
    ast:addChild code ${zmp:array:set #varname #valnum #value}
    ++valnum
  end

  ret code
end

template postop[] array index
  zmp:array:get #array #index
end

func void AABB:render(AABB* this)
  defineArray float x this.min.x this.max.x
  defineArray float y this.min.y this.max.y
  defineArray float z this.min.z this.max.z

  rendergl GL_LINES
    glColor4f 1. 1. 1. 1.
    for a 0 2
      for b 0 2
        glVertex3f this.min.x y[a] z[b]
        glVertex3f this.max.x y[a] z[b]
        glVertex3f x[a] this.min.y z[b]
        glVertex3f x[a] this.max.y z[b]
        glVertex3f x[a] y[b] this.min.z
        glVertex3f x[a] y[b] this.max.z
      end
    end
  end

  saveAttribs GL_POINT_SIZE
    glPointSize 10.0

    rendergl GL_POINTS
      for xi 0 2
        for yi 0 2
          for zi 0 2
            glColor4f x[xi] y[yi] z[zi] 1.0
            glVertex3f x[xi] y[yi] z[zi]
          end
        end
      end
    end
  end
end

///-----------------------------------------------------------------------------
/// Section: assimp bindings
///-----------------------------------------------------------------------------

// aiConfig.h

funcd cstring aiGetLegalString()
funcd int aiGetVersionMinor()
funcd int aiGetVersionMajor()
funcd int aiGetVersionRevision()


// var int aiComponent_NORMALS 0x2u
// var int aiComponent_TANGENTS_AND_BITANGENTS 0x4u
// var int aiComponent_COLORS 0x8
// var int aiComponent_TEXCOORDS 0x10
// var int aiComponent_BONEWEIGHTS 0x20
// var int aiComponent_ANIMATIONS 0x40
// var int aiComponent_TEXTURES 0x80
// var int aiComponent_LIGHTS 0x100
// var int aiComponent_CAMERAS 0x200
// var int aiComponent_MESHES 0x400
// var int aiComponent_MATERIALS 0x800
// var int _aiComponent_Force32Bit 0x9ffffff

var int aiPrimitiveType_POINT 1
var int aiPrimitiveType_LINE 2
var int aiPrimitiveType_TRIANGLE 4
var int aiPrimitiveType_POLYGON 8

var int aiProcess_CalcTangentSpace 1
var int aiProcess_JoinIdenticalVertices 2
var int aiProcess_ConvertToLeftHanded 4
var int aiProcess_Triangulate 8
var int aiProcess_RemoveComponent 16
var int aiProcess_GenNormals 32
var int aiProcess_GenSmoothNormals 64
var int aiProcess_SplitLargeMeshes 128
var int aiProcess_PreTransformVertices 256
var int aiProcess_LimitBoneWeights 512
var int aiProcess_ValidateDataStructure 1024
var int aiProcess_ImproveCacheLocality 2048
var int aiProcess_RemoveRedundantMaterials 4096
var int aiProcess_FixInfacingNormals 8192
var int aiProcess_OptimizeGraph 16384
var int aiProcess_SortByPType 32768
var int aiProcess_FindDegenerates 65536
var int aiProcess_FindInvalidData 131072
var int aiProcess_GenUVCoords 262144
var int aiProcess_TransformUVCoords 524288

type uint int

struct aiVector2D
  float x y
end

struct aiVector3D
  float x y z
end

struct aiMatrix3x3
  float a1 a2 a3
  float b1 b2 b3
  float c1 c2 c3
end

struct aiMatrix4x4
  float a1 a2 a3 a4
  float b1 b2 b3 b4
  float c1 c2 c3 c4
  float d1 d2 d3 d4
end


const int assimp:MAXLEN 1024
struct aiString
  uint length
  char[1024] data
end

func void aiString:print(aiString* this)
  printString zmp:array:addr( &(this.data) )
end

struct aiNode
  aiString mName
  aiMatrix4x4 mTransformation
  aiNode* mParent
  uint mNumChildren
  aiNode** mChildren
  uint mNumMeshes
  uint* mMeshes
end

func void aiNode:print(aiNode* this, int indent)
  times indent printChar(' ')
  printString "aiNode mName="
  aiString:print &(this.mName)
  printString ", mNumChildren="
  printInt this.mNumChildren
  printString ", mNumMeshes="
  printInt this.mNumMeshes

  printString ", mMeshes="
  for meshnum 0 this.mNumMeshes
    if2 (meshnum > 0) then
      printString " "
    end
    printInt load(ptradd this.mMeshes meshnum)
  end

  println()

  for childnum 0 this.mNumChildren
    aiNode:print(load(ptradd this.mChildren childnum), indent+2)
  end
end

struct aiVertexWeight
  uint mVertexId
  float mWeight
end

struct aiBone
  aiString mName
  uint mNumWeights
  aiVertexWeight* mWeights
  aiMatrix4x4 mOffsetMatrix
end

struct aiFace
  uint mNumIndices
  uint* mIndices
end


struct aiMesh
  uint mPrimitiveTypes
  uint mNumVertices
  uint mNumFaces
  aiVector3D* mVertices
  aiVector3D* mNormals
  aiVector3D* mTangents
  aiVector3D* mBitangents
  (array aiVector3D* 4) mColors
  (array aiVector3D* 4) mTextureCoords
  uint[4] mNumUVComponents
  aiFace* mFaces
  uint mNumBones
  aiBone** mBones
  uint mMaterialIndex
end

macro printField printF fieldName
  fieldNameQuoted := cstring:quote fieldName.id
  ret ${
    times indent printChar(' ')
    printString #fieldNameQuoted
    printString " = "
    #printF this.#fieldName
    println()
  end}
end

template printFieldi fieldName
  printField printInt #fieldName
end

func void aiMesh:print(aiMesh* this, int startIndent)
  indent := startIndent
  printIndent indent
  printlnString "aiMesh="
  indent = indent + 2
  printFieldi mPrimitiveTypes
  printFieldi mNumVertices
  printFieldi mNumFaces

  times indent printChar(' ')
  printString "components="

  macro printUnlessNull fieldName
    fieldNameQ := cstring:quote fieldName.id

    ret ${
      if2 isNotNull(this.#fieldName) then
        printString #fieldNameQ
        printChar ' '
      end
    end}
  end

  printUnlessNull mVertices
  printUnlessNull mNormals
  printUnlessNull mTangents
  printUnlessNull mBitangents
  println()

  printIndent indent
  printString "mNumUVComponents={"
  for i 0 4
    if2 (i > 0) then
      printString ", "
    end
    printInt zmp:array:get(this.mNumUVComponents, i)
  end
  printlnString "}"

  printFieldi mNumBones
  printFieldi mMaterialIndex
end

type aiMaterial
type aiAnimation
type aiTexture
type aiLight
type aiCamera

func void aiMaterial:print(aiMaterial* this, int indent)
  times indent printChar(' ')
  printlnString "aiMaterial"
end

struct aiScene
  int mFlags
  aiNode* mRootNode
  int mNumMeshes
  aiMesh** mMeshes
  int mNumMaterials
  aiMaterial** mMaterials
  int mNumAnimations
  aiAnimation** mAnimations
  int mNumTextures
  aiTexture** mTextures
  int mNumLights
  aiLight** mLights
  int mNumCameras
  aiCamera** mCameras
end

func void aiScene:print(aiScene* this)
  indent := 2

  printlnString "aiScene"
  printString "  mFlags="
  printBits this.mFlags
  println()
  printFieldi mNumMeshes
  printFieldi mNumMaterials
  printFieldi mNumAnimations
  printFieldi mNumTextures
  printFieldi mNumLights
  printFieldi mNumCameras
  printlnString "  mRootNode="
  aiNode:print this.mRootNode 4
  printlnString "  mMeshes="
  for meshnum 0 this.mNumMeshes
    aiMesh:print load(this.mMeshes +_ptr meshnum) 4
  end
  // printlnString "  mMaterials="
  // for matnum 0 this.mNumMaterials
  //   aiMaterial:print load(ptradd this.mMaterials matnum) 4
  // end
  println()
end

funcd aiScene* aiImportFile(cstring fileName, int flags)
funcd void aiReleaseImport(aiScene* scene)

funcd cstring aiGetErrorString()

func void GLenum:print(GLenum e)
  printInt e
end

///-----------------------------------------------------------------------------
/// Section: Meshes
///-----------------------------------------------------------------------------

struct VertexStream
  int size
  int components
  cstring name
  GLenum type
  void* data
end

var cstring VertexStream:positionStream "gl_Position"
var cstring VertexStream:normalStream "gl_Normals"

func cstring VertexStream:internalizeDefaultName(cstring streamName)
  if2 (streamName ==_str VertexStream:positionStream) then
    ret VertexStream:positionStream
  elseif (streamName ==_str VertexStream:normalStream)
    ret VertexStream:normalStream
  end

  ret streamName
end

func void VertexStream:init(VertexStream* this, cstring name, int components, int size, GLenum type)
  this.size = size
  this.components = components
  this.name = VertexStream:internalizeDefaultName name
  this.type = type

  if2 (type == GL_FLOAT) then
    this.data = cast void* malloc(float, size * components)
  else
    printString "Warning: unsupported data type: "
    GLenum:print type
    println()
    this.size = 0
    this.components = 0
    this.name = "<error>"
    this.type = GL_INVALID_ENUM
    this.data = nullptr void
  end
end

func void VertexStream:print(VertexStream* this)
  printString "VertexStream("
  printss "name=" this.name
  if2 (VertexStream:internalizeDefaultName this.name !=_ptr this.name) then
    printString " (attention: default name name not internalized)"
  end
  printsi ", size=" this.size
  printsi ", components=" this.components
  printString ", type="
  GLenum:print this.type
  printString ")"
end

macro VertexStream:foreach stream type dataPtr code
  uniqueId index "vertexIndex"
  ret ${
    for #index 0 #stream.size
      #dataPtr := ptradd(cast #type* #stream.data, #index * #stream.components)
      #code
    end
  end}
end

func void VertexStream:printDetailed(VertexStream* this)
  VertexStream:foreach this float f
    printString "    "
    for cnum 0 this.components
      printFloat load(f +_ptr cnum)
      printChar ' '
    end
    println()
  end
end

/// A mesh is a collection of vertex streams. Streams will be bound to GLSL
/// vertex attributes of the same name. By convention the first stream will
/// always contain the vertex positions and be called gl_Position
struct Mesh
  int streamCount
  VertexStream* streams
end

template Mesh:init m args...
  error "Cannot use new to define mesh. Use Mesh:define instead"
end

func void Mesh:print(Mesh* this)
  printlnString "Mesh"
  printsi "  streamCount=" this.streamCount
  println()
  for streamnum 0 this.streamCount
    printString "  "
    VertexStream:print ptradd(this.streams, streamnum)
    println()
  end
end

func void Mesh:printDetailed(Mesh* this)
  printlnString "Mesh"
  for snum 0 this.streamCount
    printString "  "
    VertexStream:print (ptradd this.streams snum)
    println()
    VertexStream:printDetailed (ptradd this.streams snum)
  end
end

macro Mesh:define mesh size streams
  streamCount := streams.childCount

  code := ${
    #mesh := malloc Mesh
    #mesh.streamCount = #streamCount
    #mesh.streams = malloc(VertexStream, #streamCount)
  end}

  for streamnum 0 streamCount
    stream := ast:child streams streamnum
    if2 ast:matchesShape(stream, ${_ _ _}) then
      name := ast:child stream 0
      nameQ := cstring:quote name.id
      type := ast:child stream 1
      components := ast:child stream 2
      ast:addChild code ${VertexStream:init (ptradd #mesh.streams #streamnum) #nameQ #components #size #type}
    else
      ret ${error "Expected 'name type components'" stream}
    end
  end

  ret code
end

func void VertexStream:copyFromVector3D(VertexStream* this, aiVector3D* sourceVec_in)
  vertexPtr := cast float* this.data
  sourceVec := sourceVec_in
  for i 0 this.size
    store (vertexPtr +_ptr 0) sourceVec*.x
    store (vertexPtr +_ptr 1) sourceVec*.y
    store (vertexPtr +_ptr 2) sourceVec*.z
    vertexPtr = vertexPtr +_ptr 3
    sourceVec = sourceVec +_ptr 1
  end
end

macro swap a b
  uniqueId t "swap"
  ret ${
    t := #a
    #a = #b
    #b = t
  end}
end

func void VertexStream:swapComponents(VertexStream* this, int from, int to)
  VertexStream:foreach this float ptr
    swap (ptradd ptr to)* (ptradd ptr from)*
  end
end

macro Mesh:foreachStream mesh streamptr code
  uniqueId streamnum "Mesh:foreachStream"
  ret ${
    for #streamnum 0 #mesh.streamCount
      #streamptr := ptradd #mesh.streams #streamnum
      #code
    end
  end}
end

func void Mesh:swapComponents(Mesh* this, int from, int to)
  Mesh:foreachStream this stream
    VertexStream:swapComponents stream from to
  end
end

func Mesh* aiScene:toMesh(aiScene* this)
  aim := load(ptradd this.mMeshes 0)

  Mesh:define m aim.mNumVertices
    gl_Position GL_FLOAT 3
    gl_Normals GL_FLOAT 3
  end

  VertexStream:copyFromVector3D ptradd(m.streams,0) aim.mVertices
  VertexStream:copyFromVector3D ptradd(m.streams,1) aim.mNormals

  ret m
end

func void Mesh:send(Mesh* this)
  positions := cast float* (ptradd this.streams 0)*.data
  normals := cast float* (ptradd this.streams 1)*.data
  for i 0 (this.streams)*.size
    glNormal3fv normals
    glVertex3fv positions
    positions = positions +_ptr 3
    normals = normals +_ptr 3
  end
end

func void Mesh:renderFFP(Mesh* this, GLint mode)
  positions := ptradd this.streams 0
  normals := ptradd this.streams 1

  glEnableClientState GL_VERTEX_ARRAY
  glEnableClientState GL_NORMAL_ARRAY

  glNormalPointer normals.type 0 normals.data
  glVertexPointer 3 positions.type 0 positions.data
  glDrawArrays GL_TRIANGLES 0 positions.size

  glDisableClientState GL_VERTEX_ARRAY
  glDisableClientState GL_NORMAL_ARRAY
end

func void Mesh:render(Mesh* this, GLint mode, GLint shader)
  foundpos := 0
  foundnormals := 0

  //*
  Mesh:foreachStream this stream
    if2 (stream.name ==_ptr VertexStream:positionStream) then
      glEnableClientState GL_VERTEX_ARRAY
      glVertexPointer stream.components stream.type 0 stream.data
      ++foundpos
    elseif (stream.name ==_ptr VertexStream:normalStream)
      glEnableClientState GL_NORMAL_ARRAY
      glNormalPointer stream.type 0 stream.data
      ++foundnormals
    else
      flushGLErrors()
      loc := glGetAttribLocation shader stream.name
      printGLError()
      glEnableVertexAttribArray loc
      glVertexAttribPointer loc stream.size stream.type false 0 stream.data
    end
  end

  glDrawArrays mode 0 (getField (this.streams) size)
  glDisableClientState GL_VERTEX_ARRAY
  glDisableClientState GL_NORMAL_ARRAY

  assert (foundpos == 1)
  assert (foundnormals == 1)

  /*/

  positions := ptradd this.streams 0
  normals := ptradd this.streams 1

  glEnableClientState GL_VERTEX_ARRAY
  glVertexPointer 3 positions.type 0 positions.data

  glEnableClientState GL_NORMAL_ARRAY
  glNormalPointer normals.type 0 normals.data

  glDrawArrays mode 0 positions.size

  glDisableClientState GL_VERTEX_ARRAY
  glDisableClientState GL_NORMAL_ARRAY
  /**/
end

func void Mesh:calcAABB(AABB* result, Mesh* this)
  var AABB bb
  AABB:init &bb

  posStream := this.streams
  positions := cast float* posStream.data

  for vnum 0 posStream*.size
    x := load(positions +_ptr 0)
    y := load(positions +_ptr 1)
    z := load(positions +_ptr 2)

    bb.min.x = float:min bb.min.x x
    bb.min.y = float:min bb.min.y y
    bb.min.z = float:min bb.min.z z
    bb.max.x = float:max bb.max.x x
    bb.max.y = float:max bb.max.y y
    bb.max.z = float:max bb.max.z z

    positions = positions +_ptr 3
  end

  store result bb
end

///-----------------------------------------------------------------------------
/// Section: Application
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if2 bool:not(initCalled) then
    glfwInit()
    glfwOpenWindowHint GLFW_FSAA_SAMPLES 4
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

// avoid writing it over and over, should be part of utils lib
macro mainloop body...
  ret ${
    frameDuration := 0.0
    frameNum := 0
    startTime := double:toFloat glfwGetTime()
    lastTime := startTime
    time := startTime
    running := true

    while running
      autoSetupViewport()
      glfwGetWindowSize &windowWidth &windowHeight
      // aspectRatio := int:toFloat windowWidth /_f int:toFloat windowHeight
      lastTime = time
      time = double:toFloat glfwGetTime()
      frameDuration = time -_f lastTime

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = bool:not isPressed(GLFW_KEY_ESC)
      if2 (maxRunTime !=_f 0.0) then
        running = running && (time -_f startTime <_f maxRunTime)
      end
      ++frameNum
    end

    endTime := double:toFloat glfwGetTime()
  end}
end

var bool firstRun true

func int objShader()
  varyingSource := "
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    // normal = gl_NormalMatrix * gl_Normal;
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // float brightness = normal.z * 0.5 + 0.5;
    // gl_FragColor = vec4(0.0,1.0,0.0,1.0) * brightness;
    gl_FragColor = vec4(normalize(normal)*0.5 + vec3(0.5), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

macro measureAndReport actionDescr code
  uniqueId startTime "measureAndReport"
  uniqueId stopTime "measureAndReport"

  ret ${
    #startTime := glfwGetTime()
    #code
    #stopTime := glfwGetTime()
    printString #actionDescr
    printString " took "
    printDouble (#stopTime -_d #startTime)
    printChar 's'
    println()
  end}
end

func int main()
  init()

  angle := 0.0

  // sceneFilename := "data/assimp/OBJ/rifle.obj"
  sceneFilename := "data/ModernStructure.3ds"
  loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices

  measureAndReport "Loading scene"
    scene := aiImportFile sceneFilename loadOptions
  end

  if2 (scene ==_ptr nullptr(aiScene)) then
    printString "Error while loading file: "
    printlnString aiGetErrorString()
    ret 0
  end

  if2 (scene.mNumMeshes <= 2) then
    printString "Loaded "
    aiScene:print scene
    flushStdout()
  end

  measureAndReport "Converting to mesh"
    mesh := aiScene:toMesh scene
  end
  aiReleaseImport scene
  if2 isNull(mesh) then
    printlnString "Generated mesh is null"
    ret 0
  end

  Mesh:swapComponents mesh 2 1

  var AABB meshBB
  Mesh:calcAABB &meshBB mesh

  var float3 bbdiag
  AABB:diagonal &bbdiag &meshBB
  meshSize := float3:length &bbdiag

  AABB:print &meshBB
  println()
  printsf "meshSize = " meshSize
  println()

  if2 ((mesh.streams)*.size < 40) then
    Mesh:printDetailed mesh
  else
    Mesh:print mesh
  end

  maxRunTime := 2.0

  if2 firstRun then
    firstRun = false
    maxRunTime = 0.0
  end

  material := objShader()

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL

  mainloop
    angle = angle +_f 90.0 *_f frameDuration

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := int:toDouble windowWidth /_d int:toDouble windowHeight
    gluPerspective 90.0d aspect 1.0d (1.5d *_d float:toDouble meshSize)

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    glTranslatef 0. (meshSize *_f -0.1) (-0.8 *_f meshSize)
    glRotatef angle 0. 1. 0.

    drawOrientationGrid()
    glColor4f 1. 0.5 0.0 1.0
    glUseProgram material
    Mesh:render mesh GL_TRIANGLES material
    glUseProgram 0
    AABB:render &meshBB
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  glDeleteProgram material

  ret 0
end



