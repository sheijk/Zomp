///
/// Experiments with pipeline export from XSI
///

// static:setRequireLibDebug true

requireLibs opengl20 glfw glutils mathvis assimp libcee anttweakbar array unittest quicktext stdio utils persistence

// var int callstackDepth 0
// 
// func void logFunctionBegin(cstring name):
//   times callstackDepth:
//     printChar ' '
//   end
//   println "> " name
//   flushStdout()
//   ++callstackDepth
//   return
// end
// 
// func void logFunctionEnd():
//   --callstackDepth if: (callstackDepth > 0) 
//   times callstackDepth:
//     printChar ' '
//   end
//   println "< "
//   flushStdout()
//   return
// end
// 
// macro onFunctionEnd:
//   ret ${logFunctionEnd()}
// end
// 
// macro onFunctionBegin name:
//   ret ${logFunctionBegin #name}
// end

///-----------------------------------------------------------------------------
/// Section: list
///-----------------------------------------------------------------------------

func cstring List:listTypeName(cstring memberType):
  ret (memberType ++ "_List")
end

macro defineListType memberT:
  listT := ast:fromString List:listTypeName(memberT.id)
  code := $:
    struct #listT:
      #memberT data
      #listT* next
    end
    func void INITFUNCNAME(#listT* this, #memberT data, #listT* next):
      this.data = data
      this.next = next
    end
  end
  ast:replace code "INITFUNCNAME" ast:fromString(listT.id ++ ":init")
  ret code
end

defineListType int
defineArrayType int

defineListType float
defineArrayType float


macro makeList type nums...:
  listT := ast:fromString(type.id ++ "_List")
  list := ${nullptr #listT}
  if (nums.childCount > 0):
    i := nums.childCount - 1
    while (i >= 0):
      num := ast:child(nums, i)
      list = ${new #listT #num #list}
      --i
    end
  end

  ret list
end

macro List:foreach_ptr list indexVar dataVar code:
  uniqueId current "Current_list_item"

  ret $:
    #current := #list
    #indexVar := 0
    while isNotNull(#current):
      #dataVar := fieldptr #current data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end
end

macro List:foreach list indexVar dataVar code:
  uniqueId current "Current_list_item"

  ret $:
    #current := #list
    #indexVar := 0
    while isNotNull(#current):
      #dataVar := #current.data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end
end

macro printList list name printMemberF:
  uniqueId ptr "printList"
  uniqueId index "printList"
  ret $:
    println #name ": "
    List:foreach_ptr #list #index #ptr:
      #printMemberF #ptr
    end
  end
end

macro List:length count listPtr:
  uniqueId ptr "List:length"
  ret $:
    #ptr := #listPtr
    #count = 0
    while isNotNull(#ptr):
      #count += 1
      #ptr = #ptr.next
    end
  end
end

macro List:prepend type listVar newElement:
  listType := List:listTypeName type.id

  ret ${#listVar = new #listType #newElement #listVar}
end

///-----------------------------------------------------------------------------
/// Section: experimental library extensions
///-----------------------------------------------------------------------------

/// returns the default value for the given type
macro default type:
  ctorName := type.id ++ ":default"
  ret ${#ctorName()}
end

macro isOneOf value firstLegalValue moreLegalValues...:
  code := ${#value == #firstLegalValue}
  forEachAstChild legalVal moreLegalValues:
    code = ${#value == #legalVal || #code}
  end
  ret code
end

macro initMemory startAddressExpr valueExpr countExpr:
  uniqueId startAddress "initMemory"
  uniqueId value "initMemory"
  uniqueId count "initMemory"
  uniqueId counter "initMemory"

  ret $:
    #startAddress := #startAddressExpr
    #value := #valueExpr
    #count := #countExpr
    for #counter 0 #count:
      store (#startAddress + #counter) #value
    end
  end
end

/// TODO fix mem leaks
func cstring floatArrayToString(int count, float* data):
  str := ""
  for i 0 count:
    f := (data+i)*
    fstr := toCString f
    if (i > 0):
      str = str ++ " "
    end
    str = str ++ fstr
    dealloc fstr
  end
  ret str
end

func bool readUntil(FILE* file, char stopper, int maxLength, cstring* target):
  eof := false
  pos := 0

  writeTarget := target*
  store writeTarget '\0'

  while !eof:
    if (pos >= maxLength):
      ret false
    end

    result := getc(file)
    chr := toChar result
    if (result < 0):
      ret false
    end

    if (chr == stopper):
      store writeTarget '\0'
      ret true
    else:
      store writeTarget chr
    end
    ++pos
    writeTarget = writeTarget + 1
  end

  ret false
end

func int readFloatsFromFile(FILE* file, int count, float* target):
  read := 0
  for i 0 count:
    value := 0.0
    newlyRead := readFloat(file, target+i)
    if (newlyRead < 0):
      ret -1
    end
    read += newlyRead
  end
  ret read
end

func bool file:copy(cstring old_name, cstring new_name):
  result := system("cp " ++ old_name ++ " " ++ new_name)
  ret (result == 0)
end

func bool file:makeBackup(cstring fileName):
  num := 0
  maxAttempts := 1000
  succeeded := false
  goOnTrying := true

  while (goOnTrying):
    goOnTrying = num <= maxAttempts

    bkFileName := fileName ++ ".bk_" ++ toCString num

    bkfile := fopen bkFileName "r"
    if isNull(bkfile):
      succeeded = file:copy fileName bkFileName
      goOnTrying = false
    else:
      closeFile bkfile
    end

    ++num
  end

  ret succeeded
end

macro op{} args...:
  code := ${}
  forEachAstChild child args:
    ast:addChild code child
  end
  ret code
end

macro arraylit type elements...:
  uniqueId name "arraylit"
  size := elements.childCount
  code := ${seq}
  ast:addChild code ${var #type[#size] #name}
  for i 0 size:
    child := ast:child elements i
    ast:addChild code ${zmp:array:set #name #i #child}
  end
  ast:addChild code ast:fromString(name)
  ret code
end

func cstring glfw:keyName(int key):
  if (key == GLFW_KEY_SPACE):
    ret "Space"
  elseif (key == GLFW_KEY_SPECIAL):
    ret "Special"
  elseif (key == GLFW_KEY_ESC):
    ret "Esc"
  elseif (key == GLFW_KEY_F1):
    ret "F1"
  elseif (key == GLFW_KEY_F2):
    ret "F2"
  elseif (key == GLFW_KEY_F3):
    ret "F3"
  elseif (key == GLFW_KEY_F4):
    ret "F4"
  elseif (key == GLFW_KEY_F5):
    ret "F5"
  elseif (key == GLFW_KEY_F6):
    ret "F6"
  elseif (key == GLFW_KEY_F7):
    ret "F7"
  elseif (key == GLFW_KEY_F8):
    ret "F8"
  elseif (key == GLFW_KEY_F9):
    ret "F9"
  elseif (key == GLFW_KEY_F10):
    ret "F10"
  elseif (key == GLFW_KEY_F11):
    ret "F11"
  elseif (key == GLFW_KEY_F12):
    ret "F12"
  elseif (key == GLFW_KEY_F13):
    ret "F13"
  elseif (key == GLFW_KEY_F14):
    ret "F14"
  elseif (key == GLFW_KEY_F15):
    ret "F15"
  elseif (key == GLFW_KEY_F16):
    ret "F16"
  elseif (key == GLFW_KEY_F17):
    ret "F17"
  elseif (key == GLFW_KEY_F18):
    ret "F18"
  elseif (key == GLFW_KEY_F19):
    ret "F19"
  elseif (key == GLFW_KEY_F20):
    ret "F20"
  elseif (key == GLFW_KEY_F21):
    ret "F21"
  elseif (key == GLFW_KEY_F22):
    ret "F22"
  elseif (key == GLFW_KEY_F23):
    ret "F23"
  elseif (key == GLFW_KEY_F24):
    ret "F24"
  elseif (key == GLFW_KEY_F25):
    ret "F25"
  elseif (key == GLFW_KEY_UP):
    ret "Cursor up"
  elseif (key == GLFW_KEY_DOWN):
    ret "Cursor down"
  elseif (key == GLFW_KEY_LEFT):
    ret "Cursor left"
  elseif (key == GLFW_KEY_RIGHT):
    ret "Cursor right"
  elseif (key == GLFW_KEY_LSHIFT):
    ret "Left shift"
  elseif (key == GLFW_KEY_RSHIFT):
    ret "Right shift"
  elseif (key == GLFW_KEY_LCTRL):
    ret "Left control"
  elseif (key == GLFW_KEY_RCTRL):
    ret "Right control"
  elseif (key == GLFW_KEY_LALT):
    ret "Left alt"
  elseif (key == GLFW_KEY_RALT):
    ret "Right alt"
  elseif (key == GLFW_KEY_TAB):
    ret "Tab"
  elseif (key == GLFW_KEY_ENTER):
    ret "Enter"
  elseif (key == GLFW_KEY_BACKSPACE):
    ret "Backspace"
  elseif (key == GLFW_KEY_INSERT):
    ret "Insert"
  elseif (key == GLFW_KEY_DEL):
    ret "Del"
  elseif (key == GLFW_KEY_PAGEUP):
    ret "Pageup"
  elseif (key == GLFW_KEY_PAGEDOWN):
    ret "Pagedown"
  elseif (key == GLFW_KEY_HOME):
    ret "Home"
  elseif (key == GLFW_KEY_END):
    ret "End"
  elseif (key == GLFW_KEY_KP_0):
    ret "Keypad 0"
  elseif (key == GLFW_KEY_KP_1):
    ret "Keypad 1"
  elseif (key == GLFW_KEY_KP_2):
    ret "Keypad 2"
  elseif (key == GLFW_KEY_KP_3):
    ret "Keypad 3"
  elseif (key == GLFW_KEY_KP_4):
    ret "Keypad 4"
  elseif (key == GLFW_KEY_KP_5):
    ret "Keypad 5"
  elseif (key == GLFW_KEY_KP_6):
    ret "Keypad 6"
  elseif (key == GLFW_KEY_KP_7):
    ret "Keypad 7"
  elseif (key == GLFW_KEY_KP_8):
    ret "Keypad 8"
  elseif (key == GLFW_KEY_KP_9):
    ret "Keypad 9"
  elseif (key == GLFW_KEY_KP_DIVIDE):
    ret "Keypad divide"
  elseif (key == GLFW_KEY_KP_MULTIPLY):
    ret "Keypad multiply"
  elseif (key == GLFW_KEY_KP_SUBTRACT):
    ret "Keypad subtract"
  elseif (key == GLFW_KEY_KP_ADD):
    ret "Keypad add"
  elseif (key == GLFW_KEY_KP_DECIMAL):
    ret "Keypad decimal"
  elseif (key == GLFW_KEY_KP_EQUAL):
    ret "Keypad equal"
  elseif (key == GLFW_KEY_KP_ENTER):
    ret "Keypad enter"
  elseif (key == GLFW_KEY_LAST):
    ret "Last"
  elseif (key == GLFW_KEY_A):
    ret "A"
  elseif (key == GLFW_KEY_B):
    ret "B"
  elseif (key == GLFW_KEY_C):
    ret "C"
  elseif (key == GLFW_KEY_D):
    ret "D"
  elseif (key == GLFW_KEY_E):
    ret "E"
  elseif (key == GLFW_KEY_F):
    ret "F"
  elseif (key == GLFW_KEY_G):
    ret "G"
  elseif (key == GLFW_KEY_H):
    ret "H"
  elseif (key == GLFW_KEY_I):
    ret "I"
  elseif (key == GLFW_KEY_J):
    ret "J"
  elseif (key == GLFW_KEY_K):
    ret "K"
  elseif (key == GLFW_KEY_L):
    ret "L"
  elseif (key == GLFW_KEY_M):
    ret "M"
  elseif (key == GLFW_KEY_N):
    ret "N"
  elseif (key == GLFW_KEY_O):
    ret "O"
  elseif (key == GLFW_KEY_P):
    ret "P"
  elseif (key == GLFW_KEY_Q):
    ret "Q"
  elseif (key == GLFW_KEY_R):
    ret "R"
  elseif (key == GLFW_KEY_S):
    ret "S"
  elseif (key == GLFW_KEY_T):
    ret "T"
  elseif (key == GLFW_KEY_U):
    ret "U"
  elseif (key == GLFW_KEY_V):
    ret "V"
  elseif (key == GLFW_KEY_W):
    ret "W"
  elseif (key == GLFW_KEY_X):
    ret "X"
  elseif (key == GLFW_KEY_Y):
    ret "Y"
  elseif (key == GLFW_KEY_Z):
    ret "Z"
  elseif (key == GLFW_KEY_0):
    ret "0"
  elseif (key == GLFW_KEY_1):
    ret "1"
  elseif (key == GLFW_KEY_2):
    ret "2"
  elseif (key == GLFW_KEY_3):
    ret "3"
  elseif (key == GLFW_KEY_4):
    ret "4"
  elseif (key == GLFW_KEY_5):
    ret "5"
  elseif (key == GLFW_KEY_6):
    ret "6"
  elseif (key == GLFW_KEY_7):
    ret "7"
  elseif (key == GLFW_KEY_8):
    ret "8"
  elseif (key == GLFW_KEY_9):
    ret "9"
  elseif (key == GLFW_MOUSE_BUTTON_LEFT):
    ret "Left mouse button"
  elseif (key == GLFW_MOUSE_BUTTON_RIGHT):
    ret "Right mouse button"
  elseif (key == GLFW_MOUSE_BUTTON_MIDDLE):
    ret "Middle mouse button"
  elseif (key == GLFW_MOUSE_BUTTON_4):
    ret "Mouse button 4"
  elseif (key == GLFW_MOUSE_BUTTON_5):
    ret "Mouse button 5"
  elseif (key == GLFW_MOUSE_BUTTON_6):
    ret "Mouse button 6"
  elseif (key == GLFW_MOUSE_BUTTON_7):
    ret "Mouse button 7"
  elseif (key == GLFW_MOUSE_BUTTON_8):
    ret "Mouse button 8"
  end

  ret "Unknown key"
end

struct Rect:
  float left right top bottom
end

func Rect makeRect(float l, float t, float r, float b):
  var Rect rect
  rect.left = l
  rect.top = t
  rect.right = r
  rect.bottom = b
  ret rect
end

func bool insideRect(float x, float y, Rect* r):
  ret (x >= r.left && x < r.right && y >= r.top && y < r.bottom)
end

func void relativePos(float* x, float* y, Rect* r):
  x* = (x* - r.left) / (r.right - r.left)
  y* = (y* - r.bottom) / (r.top - r.bottom)
end

macro hasType vr typ:
  uniqueId tmp "hasType"
  ret $:
    #tmp := nullptr #typ
    #tmp = &#vr
  end
end

///-----------------------------------------------------------------------------
/// Section: math
///-----------------------------------------------------------------------------

/// calculates a 4x4 column major float matrix from the rotation component
func void RBTransform:toRotMatrix4x4(RBTransform* this, float* mat44):
  mat44[0] = this.xaxis.x
  mat44[1] = this.yaxis.x
  mat44[2] = this.zaxis.x
  mat44[3] = 0.0
  mat44[4] = this.xaxis.y
  mat44[5] = this.yaxis.y
  mat44[6] = this.zaxis.y
  mat44[7] = 0.0
  mat44[8] = this.xaxis.z
  mat44[9] = this.yaxis.z
  mat44[10] = this.zaxis.z
  mat44[11] = 0.0
  mat44[12] = 0.0
  mat44[13] = 0.0
  mat44[14] = 0.0
  mat44[15] = 1.0
end

/// calculates a 4x4 column major float matrix from the translation component
func void RBTransform:toTransMatrix44(RBTransform* this, float* mat44):
  for i 0 16 (mat44[i] = 0.0)
  mat44[0] = 1.0
  mat44[5] = 1.0
  mat44[10] = 1.0
  mat44[15] = 1.0
  mat44[12] = -this.origin.x
  mat44[13] = -this.origin.y
  mat44[14] = -this.origin.z
end

func v3f RBTransform:rotate(RBTransform* this, v3f v):
  ret (v.x * this.xaxis + v.y * this.yaxis + v.z * this.zaxis)
end

func RBTransform RBTransform:concat(RBTransform* first, RBTransform* relative):
  result := undef RBTransform
  result.xaxis = RBTransform:rotate first relative.xaxis
  result.yaxis = RBTransform:rotate first relative.yaxis
  result.zaxis = RBTransform:rotate first relative.zaxis
  result.origin = first.origin + RBTransform:rotate first relative.origin * first.scale
  result.scale = first.scale * relative.scale
  ret result
end

func float lerp(float t, float a, float b):
  return ((1. - t) * a + t * b)
end

unittest:testCase float_lerp:
  unittest:assertAll:
    lerp 0.0 10. 20. == 10.
    lerp 0.5 10. 20. == 15.
    lerp 1.0 10. 20. == 20.
  end
end

// proof of 'unlerp(lerp(t,a,b), a, b) = t', no unit tests needed for this
//   unlerp(lerp(t,a,b), a, b)
// = unlerp(((1-t)*a + t*b), a, b)
// = ((((1-t)*a + t*b) - a) / (b - a))
// = ((a - t*a + t*b - a) / (b - a))
// = ((-t*a + t*b) / (b - a)
// = t * (b-a) / (b-a)
// = t
func float unlerp(float t, float a, float b):
  return ((t - a) / (b - a))
end

func float remapRange(
    float t,
    float oldMin, float oldMax,
    float newMin, float newMax):
  return lerp(unlerp t oldMin oldMax, newMin, newMax)
end

func bool op==_eps(float l, float r):
  // stupid value..
  eps := 0.0001
  return (fabsf (l-r) < eps)
end

unittest:testCase remapRange:
  unittest:assertAll:
    remapRange 10.0 10. 20. 50. 100. ==_eps 50.
    remapRange 20.0 10. 20. 50. 100. ==_eps 100.
    remapRange 15.0 10. 20. 50. 100. ==_eps 75.
  end
end

func float smoothstep(float t):
  return ((3. - 2. * t)*(t*t))
end

func float cubicBezier1d(float t, float p0, float p1, float p2, float p3):
  i := 1. - t
  return (i*i*i*p0 + 3.*i*i*t*p1 + 3.*i*t*t*p2 + t*t*t*p3)
end

struct quatf:
  float x y z w
end

func void quatf:makeConjugate(quatf* this):
  this.x = float:neg this.x
  this.y = float:neg this.y
  this.z = float:neg this.z
end

func quatf quatf:conjugate(quatf q):
  conj := q
  quatf:makeConjugate &conj
  ret conj
end

func float quatf:magnitude(quatf q):
  ret sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w)
end

func void quatf:makeNormalized(quatf* this):
  mag := quatf:magnitude *this
  this.x *= mag
  this.y *= mag
  this.z *= mag
  this.w *= mag
end

func quatf quatf:normalized(quatf q):
  r := q
  quatf:makeNormalized &r
  ret r
end

/// adpated from gmtl
func quatf quatf:lerp(float t, quatf a, quatf b):
  // calc cosine theta
  cosom := a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

  // adjust signs (if necessary)
  b2 := b
  if (cosom < 0.0):
    cosom = float:neg cosom
    b2.x = float:neg b2.x
    b2.y = float:neg b2.y
    b2.z = float:neg b2.z
    b2.w = float:neg b2.w
  end

  // Calculate coefficients
  sclp := 0.0
  sclq := 0.0

  if ( (1.0f - cosom) > 0.0001f): // 0.0001 -> some epsillon
    // Standard case (slerp)
    omega := acosf cosom
    sinom := sinf omega // extract theta from dot product's cos theta
    sclp  = sinf( (1.0 - t) * omega) / sinom
    sclq  = sinf( t * omega) / sinom
  else:
    // Very close, do linear interp (because it's faster)
    sclp = 1.0f - t
    sclq = t
  end

  result := undef quatf
  result.x = sclp * a.x + sclq * b2.x
  result.y = sclp * a.y + sclq * b2.y
  result.z = sclp * a.z + sclq * b2.z
  result.w = sclp * a.w + sclq * b2.w
  ret result
end

defineArrayType quatf

func quatf aiQuaternion:quatf(aiQuaternion q):
  ret (structlit quatf x q.x y q.y z q.z w q.w)
end

/// approach by fg
func v3f quatf:rotate(quatf rot, v3f v):
  rot_xyz := mv3f rot.x rot.y rot.z
  t := 2.0 * (rot_xyz *_cross v)
  rv := v + rot.w * t + rot_xyz *_cross t
  ret rv
end

/// axis is the normal (yes, that implies it needs to be normalized!) of the
/// plane of rotation
/// angleRad is the counter clockwise rotation angle (as seen when looking down
/// on the plane of rotation from the direction the normal points to)
func quatf quatf:fromAxisAngle(v3f axis, float angleRad):
  r := undef quatf
  sinr := sinf (0.5 * angleRad)
  cosr := cosf (0.5 * angleRad)

  r.x = axis.x * sinr
  r.y = axis.y * sinr
  r.z = axis.z * sinr
  r.w = cosr

  ret r
end

defineArrayType v3f

///-----------------------------------------------------------------------------
/// Section: events
///-----------------------------------------------------------------------------

defineListType astp

func cstring eventVarName(cstring id):
  ret ("event_" ++ id)
end

macro defineEvent id:
  varname := eventVarName id.id
  ret $:
    var astp_List* #varname null
  end
end

macro onEvent id code:
  varname := eventVarName id.id
  ret $:
    macro mtmp:
      newList := malloc astp_List
      newList.next = #varname
      newList.data = ${#code}
      #varname = newList
      ret ${}
    end
    mtmp
  end
end

macro triggerEvent id:
  varname := eventVarName id.id
  ret $:
    macro mtmp:
      code := ${}
      List:foreach #varname i icode:
        ast:addChild code icode
      end
      ret code
    end
    mtmp
  end
end

///-----------------------------------------------------------------------------
/// Section: initialization
///-----------------------------------------------------------------------------

var AppInfo* app nullptr(AppInfo)

func void myInit():
  if (TwInit(TW_OPENGL, nullptr void) == 0):
    println "AntTweakBar initialization failed, exiting"
    glfwTerminate()
    exit 2
  end
end

/// when the main app starts
defineEvent startup

func void twMoveBar(cstring barName, int left, int top, int right, int bottom):
  leftStr := int2cstring left
  topStr := int2cstring top
  widthStr := int2cstring(right - left)
  heightStr := int2cstring(bottom - top)

  options := barName ++ " position='" ++ leftStr ++ " " ++ topStr ++
      "' size='" ++ widthStr ++ " " ++ heightStr ++ "'"
  TwDefine options
  // TODO clean up memory
  ret
end

///-----------------------------------------------------------------------------
/// Section: event handling
///-----------------------------------------------------------------------------

struct KeyEvent:
  int key
  int action
  double time
  int mouseX mouseY
end

func KeyEvent KeyEvent:default():
  event := undef KeyEvent
  event.key = 0
  event.action = 0
  event.time = 0.0d
  event.mouseX = 0
  event.mouseY = 0
  ret event
end

defineListType KeyEvent

var KeyEvent_List* keyEvents null

func KeyEvent* storeKeyEvent(int key, int action, double time):
  event := malloc KeyEvent_List
  event.data.key = key
  event.data.action = action
  event.data.time = time
  event.next = keyEvents
  keyEvents = event
  ret &event.data
end

func bool fetchNextKeyEvent(KeyEvent* event):
  if isNull(keyEvents):
    return false
  end

  event* = keyEvents*.data
  toDelete := keyEvents
  keyEvents = keyEvents.next
  dealloc toDelete
  return true
end

func void clearKeyEvents():
  ignore := default KeyEvent
  while fetchNextKeyEvent(&ignore):
  end
end

func void onTweakbarError(char* msg):
  println "AntTweakBar error: " msg
end

func void onWindowResize(int newWidth, int newHeight):
  // desiredAspect := toFloat windowWidth / toFloat windowHeight
  // correctHeight := toFloat newWidth / desiredAspect
  // glfwSetWindowSize newWidth toInt(correctHeight)
  // windowWidth = newWidth
  // windowHeight = toInt correctHeight
  // TwWindowSize windowWidth windowHeight

  guiBottom := newHeight * 17 / 20
  twMoveBar "Settings" 0 20 200 guiBottom
  twMoveBar "Shaders" (newWidth-300) 20 (newWidth-2) guiBottom

  app*.windowWidth = newWidth
  app*.windowHeight = newHeight
  glfwSetWindowSize app*.windowWidth app*.windowHeight
  TwWindowSize app*.windowWidth app*.windowHeight

  println "new window size is " app*.windowWidth "x" app*.windowHeight
  
  ret
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

dfunc void timelineOnMouseMove(int x, int y)

func void onMouseMove(int x, int y):
  TwEventMousePosGLFW x y

  timelineOnMouseMove x y

  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos):
  TwEventMouseWheelGLFW pos

  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

func int onKey(int key, int action):
  storeKeyEvent key action glfwGetTime()
  TwEventKeyGLFW key action
  ret 0
end

func int onMouseButton(int button, int action):
  notHandled := 0
  if (TwEventMouseButtonGLFW button action == notHandled):
    event := storeKeyEvent button action glfwGetTime()
    event.mouseX = lastMouseX
    event.mouseY = lastMouseY
  end

  ret 0
end

onEvent startup:
  glfwSetWindowSizeCallback (cast void* &onWindowResize)
  TwHandleErrors &onTweakbarError
  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)
  glfwSetKeyCallback (cast void* &onKey)
  glfwSetMouseButtonCallback (cast void* &onMouseButton)
  glfwSetCharCallback (cast void* &TwEventCharGLFW)
end

///-----------------------------------------------------------------------------
/// Section: code
///-----------------------------------------------------------------------------


func void renderGrid3d(v3f min, v3f max, float step):
  rendergl GL_POINTS:
    ffor x min.x max.x step:
      ffor y min.y max.y step:
        ffor z min.x max.z step:
          glVertex3f x y z
        end
      end
    end
  end
end

macro twgroup bar optionString settings:
  code := ${}
  forEachAstChild s settings:
    if ast:matchesShape(s, ${rw _ _ __}):
      typeId := ast:child s 1
      name := ast:child s 2
      vr := ast:child s 3
      ast:addChild code ${TwAddVarRW #bar #name #typeId (cast void* &#vr) #optionString}
    elseif ast:matchesShape(s, ${separator}):
      ast:addChild code ${TwAddSeparator #bar nullptr(char) #optionString}
    elseif ast:matchesShape(s, ${button _ __ __}):
      buttonName := ast:child s 1
      buttonCallback := ast:child s 2
      buttonClientData := ast:child s 3
      ast:addChild code ${TwAddButton #bar #buttonName #buttonCallback #buttonClientData #optionString}
    else:
      ret ${error "Expected rw TYPE NAME VAR" #s}
    end
  end

  ret code
end

var float rotationSpeed 64.0
var float playbackSpeed 1.0
var float cameraOffsetX 0.
var float cameraOffsetY 2.
var float cameraOffsetZ 10.
var bool wireframe false
var bool showCameraPositions false
var bool showAnimationKeyframes false
/// draw lines from origin to center of each mesh
var bool showMeshPointers false

template abortIf cond onFail:
  if #cond:
    #onFail
    ret 0
  end
end

func GLint loadGLSLShader(cstring vsFileName, cstring fsFileName):
  vsSource := nullptr char
  onReturn (dealloc vsSource)
  if (zompLoadFileToMemory(vsFileName, &vsSource) == -1):
    println "Error: could not load " vsFileName
    return 0
  end
  fsSource := nullptr char
  onReturn (dealloc fsSource)
  if (zompLoadFileToMemory fsFileName &fsSource == -1):
    println "Error: could not load " fsFileName
    dealloc vsSource
    return 0
  end

  shader := createShader "" vsSource fsSource

  return shader
end

//------------------------------------------------------------------------------

func void printGLMatrixStacks():
  modelview_stack_depth := 0
  glGetIntegerv GL_MODELVIEW_STACK_DEPTH &modelview_stack_depth
  println "GL_MODELVIEW_STACK_DEPTH = " modelview_stack_depth
  projection_stack_depth := 0
  glGetIntegerv GL_PROJECTION_STACK_DEPTH &projection_stack_depth
  println "GL_PROJECTION_STACK_DEPTH = " projection_stack_depth
end

func void readGLMatrix(GLenum matrix, float* f16):
  glGetFloatv matrix f16
end

func GLint debugMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_NormalMatrix * gl_Normal;
    }"
  fragmentSource := "
  uniform float dampening;
  uniform float red;
  void main(void) {
    float intensity = 1.0 - dampening;
    gl_FragColor = vec4((normalize(normal)*0.5+vec3(0.5))*intensity,1.0);
    gl_FragColor.r = red;
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func GLint objectMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 wsNormal;
  varying vec3 wsLightDir;
  varying float depth;
  uniform mat4 pj_ModelMatrix;
  uniform mat4 pj_CameraMatrix; // guaranteed to be 'nice'
  "
  vertexSource := "
  vec3 unhomo(vec4 v) { return v.xyz / v.w; }

  void main(void) {
    gl_Position = ftransform();
    // wsNormal = gl_NormalMatrix * gl_Normal;
    wsNormal = (pj_ModelMatrix * vec4(gl_Normal,0.0)).xyz;
    vec3 wsPos = unhomo(pj_ModelMatrix * gl_Vertex);
    vec3 wsLightPos = vec3(10., 10., 10.);
    wsLightDir = wsLightPos - wsPos;
    depth = gl_Position.z;
    }"
  fragmentSource := "
  uniform vec2 red_green;
  uniform float diffuseFactor = 1.0;
  uniform vec3 ambientGroundColor = vec3(0.1,0.2,0.05);
  uniform vec3 ambientSkyColor = vec3(0.,0.,0.2);
  uniform vec4 testColor2 = vec4(0.,0.,0.,0.);
  uniform vec3 fogColor;
  uniform float fogNear;
  uniform float fogFar;

  uniform bool debugEnabled;
  uniform float debugDistance;

  void main(void) {
    // gl_FragColor = vec4(normalize(lightDir) * 0.5 + 0.5, 1.0);
    // gl_FragColor = vec4(length(wsLightDir), length(wsLightDir), length(wsLightDir), 1.0);
    // gl_FragColor = vec4(normalize(wsLightDir)*0.5+vec3(0.5),1.0);
    vec3 diffuse = diffuseFactor * vec3(dot(normalize(wsLightDir), normalize(wsNormal)));

    vec3 ambientHemi = 3.*mix(
        ambientGroundColor,
        ambientSkyColor,
        dot(wsNormal, vec3(0.,1.,0.))*0.5+0.5);

    vec3 color = diffuse + ambientHemi + vec3(red_green.r, red_green.g, 0.);
    float fog = (depth - fogNear) / (fogFar - fogNear);
    fog = min(1.0, max(0.0, fog));

    if( debugEnabled && debugDistance > 0 && abs(depth-debugDistance) < 0.1 ) {
        gl_FragColor = vec4(1.0,0.,0.,1.);
    }
    else {
        gl_FragColor = vec4(mix(color, fogColor, fog*0.8), 1.0);
        // vec4 tc = testColor2;
        // gl_FragColor = vec4(tc.rgb,1.0);
    }
  }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func GLint lambertMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_NormalMatrix * gl_Normal;
    }"
  fragmentSource := "
  uniform vec4 diffuse;
  uniform float scaling;
  void main(void) {
    gl_FragColor = vec4(diffuse.rgb * dot(normal, vec3(0,0,1)) * scaling, 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func GLint ditherMaterial():
  varyingSource := "
    varying vec2 screenpos;
    varying vec3 lightDir;
    varying vec3 normal;
  "
  vertexSource := "
    void main(void) {
        gl_Position = ftransform();
        screenpos = gl_Position.xy / gl_Position.z;
        normal = gl_NormalMatrix * gl_Normal.xyz;

        vec4 vertPos = gl_ModelViewMatrix * gl_Vertex;
        vec4 lightPos = gl_LightSource[0].position;
        lightDir = (lightPos - vertPos).xyz;
    }
  "
  fragmentSource := "
    uniform float amplitude;
    uniform vec2 scale;
    uniform vec4 baseColor;

    float crng(float x) {
        return 0.5 + (x / 2.0);
    }

    float brightnessAt(vec2 pos) {
        return crng( sin(80.0 * pos.y) );
    }

    vec2 distort(vec2 pos) {
        pos *= scale;
        vec2 sinp = vec2(pos.x, pos.y + amplitude * sin(pos.x * 40.0) );
        return sinp;
    }

    void main(void) {
        // vec3 normal2 = normalize(normal);
        // lightDir = normalize(lightDir);
        float n = dot(normalize(normal), normalize(lightDir));
        n = max(0.0, min(1.0, n));
        n += 0.1;

        vec2 newpos = distort(screenpos);
        float threshold = brightnessAt(newpos);

        float diff = max(0.0, n - threshold);
        diff = smoothstep(-0.1, 0.6, diff);

        gl_FragColor = baseColor * diff;
    }
  "
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end


func GLint simplePPMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec2 screenSpaceCoord;
  "
  vertexSource := "
  void main(void) {
      gl_Position = ftransform();
      screenSpaceCoord = gl_Position.xy * 0.5 + vec2(0.5);
    }"
  fragmentSource := "
  uniform sampler2D texture;
  uniform float blurStepDeltaInv;
  void main(void) {
      // gl_FragColor = vec4(screenSpaceCoord.x, screenSpaceCoord.y, 0.0, 1.0);
      // gl_FragColor = texture2D(texture, screenSpaceCoord);
      vec3 color = vec3(0.);
      int blurSteps = 5;
      for(int i = 0; i < blurSteps; ++i) {
          color += texture2D(texture, screenSpaceCoord + vec2(float(i-float(blurSteps/2))/blurStepDeltaInv,0.)).xyz;
      }
      gl_FragColor = vec4(color / float(blurSteps), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func void gluLookAtf(
    float eyex, float eyey, float eyez,
    float cx, float cy, float cz,
    float ux, float uy, float uz):
  gluLookAt
    (toDouble eyex) (toDouble eyey) (toDouble eyez)
    (toDouble cx) (toDouble cy) (toDouble cz)
    (toDouble ux) (toDouble uy) (toDouble uz)
end

func void RBTransform:toMatrix4x4(RBTransform* this, float* mat44):
  mat44[0] = this.xaxis.x * this.scale
  mat44[1] = this.xaxis.y * this.scale
  mat44[2] = this.xaxis.z * this.scale
  mat44[3] = 0.0
  mat44[4] = this.yaxis.x * this.scale
  mat44[5] = this.yaxis.y * this.scale
  mat44[6] = this.yaxis.z * this.scale
  mat44[7] = 0.0
  mat44[8] =  this.zaxis.x * this.scale
  mat44[9] =  this.zaxis.y * this.scale
  mat44[10] = this.zaxis.z * this.scale
  mat44[11] = 0.0
  mat44[12] = this.origin.x
  mat44[13] = this.origin.y
  mat44[14] = this.origin.z
  mat44[15] = 1.0
end

func void applyTransformGL(RBTransform* this):
  // converting to matrix, then applying. not pretty...
  var float[16] mat_
  mat := zmp:array:addr &mat_
  RBTransform:toMatrix4x4 this mat

  glMultMatrixf mat
end

// TODO move to libcee <<<
funcd int toupper(int chr)
funcd int tolower(int chr)

func char char:upperCase(char chr):
  ret toChar(toupper(toInt chr))
end

func char char:lowerCase(char chr):
  ret toChar(tolower(toInt chr))
end
// >>>

struct KeyFrameVector:
  double time
  v3f value
end

ofunc void print(KeyFrameVector kfv):
  print "KeyFrameVector(time=" kfv.time ", value=" kfv.value ")"
end

struct KeyFrameQuat:
  double time
  quatf value
end

ofunc void print(quatf q):
  print "quatf(x=" q.x ", y=" q.y ", z=" q.z ", w=" q.w ")"
end

ofunc void print(KeyFrameQuat kfq):
  print "KeyFrameQuat(time=" kfq.time ", value=" kfq.value ")"
end

func v3f aiVector3D:vec3f(aiVector3D v):
  var v3f r
  r.x = v.x
  r.y = v.y
  r.z = v.z
  ret r
end

ofunc void print(aiVectorKey vk):
  aiVectorKey:print &vk
end

func KeyFrameVector aiVectorKey:toKeyFrameVector(aiVectorKey* this):
  var KeyFrameVector v
  v.time = this.mTime
  v.value = aiVector3D:vec3f this.mValue
  println "input = " *this
  println "outpt = " v
  ret v
end

defineArrayType KeyFrameVector
defineArrayType KeyFrameQuat

struct NodeAnimation:
  float duration //TODO remove
  RBTransform* targetTransform
  // float ticksPerSecond

  float_Array transformTimes
  v3f_Array transformKeyframes
  float_Array scaleTimes
  v3f_Array scaleKeyFrames
  float_Array rotatationTimes
  quatf_Array rotationKeyFrames
end

defineArrayType NodeAnimation

struct Animation:
  NodeAnimation_Array channels
  float duration
  cstring name
  // float ticksPerSecond
end

defineArrayType Animation

struct KeyframeInterpol:
  int first
  /// t in [0,1], result = lerp(t, keyframe first, keyframe first+1)
  float t
end

func KeyframeInterpol KeyframeInterpol:default():
  ret (structlit KeyframeInterpol first 0 t 0.0)
end

func KeyframeInterpol interpolKeyframeAt(float_Array* keyframeTimes, float time):
  rem := time
  // if (this.duration > 0.0)
  //   rem = fmodf time this.duration
  // end
  keyNum := -1
  found := false

  if (keyframeTimes.length == 1):
    ret (structlit KeyframeInterpol first 0 t 0.)
  elseif (keyframeTimes.length == 0):
    ret (structlit KeyframeInterpol first -1 t 0.)
  end

  result := default KeyframeInterpol

  firstFrameTime := aget(keyframeTimes,0)
  if (firstFrameTime < rem):
    while bool:not(found):
      ++keyNum
      if (keyNum >= keyframeTimes.length):
        found = true
      else:
        key := aget(keyframeTimes, keyNum)
        if (key > rem):
          found = true
        end
      end
    end

    if (keyNum < keyframeTimes.length):
      kfpre := aget(keyframeTimes, keyNum - 1)
      kfpost := aget(keyframeTimes, keyNum)
      result.first = keyNum - 1
      result.t = (rem - kfpre) / (kfpost - kfpre)
    else:
      /// ok, because keyframeTimes.length >= 2 checked above
      result.first = keyframeTimes.length - 2
      result.t = 1.0
    end
  end

  ret result
end

func v3f interpolTransform(float_Array* times, v3f_Array* positions, float time):
  assert (positions.length == times.length)

  if (times.length == 1):
    ret aget(positions*,0)
  end

  interp := interpolKeyframeAt times time
  posA := aget(positions, interp.first)
  posB := aget(positions, interp.first+1)
  ret v3f:lerp(interp.t, posA, posB)
end

func v3f NodeAnimation:transformAt(NodeAnimation* this, float time):
  ret interpolTransform(&this.transformTimes, &this.transformKeyframes, time)
end

func v3f NodeAnimation:scaleAt(NodeAnimation* this, float time):
  ret interpolTransform(&this.scaleTimes, &this.scaleKeyFrames, time)
end

func quatf NodeAnimation:rotationAt(NodeAnimation* this, float time):
  if (this.rotatationTimes.length == 1):
    ret aget(this.rotationKeyFrames, 0)
  end

  interp := interpolKeyframeAt &this.rotatationTimes time
  quatA := aget this.rotationKeyFrames interp.first
  quatB := aget this.rotationKeyFrames (interp.first+1)
  ret quatf:lerp(interp.t, quatA, quatB)
end

func void RBTransform:setRotation(RBTransform* this, quatf rot):
  xx := rot.x * rot.x
  xy := rot.x * rot.y
  xz := rot.x * rot.z
  xw := rot.x * rot.w
  yy := rot.y * rot.y
  yz := rot.y * rot.z
  yw := rot.y * rot.w
  zz := rot.z * rot.z
  zw := rot.z * rot.w

  this.xaxis.x = 1. - 2. * (yy + zz)
  this.yaxis.x = 2. * (xy - zw)
  this.zaxis.x = 2. * (xz + yw)
  this.xaxis.y = 2. * (xy + zw)
  this.yaxis.y = 1. - 2. * (xx + zz)
  this.zaxis.y = 2. * (yz - xw)
  this.xaxis.z = 2. * (xz - yw)
  this.yaxis.z = 2. * (yz + xw)
  this.zaxis.z = 1. - 2. * (xx + yy)

  // this.xaxis.x = 1. - 2. * (yy + zz)
  // this.xaxis.y = 2. * (xy - zw)
  // this.xaxis.z = 2. * (xz + yw)
  // this.yaxis.x = 2. * (xy + zw)
  // this.yaxis.y = 1. - 2. * (xx + zz)
  // this.yaxis.z = 2. * (yz - xw)
  // this.zaxis.x = 2. * (xz - yw)
  // this.zaxis.y = 2. * (yz + xw)
  // this.zaxis.z = 1. - 2. * (xx + yy)
end

func void RBTransform:setPosRotScale(RBTransform* this, v3f pos, quatf rot, float scale):
  this.origin = pos
  RBTransform:setRotation this rot
  this.scale = scale
  RBTransform:makeNormalized this
end

func void NodeAnimation:apply(NodeAnimation* this, float time):
  rem := time
  if (this.duration > 0.0):
    rem = fmodf time this.duration
  end

  targetTransform := this.targetTransform
  if isNotNull(targetTransform):
    // scale := mv3f 1.0 1.0 1.0
    // rot := quatf:fromAxisAngle mv3f(0.,1.,0.) 0.
    // pos := mv3f 0. 10. 0.
    scale := NodeAnimation:scaleAt this rem
    rot := NodeAnimation:rotationAt this rem
    pos := NodeAnimation:transformAt this rem
    // pos = pos * scale
    // pos = quatf:rotate rot pos
    RBTransform:setPosRotScale targetTransform pos rot ((scale.x + scale.y + scale.z) / 3.0)
    // RBTransform:makeNormalized targetTransform
  end
end

func void NodeAnimation:init(NodeAnimation* this, aiNodeAnim* source):
  this.duration = 0.0
  this.targetTransform = nullptr RBTransform
  this.transformTimes = *makeArray(float, source.mNumPositionKeys)
  this.transformKeyframes = *makeArray(v3f, source.mNumPositionKeys)
  this.scaleTimes = *makeArray(float, source.mNumScalingKeys)
  this.scaleKeyFrames = *makeArray(v3f, source.mNumScalingKeys)
  this.rotatationTimes = *makeArray(float, source.mNumRotationKeys)
  this.rotationKeyFrames = *makeArray(quatf, source.mNumRotationKeys)

  for transnum 0 source.mNumPositionKeys:
    aikey := *(source.mPositionKeys + transnum)
    var KeyFrameVector key
    key.time = aikey.mTime
    key.value = aiVector3D:vec3f aikey.mValue
    aset this.transformTimes transnum toFloat(key.time)
    aset this.transformKeyframes transnum key.value
  end

  for scalenum 0 source.mNumScalingKeys:
    skey := *(source.mScalingKeys + scalenum)
    aset this.scaleTimes scalenum toFloat(skey.mTime)
    scale := aiVector3D:vec3f(skey.mValue)
    aset this.scaleKeyFrames scalenum scale
    if (float:max(fabsf(scale.x - scale.y), fabsf(scale.x - scale.z)) > 0.0001 * (scale.x + scale.y + scale.z)):
      println "Found non uniform scaling " scale
    end
  end

  for rotnum 0 source.mNumRotationKeys:
    rkey := *(source.mRotationKeys + rotnum)
    aset this.rotatationTimes rotnum toFloat(rkey.mTime)
    aset this.rotationKeyFrames rotnum aiQuaternion:quatf(rkey.mValue)
  end
end

func NodeAnimation* aiNodeAnim:toNodeAnimation(aiNodeAnim* this):
  ret new(NodeAnimation, this)
end

func void Animation:apply(Animation* this, float time):
  for channelNum 0 this.channels.length:
    NodeAnimation:apply (this.channels.elements+channelNum) time
  end
end

struct Color:
  float red green blue
end

func Color color(float red, float green, float blue):
  ret (structlit Color red red green green blue blue)
end

func void renderTimeline(
    float startTime,
    float endTime, int markerCount,
    float* markerPos,
    Color* markerColors):

  if (startTime >= endTime):
    return
  end

  saveAttribs:
    glEnable GL_BLEND
    glBlendFunc GL_ONE GL_SRC_ALPHA
    rendergl GL_QUADS:
      glColor4f 0. 0. 0. 0.4
      xborder := 0.02
      yborder := 0.1
      glVertex2f -xborder -yborder
      glVertex2f (1.+xborder) -yborder
      glVertex2f (1.+xborder) (1.+yborder)
      glVertex2f -xborder (1.+yborder)
    end
  end saveAttribs

  rendergl GL_LINES:
    glColor3f 1. 1. 1.
    glVertex3f 0. 0. 0.
    glVertex3f 1. 0. 0.

    glVertex3f 0. 0. 0.
    glVertex3f 0. 1. 0.

    glVertex3f 1. 0. 0.
    glVertex3f 1. 1. 0.

    fullSecond := startTime - fmodf startTime 1.0
    while (fullSecond < endTime):
      x2 := remapRange(fullSecond, startTime, endTime, 0., 1.)
      glVertex3f x2 0. 0.
      glVertex3f x2 0.1 0.
      fullSecond += 1.0
    end

    pos := markerPos
    color := markerColors
    for markerNum 0 markerCount:
      x := remapRange pos* startTime endTime 0. 1.
      glColor3fv (cast float* color)
      glVertex3f x 0. 0.
      glVertex3f x 1. 0.
      ++pos
      ++color
    end
  end
end

func void scaleTo2dArea(float left, float bottom, float right, float top):
  makeGLIdentityTransforms
  glMatrixMode GL_MODELVIEW
  glTranslatef -1. -1. 0.
  glScalef 2. 2. 1.
  glTranslatef left bottom 0.
  glScalef (right-left) (top-bottom) 1.
end

///-----------------------------------------------------------------------------
/// Section: camera
///-----------------------------------------------------------------------------

struct Camera:
  RBTransform transform
  cstring id
  float horizontalFOV aspect
  float nearPlaneDist farPlaneDist
end

defineArrayType Camera

func void Camera:init(Camera* this):
  makeOrigin &this.transform
  this.id = "-camera-"
  this.horizontalFOV = 60.0
  this.aspect = 1.0
  this.nearPlaneDist = 1.0
  this.farPlaneDist = 100.0
end

func void Camera:print(Camera* this, int indent):
  iprintln indent "Camera '" this.id "'"
  iprintln indent "aspect = " this.aspect
  iprintln indent "horizontalFOV = " this.horizontalFOV
  iprintln indent "nearPlaneDist = " this.nearPlaneDist
  iprintln indent "farPlaneDist = " this.farPlaneDist
  RBTransform:print &this.transform (indent+2)
end

func void Camera:applyGL(Camera* this):
  var float[16] mat_
  mat := zmp:array:addr(&mat_)

  RBTransform:toRotMatrix4x4 &this.transform mat
  glMultMatrixf mat

  RBTransform:toTransMatrix44 &this.transform mat
  glMultMatrixf mat
end

func void Camera:draw(Camera* this):
  rendergl GL_LINES:
    glColor3f 0. 0. 1.
    glVertex this.transform.origin
    glVertex (this.transform.origin - this.transform.zaxis)
    glColor3f 0. 1. 0.
    glVertex this.transform.origin
    glVertex (this.transform.origin + this.transform.yaxis)
  end
end

func bool keyDown(GLint key):
  ret(glfwGetKey key == GLFW_PRESS)
end

func bool mouseButtonDown(int button):
  glfwGetMouseButton button == GLFW_PRESS
end

func void Camera:move(Camera* this, float time):
  delta := mv3f 0. 0. 0.

  if (keyDown GLFW_KEY_A) (delta.x -= 1.0)
  if (keyDown GLFW_KEY_D) (delta.x += 1.0)
  if (keyDown GLFW_KEY_W) (delta.z -= 1.0)
  if (keyDown GLFW_KEY_S) (delta.z += 1.0)
  if (keyDown GLFW_KEY_F) (delta.y -= 1.0)
  if (keyDown GLFW_KEY_R) (delta.y += 1.0)

  speed := 2.0
  rspeed := 2.0
  if (keyDown GLFW_KEY_LSHIFT):
    speed *= 4.0
    rspeed *= 4.0
  elseif (keyDown GLFW_KEY_LCTRL):
    speed *= 0.25
    rspeed *= 0.25
  end

  delta = RBTransform:rotate &this.transform delta
  delta *= time * speed

  rot := mv3f 0. 0. 0.

  if (keyDown GLFW_KEY_UP) (rot.x += 1.0)
  if (keyDown GLFW_KEY_DOWN) (rot.x -= 1.0)
  if (keyDown GLFW_KEY_RIGHT) (rot.y -= 1.0)
  if (keyDown GLFW_KEY_LEFT) (rot.y += 1.0)
  if (keyDown GLFW_KEY_Q) (rot.z += 1.0)
  if (keyDown GLFW_KEY_E) (rot.z -= 1.0)

  rot *= time * rspeed

  if (rot.x != 0.0):
    rx := quatf:fromAxisAngle this.transform.xaxis rot.x
    this.transform.yaxis = quatf:rotate rx this.transform.yaxis
    this.transform.zaxis = quatf:rotate rx this.transform.zaxis
  end
  if (rot.y != 0.0):
    ry := quatf:fromAxisAngle this.transform.yaxis rot.y
    this.transform.xaxis = quatf:rotate ry this.transform.xaxis
    this.transform.zaxis = quatf:rotate ry this.transform.zaxis
  end
  if (rot.z != 0.0):
    rz := quatf:fromAxisAngle this.transform.zaxis rot.z
    this.transform.xaxis = quatf:rotate rz this.transform.xaxis
    this.transform.yaxis = quatf:rotate rz this.transform.yaxis
  end

  this.transform.origin += delta
end

///-----------------------------------------------------------------------------
/// Section: shader parameters
///-----------------------------------------------------------------------------

struct GLSLParameter:
  cstring name
  GLint location
  GLenum gltype
  void* data
end

defineListType GLSLParameter

struct Shader:
  cstring name
  GLint glname
  // GLSLParameter_List* params
end

func void Shader:print(Shader* this, int indent):
  xind := indent+2
  iprintln indent "Shader"
  iprintln xind "name = " this.name
  iprintln xind "glname = " this.glname
  iprintln xind "params = TODO"
end

defineListType Shader

struct Texture:
  GLint glname
  GLenum format
  cstring fileName
  int width heigth
end

defineArrayType Texture

struct Material:
  cstring name
  Texture_Array textures
  // GLint shader
  Shader* shader
  GLSLParameter_List* params

  // some standard parameters
  float[4] ambient diffuse specular emissive
  float shininess
end

defineArrayType Material
defineListType Material
type MaterialPtr Material*
defineListType MaterialPtr

struct ShaderManager:
  Shader_List* shaders
  MaterialPtr_List* materials
  cstring settingsFile
  TwBar* bar
  StringMap* shadersByName
  StringMap* materialsByName
end

func cstring GLSLParameter:valueToString(GLSLParameter* param):
  /// dispatching based on gltype
  if (param.gltype == GL_FLOAT):
    ret float2cstring(*(cast float* param.data))
  elseif (param.gltype == GL_FLOAT_VEC2):
    ret floatArrayToString(2, cast float* param.data)
  elseif (param.gltype == GL_FLOAT_VEC3):
    ret floatArrayToString(3, cast float* param.data)
  elseif (param.gltype == GL_FLOAT_VEC4):
    ret floatArrayToString(4, cast float* param.data)
  elseif (param.gltype == GL_BOOL):
    ret bool2cstring(*(cast bool* param.data))
  end
  ret ""
end

ofunc void print(GLSLParameter param):
  print "(GLSLParameter name='" param.name
  print "', location=" param.location
  print ", type=" glenum2cstring(param.gltype)
  print ", data=" GLSLParameter:valueToString(&param)
  print ")"
end

func void GLSLParameter:apply(GLSLParameter* param):
  /// dispatching based on gltype
  if (param.gltype == GL_FLOAT):
    pFloat := cast float* param.data
    glUniform1f param.location pFloat*
  elseif (param.gltype == GL_FLOAT_VEC2):
    pFloat2 := cast float* param.data
    glUniform2f param.location (pFloat2+0)* (pFloat2+1)*
  elseif (param.gltype == GL_FLOAT_VEC3):
    pFloat3 := cast float* param.data
    glUniform3f param.location (pFloat3+0)* (pFloat3+1)* (pFloat3+2)*
  elseif (param.gltype == GL_FLOAT_VEC4):
    pFloat4 := cast float* param.data
    glUniform4f param.location (pFloat4+0)* (pFloat4+1)* (pFloat4+2)* (pFloat4+3)*
  elseif (param.gltype == GL_BOOL):
    pBool := cast int* param.data
    glUniform1i param.location *pBool
  end
end

func GLSLParameter GLSLParameter:make(cstring name, GLint location, GLenum type):
  var GLSLParameter param
  param.name = strdup(name)
  param.location = location
  param.gltype = type
  /// dispatching based on gltype
  floatCount := 0
  boolCount := 0
  if (type == GL_FLOAT):
    floatCount = 1
  elseif (type == GL_FLOAT_VEC2):
    floatCount = 2
  elseif (type == GL_FLOAT_VEC3):
    floatCount = 3
  elseif (type == GL_FLOAT_VEC4):
    floatCount = 4
  elseif (type == GL_BOOL):
    boolCount = 1
  else:
    param.gltype = 0
  end

  if (floatCount > 0):
    pFloat := malloc float floatCount
    initMemory pFloat 1.0 floatCount
    param.data = cast void* pFloat
  elseif (boolCount > 0):
    pBool := malloc int floatCount
    initMemory pBool 0 boolCount
    param.data = cast void* pBool
  end

  ret param
end

func GLSLParameter* GLSLParameter:findByName(cstring name, GLSLParameter_List* params):
  if isNull(params):
    ret nullptr(GLSLParameter)
  elseif (params.data.name ==_str name):
    ret &params.data
  end
  ret GLSLParameter:findByName(name, params.next)
end

func bool GLSLParameter:isSupportedType(GLenum gltype):
  ret (isOneOf gltype GL_FLOAT GL_FLOAT_VEC2 GL_FLOAT_VEC3 GL_FLOAT_VEC4 GL_BOOL)
end

var int addControlsForUniforms_shaderParamSeq 0

func GLSLParameter_List* addControlsForUniforms(GLenum shader, TwBar* bar, cstring group):
  debugPrinting := false

  paramList := makeList GLSLParameter

  // TODO release memory, again
  optionForFloat := " group='" ++ group ++ "' step=0.1"
  optionGroup := " group='" ++ group ++ "'"

  withShader shader:
    paramNum := 0
    abort := false
    index := 0
    name := malloc char 100
    onReturn dealloc(name)

    if debugPrinting { println "Shader parameters:" }
    while !abort:
      length := 0
      size := 0
      gltype := 0

      glGetActiveUniform shader index 100 &length &size &gltype name
      flushGLErrors()

      if (gltype == 0):
        abort = true
      else:
        if debugPrinting:
          println "  index = " index ", name = " name ", gltype = " glenum2cstring(gltype) ", size = " size
        end

        if (GLSLParameter:isSupportedType gltype):
          location := glGetUniformLocation shader name
          List:prepend GLSLParameter paramList GLSLParameter:make(name, location, gltype)

          GLSLParameter:apply &paramList.data

          dummyName := int2cstring(addControlsForUniforms_shaderParamSeq)
          ++addControlsForUniforms_shaderParamSeq

          explicitSetName := true
          param := paramList.data.data
          if (gltype == GL_FLOAT):
            TwAddVarRW bar dummyName TW_TYPE_FLOAT param optionForFloat
          elseif (gltype == GL_FLOAT_VEC2):
            // TODO investigate why (name++".x") results in ".x"
            TwAddVarRW bar (name ++ ".x") TW_TYPE_FLOAT (param+0) optionForFloat
            TwAddVarRW bar (name ++ ".y") TW_TYPE_FLOAT (param+4) optionForFloat
            explicitSetName = false
          elseif (gltype == GL_FLOAT_VEC3):
            TwAddVarRW bar dummyName TW_TYPE_COLOR3F param optionGroup
          elseif (gltype == GL_FLOAT_VEC4):
            TwAddVarRW bar dummyName TW_TYPE_COLOR4F param optionGroup
          elseif (gltype == GL_BOOL):
            TwAddVarRW bar dummyName TW_TYPE_BOOL32 param optionGroup
          else:
            explicitSetName = false
            println "error: failed to handle type " glenum2cstring(gltype)
          end

          if explicitSetName:
            opts := "Shaders/" ++ dummyName ++ " label='" ++ name ++ "'"
            // println "opts = " opts
            TwDefine opts
          end
        else:
          if debugPrinting { println "  (unsupported type, skipping)" }
        end
      end

      maxParamCount := 100
      if (index > maxParamCount):
        abort = true
        println "warning: max param limit (" maxParamCount ") reached, skipping all following params"
      end

      ++index
    end
  end
  flushGLErrors()
  return paramList
end

func void GLSLParameter:saveParamsToFileDescr(FILE* file, GLSLParameter_List* paramList):
  if isNull(paramList):
    return
  end

  param := &paramList.data

  writeCString file param.name
  writeCString file "="
  str := GLSLParameter:valueToString param
  writeCString file str
  dealloc str
  writeNewline file

  GLSLParameter:saveParamsToFileDescr file paramList.next
end

func void GLSLParameter:saveParamsToFile(cstring fileName, GLSLParameter_List* paramList):
  if !file:makeBackup(fileName):
    println "warning: could not backup shader settings file " fileName
  end

  file := fopen fileName "w"
  GLSLParameter:saveParamsToFileDescr file paramList
  closeFile file
  return
end

func void GLSLParameter:readValueFromFile(GLSLParameter* this, FILE* file):
  debugPrinting := false

  bufferSize := 100
  buffer := malloc char bufferSize

  readSomething := true

  /// dispatching based on gltype
  if (this.gltype == GL_FLOAT):
    value := 0.0
    readFloat file (cast float* this.data)
  elseif (this.gltype == GL_FLOAT_VEC2):
    readFloatsFromFile file 2 (cast float* this.data)
  elseif (this.gltype == GL_FLOAT_VEC3):
    readFloatsFromFile file 3 (cast float* this.data)
  elseif (this.gltype == GL_FLOAT_VEC4):
    readFloatsFromFile file 4 (cast float* this.data)
  elseif (this.gltype == GL_BOOL):
    readInt file (cast int* this.data)
  else:
    readSomething = false
  end

  if (debugPrinting && readSomething):
    println "read new value for " this*
  end

  // skip until end of line
  readUntil(file, '\n', bufferSize, &buffer)

  dealloc buffer

  return
end

func void GLSLParameter:readFromString(GLSLParameter* this, cstring str):
  readSomething := true
  fdata := cast float* this.data
  if (this.gltype == GL_FLOAT):
    *fdata = parseFloat(str)
  elseif (this.gltype == GL_FLOAT_VEC2):
    parseFloats(str, 2, fdata)
  elseif (this.gltype == GL_FLOAT_VEC3):
    parseFloats(str, 3, fdata)
  elseif (this.gltype == GL_FLOAT_VEC4):
    parseFloats(str, 4, fdata)
  // elseif (this.gltype == GL_BOOL):
  //   readInt file (cast int* this.data)
  else:
    readSomething = false
  end
end

func void GLSLParameter:loadParamsFromFile(cstring fileName, GLSLParameter_List* paramList):
  file := fopen fileName "r"
  if isNull(file):
    return
  end

  eof := false

  maxNameLength := 100
  name := malloc char maxNameLength
  onReturn dealloc(name)

  while !eof:
    eof = !readUntil(file, '=', maxNameLength, &name)
    unless eof:
      param := GLSLParameter:findByName(name, paramList)
      if isNotNull(param):
        GLSLParameter:readValueFromFile(param, file)
      end
    end
  end

  closeFile file
  return
end

func void ShaderManager:init(ShaderManager* this, cstring settingsFile, TwBar* bar):
  this.shaders = nullptr Shader_List
  this.settingsFile = settingsFile
  this.bar = bar
  this.shadersByName = StringMap_new()
  this.materials = nullptr MaterialPtr_List
  this.materialsByName = StringMap_new()
end

func Shader* ShaderManager:add(ShaderManager* this, GLint glname, cstring name):
  var Shader shader
  shader.name = name
  shader.glname = glname
  // shader.params = nullptr GLSLParameter_List

  List:prepend Shader this.shaders shader

  shaderList := this.shaders
  shaderp := &shaderList.data
  StringMap_insert this.shadersByName name (cast void* &(shaderList.data))

  tmp := this.shaders
  ret &tmp.data
end

func void ShaderManager:delete(ShaderManager* this):
  StringMap_delete this.shadersByName
end

func void ShaderManager:dump(ShaderManager* this):
  StringMap_debugPrint this.shadersByName
end

func void ShaderManager:createControls(ShaderManager* this):
  List:foreach this.materials shaderNum material:
    shader := material.shader
    // println "adding controls for " material.name
    material.params = addControlsForUniforms shader.glname this.bar material.name

    List:foreach material.params paramNum param:
      v4ptr := nullptr float
      if (param.name ==_str "diffuse" && param.gltype == GL_FLOAT_VEC4):
        v4ptr = cast float* &material.diffuse
        // Material:print material 2
        // print "setting diffuse to "
      end

      value := cast float* param.data
      if isNotNull(v4ptr):
        for i 0 4:
          value[i] = *(v4ptr + i)
          // print *(value + i) " "
        end
        // println()
      end
    end
  end
end

func void ShaderManager:addMaterial(ShaderManager* this, Material* material):
  if isNotNull(material.shader):
    println "warning: material " material.name " added twice"
    return
  end

  // split into instance and shader name
  shaderNameEnd := strstr material.name "__"
  if isNotNull(shaderNameEnd):
    instanceName := shaderNameEnd + 2
    instanceNameLength := strlen(instanceName)
    // TODO: allow to take the difference between two pointers
    shaderNameLength := strlen(material.name) - strlen(instanceName) - 2
    // TODO: release memory
    shaderName := malloc char (shaderNameLength + 1)
    memcpy(cast void* shaderName, cast void* material.name, shaderNameLength)
    shaderName[shaderNameLength] = '\0'

    shader := cast Shader* StringMap_find(this.shadersByName, shaderName)

    if isNotNull(shader):
      material.shader = shader
      List:prepend MaterialPtr this.materials material
      StringMap_insert this.materialsByName material.name (cast void* material)
    else:
      println "warning: could not find shader " shaderName " for material " material.name
    end
  else:
    println "warning: Could not detect shader/instance name for material "
      material.name ". Name should follow pattern shader__instance"
  end
end

func void ShaderManager:addMaterialArray(ShaderManager* this, Material_Array* materials):
  Array:foreach2 materials matnum mat:
    ShaderManager:addMaterial(this, mat)
  end
end


func Shader* Shader:createFromGL(GLenum glname, cstring name):
  shader := malloc Shader
  shader.glname = glname
  shader.name = name
  // shader.params = nullptr(GLSLParameter_List)
  ret shader
end

func void Shader:delete(Shader* this):
  glDeleteProgram this.glname
  // delete param list
  // delete name string
end

func Shader* createObjectMaterial():
  ret Shader:createFromGL( objectMaterial(), "default-material" )
end

func Shader* createSimplePPMaterial():
  ret Shader:createFromGL( simplePPMaterial(), "simple-pp-material" )
end

/// only shader params atm.
func Section* Material:serializeParams(Material* this):
  sec := new Section this.name

  paramI := this.params
  while !isNull(paramI):
    param := &paramI.data
    value := GLSLParameter:valueToString param
    StringMap_insert sec.settings param.name (cast void* value)

    paramI = paramI.next
  end

  return sec
end

func Section* ShaderManager:serializeParams(ShaderManager* this):
  sec := new Section ""

  matR := StringMap_range(this.materialsByName)
  while StringMapRange_hasNext(matR):
    name := StringMapRange_key(matR)
    value := cast Material* StringMapRange_value(matR)

    matsec := Material:serializeParams value
    StringMap_insert(sec.subsections, name, cast void* matsec)

    StringMapRange_next(matR)
  end
  return sec
end

func void Material:applyParams(Material* this, Section* section):
  settingR := StringMap_range(section.settings)
  while StringMapRange_hasNext(settingR):
    name := StringMapRange_key(settingR)
    value := cast cstring StringMapRange_value(settingR)

    param := GLSLParameter:findByName name this.params
    if isNotNull(param):
      GLSLParameter:readFromString param value
    end

    StringMapRange_next(settingR)
  end
end

func void ShaderManager:applySettings(ShaderManager* this, Section* section):
  matR := StringMap_range section.subsections
  while StringMapRange_hasNext(matR):
    name := StringMapRange_key(matR)
    value := cast Section* StringMapRange_value(matR)

    mat := cast Material* StringMap_find(this.materialsByName, name)
    if !isNull(mat):
      Material:applyParams(mat, value)
    end

    StringMapRange_next(matR)
  end
end

///-----------------------------------------------------------------------------
/// Section: scene graph
///-----------------------------------------------------------------------------

struct MeshInfo:
  Mesh mesh
  cstring id
  RBTransform transform
  Material* material
end

defineListType Mesh
defineListType MeshInfo
defineArrayType MeshInfo

struct SceneGraphNode:
  RBTransform globalSpace
  RBTransform relativeTransform
  int_Array meshes
  cstring id
end

struct CameraInfo:
  Camera camera
  SceneGraphNode* parentNode
  // TODO: maintain original relative transform of the aiCamera
end

defineArrayType CameraInfo

defineArrayType SceneGraphNode

struct SceneGraphEdge:
  int parent child
end

defineArrayType SceneGraphEdge
defineListType SceneGraphEdge
defineArrayType Mesh

// ofunc bool op==(aiString aistr, cstring str):
//   ret false
// end

func bool op==_aistr(aiString aistr, cstring str):
  ret (strcmp(cast cstring &aistr.data, str) == 0)
end

var cstring aiMaterial:propName "?mat.name"
var cstring aiMaterial:propAmbient "$clr.ambient"
var cstring aiMaterial:propDiffuse "$clr.diffuse"
var cstring aiMaterial:propSpecular "$clr.specular"
var cstring aiMaterial:propEmissive "$clr.emissive"
var cstring aiMaterial:propShininess "$mat.shininess"
var cstring aiMaterial:propTextureFile "$tex.file"

func void Texture:print(Texture* this, int indent):
  xind := indent + 2
  iprintln indent "Texture"
  iprintln xind "file name = " this.fileName
  iprintln xind "glname = " this.glname
  iprintln xind "size = " this.width "x" this.heigth
  iprintln xind "format = " glenum2cstring(this.format)
end

func void iprintlnFloat4WName(int indent, cstring name, float[4] v):
  printIndent indent
  v2 := zmp:array:addr &v
  println name " = [" v2[0] ", " v2[1] ", " v2[2] ", " v2[3] "]"
end

func void Material:print(Material* this, int indent):
  xind := indent + 2
  iprintln indent "Material"
  iprintln xind "name = '" this.name "'"
  iprintlnFloat4WName xind "ambient" this.ambient
  iprintlnFloat4WName xind "diffuse" this.diffuse
  iprintlnFloat4WName xind "specular" this.specular
  iprintlnFloat4WName xind "emissive" this.emissive
  iprintln xind "shininess = " this.shininess
  if isNull(this.shader):
    iprintln xind "shader = null"
  else:
    Shader:print this.shader xind
  end
  iprintArray this.textures "textures" Texture:print xind
end

ofunc void print(aiString s):
  s2 := s
  aiString:print(&s2)
end

func void reportUnhandledMaterialProperty(aiMaterialProperty* prop, cstring reason):
  println "Did not handle material property '" prop.mKey "' of type '"
      aiPropertyTypeInfo:toCString(prop.mType) "': " reason
end

func void Material:initFromAI(Material* this, aiMaterial* aimat):
  this.name = nullptr char
  Texture_Array:init &this.textures 0
  this.shader = nullptr Shader
  this.params = nullptr GLSLParameter_List

  black := arraylit float 0.0 0.0 0.0 0.0
  this.ambient = black
  this.diffuse = black
  this.specular = black
  this.emissive = black
  this.shininess = 0.0

  for propnum 0 aimat.mNumProperties:
    prop := *(aimat.mProperties + propnum)
    if (prop.mType == aiPTI_String):
      strdata := cast aiString* prop.mData
      if (prop.mKey ==_aistr aiMaterial:propName):
        this.name = aiString:cstring strdata
      elseif (prop.mKey ==_aistr aiMaterial:propTextureFile):
        textureFileName := aiString:cstring strdata
        println "texture file = " textureFileName
      else:
        reportUnhandledMaterialProperty(prop, "unknown key")
      end
    elseif (prop.mType == aiPTI_Float && prop.mDataLength == 16):
      rgba := *(cast float[4]* prop.mData)
      if (prop.mKey ==_aistr aiMaterial:propAmbient):
        this.ambient = rgba
      elseif (prop.mKey ==_aistr aiMaterial:propDiffuse):
        this.diffuse = rgba
      elseif (prop.mKey ==_aistr aiMaterial:propSpecular):
        this.specular = rgba
      elseif (prop.mKey ==_aistr aiMaterial:propEmissive):
        this.emissive = rgba
      else:
        reportUnhandledMaterialProperty(prop, "unknow key")
      end
    else:
      reportUnhandledMaterialProperty(prop, "unknown type")
    end
  end

  unless isNull(this.name):
    shaderNameEnd := strstr this.name "__"
    if isNotNull(shaderNameEnd):
      instanceName := shaderNameEnd + 2
      instanceNameLength := strlen(instanceName)
      // TODO: allow to take the difference between two pointers
      shaderNameLength := strlen(this.name) - strlen(instanceName) - 2
      shaderName := malloc char (shaderNameLength + 1)
      memcpy(cast void* shaderName, cast void* this.name, shaderNameLength)
      shaderName[shaderNameLength] = '\0'

      // println "shader = '" shaderName "', instance '" instanceName "'"
      dealloc shaderName
    else:
      println "could not detect shader/instance name for material " this.name
    end
  end

  // unless isNull(this.name):
  //   // println "loaded material " this.name
  //   Material:print this 2
  // end
end

struct SceneGraph:
  SceneGraphNode_Array nodes
  SceneGraphEdge_Array edges
  MeshInfo_Array meshes
  Animation_Array animations
  CameraInfo_Array cameras
  Material_Array materials
end

//--- functions

func MeshInfo_Array collectMeshes(aiScene* scene):
  var MeshInfo_Array meshes
  MeshInfo_Array:init &meshes scene.mNumMeshes

  for meshnum 0 scene.mNumMeshes:
    aimesh := *(scene.mMeshes+meshnum)
    info := meshes.elements + meshnum
    newMesh := aiMesh:toMesh aimesh
    info.mesh = newMesh*
    info.id = ""
    makeOrigin &info.transform
  end

  ret meshes
end

func MeshInfo* lookupMesh(MeshInfo_Array meshes, cstring id):
  Array:foreach meshes num:
    mesh := meshes.elements + num
    if (mesh.id ==_str id):
      ret mesh
    end
  end
  ret nullptr(MeshInfo)
end

func void SceneGraphEdge:init(SceneGraphEdge* this, int parent, int child):
  this.parent = parent
  this.child = child
end


func void SceneGraphEdge:print(SceneGraphEdge* this):
  println this.parent " -> " this.child
end

ofunc void print(SceneGraphEdge edge):
  SceneGraphEdge:print &edge
end

func void SceneGraphNode:init(SceneGraphNode* this, aiNode* source):
  makeOrigin &this.globalSpace
  // makeOrigin &this.relativeTransform
  this.relativeTransform = aiMatrix4x4:toRBTransform &source.mTransformation
  int_Array:init &this.meshes source.mNumMeshes
  Array:foreach this.meshes meshNum:
    aset this.meshes meshNum *(source.mMeshes + meshNum)
  end
  this.id = aiString:cstring &source.mName
end

func int SceneGraphNode:lookup(SceneGraphNode_Array* this, cstring id):
  Array:foreach this nodeNum:
    node := aptr this nodeNum
    if (node.id ==_str id):
      ret nodeNum
    end
  end
  ret -1
end

func void CameraInfo:init(CameraInfo* this, aiCamera* aicam, SceneGraphNode_Array* nodes):
  Camera:init &this.camera
  this.camera.id = aiString:cstring(&aicam.mName)
  parentNodeIndex := SceneGraphNode:lookup nodes this.camera.id
  if (parentNodeIndex >= 0):
    this.parentNode = aptr(nodes, parentNodeIndex)
  else:
    this.parentNode = nullptr SceneGraphNode
  end
end

func void "print_void*"(void* ptr):
  printPtr ptr
end

func void SceneGraph:collectNodes(
    SceneGraph* this,
    aiNode* source,
    int* nodeNum,
    int* edgeNum,
    SceneGraphEdge_List** edges,
    RBTransform parentTransform):

  node := aptr this.nodes nodeNum*
  SceneGraphNode:init node source

  node.relativeTransform = aiMatrix4x4:toRBTransform &source.mTransformation
  node.globalSpace = RBTransform:concat &parentTransform &node.relativeTransform

  parentIndex := nodeNum*
  nodeNum* += 1
  for childNum 0 source.mNumChildren:
    childIndex := nodeNum*
    // relTransform := aiMatrix4x4:toRBTransform &srcNode.mTransformation
    // childTransform := RBTransform:concat &transform &relTransform
    srcNode := *(source.mChildren + childNum)
    SceneGraph:collectNodes this srcNode nodeNum edgeNum edges node.globalSpace

    pParent := aptr this.nodes parentIndex
    pChild := aptr this.nodes childNum

    edge := local SceneGraphEdge parentIndex childIndex
    edgeList := new SceneGraphEdge_List *edge edges*
    edges* = edgeList
  end
end

func void MeshInfo:print(MeshInfo* this, int indent):
  iprintln indent "MeshInfo '" this.id "':"
  Mesh:print &this.mesh (indent+2)
  RBTransform:print &this.transform (indent+2)
  mat := this.material
  if isNotNull(mat):
    iprintln (indent+2) "material = " mat.name
  else:
    iprintln (indent+2) "material = null"
  end
end

func void SceneGraphNode:print(SceneGraphNode* this, int indent):
  printIndent indent
  print "SceneGraphNode('" this.id "', " this.meshes.length " meshes = ["
  for num 0 this.meshes.length:
    if (num > 0):
      print ", "
    end
    print aget(this.meshes, num)
  end
  println "])"
  iprintln indent "  relativeTransform =:"
  RBTransform:print &this.relativeTransform (indent+4)
  iprintln indent "  globalSpace =:"
  RBTransform:print &this.globalSpace (indent+4)
end

func void SceneGraphNode:printUnindented(SceneGraphNode* this):
  SceneGraphNode:print this 0
end

func void NodeAnimation:print(NodeAnimation* this, int indent):
  iprint indent "NodeAnimation(" this.transformKeyframes.length
  print "/" this.rotationKeyFrames.length "/" this.scaleKeyFrames.length
  if isNull(this.targetTransform):
    print " no target!"
  end
  println ")"
  Array:foreach this.transformKeyframes tnum:
    pos := aget this.transformKeyframes tnum
    ttime := aget this.transformTimes tnum
    iprintln (indent+2) "time=" ttime ", pos=" pos
  end
  Array:foreach this.scaleKeyFrames snum:
    scale := aget this.scaleKeyFrames snum
    stime := aget this.scaleTimes snum
    iprintln (indent+2) "time=" stime ", scale=" scale
  end
  Array:foreach this.rotationKeyFrames rnum:
    rot := aget this.rotationKeyFrames rnum
    rtime := aget this.rotatationTimes rnum
    iprintln (indent+2) "time=" rtime ", rot=" rot
  end
end

func void Animation:print(Animation* this, int indent):
  iprintln indent "Animation '" this.name "', duration=" this.duration
  iprintArray this.channels "channels" NodeAnimation:print (indent+2)
end

func cstring SceneGraph:nodeName(SceneGraph* this, int nodeNum):
  if (nodeNum < 0 || nodeNum >= this.nodes.length):
    ret "-out of bounds-"
  end

  pNode := aptr this.nodes nodeNum
  ret pNode.id
end

func void CameraInfo:print(CameraInfo* this, int indent):
  iprint indent "CameraInfo"
  if isNull(this.parentNode):
    print "(connected)"
  else:
    println "(not in scene graph)"
  end
  Camera:print &this.camera (indent+2)
end

func void SceneGraph:print(SceneGraph* this, int indent):
  iprintln indent "SceneGraph:"

  iprintArray this.nodes "nodes" SceneGraphNode:print (indent+2)
  iprintln (indent+2) this.edges.length " edges:"
  Array:foreach this.edges edgeNum:
    edge := aptr this.edges edgeNum
    iprintln (indent+2) "  " SceneGraph:nodeName(this, edge.parent)
        " (nr. " edge.parent ") -> " SceneGraph:nodeName(this, edge.child)
        "(nr. " edge.child ")"
  end
  iprintArray this.animations "animations" Animation:print (indent+2)
  iprintArray this.meshes "meshes" MeshInfo:print (indent+2)
  iprintArray this.cameras "cameras" CameraInfo:print (indent+2)
  iprintArray this.materials "materials" Material:print (indent+2)
end

func void Animation:init(Animation* this, aiAnimation* source, SceneGraphNode_Array nodes):
  this.duration = toFloat source.mDuration
  this.name = aiString:cstring &source.mName
  NodeAnimation_Array:init &this.channels source.mNumChannels
  Array:foreach this.channels channelNum:
    channel := this.channels.elements + channelNum
    aianim := *(source.mChannels+channelNum)
    NodeAnimation:init channel aianim
    channel.duration = toFloat this.duration

    /// connect to target node
    name := aiString:cstring &aianim.mNodeName
    nodeNum := SceneGraphNode:lookup &nodes name
    if (nodeNum >= 0):
      node := aptr nodes nodeNum
      channel.targetTransform = fieldptr node relativeTransform
    else:
      println "warning, could not connect anim channel " this.name
    end
  end
end

func void SceneGraph:init(SceneGraph* this, aiScene* source):
  /// materials

  Material_Array:init &this.materials source.mNumMaterials
  Array:foreach this.materials matnum:
    aimat := *(source.mMaterials + matnum)
    mat := aptr this.materials matnum
    Material:initFromAI mat aimat
  end

  /// meshes
  MeshInfo_Array:init &this.meshes source.mNumMeshes

  Array:foreach this.meshes meshNum:
    aimesh := *(source.mMeshes + meshNum)
    newMesh := aiMesh:toMesh aimesh
    info := aptr this.meshes meshNum
    info.mesh = newMesh*
    info.id = "- SceneGraph mesh-"
    info.material = aptr this.materials aimesh.mMaterialIndex
    makeOrigin &info.transform
  end

  /// nodes and edges
  SceneGraphNode_Array:init &this.nodes aiScene:totalNodeCount(source)
  nodeNum := 0
  edgeNum := 0
  edgeList := nullptr SceneGraphEdge_List
  SceneGraph:collectNodes
      this source.mRootNode &nodeNum &edgeNum &edgeList RBTransform:identity()
  edgeCount := 0
  List:length edgeCount edgeList
  SceneGraphEdge_Array:init &this.edges edgeCount
  List:foreach_ptr edgeList edgeNum2 pEdge:
    aset this.edges edgeNum2 pEdge*
  end

  // TODO: find nodes using the same mesh with different transform matrices,
  // add relative transforms or split those meshes (maybe even consider animations?)

  /// animations
  Animation_Array:init &this.animations source.mNumAnimations
  Array:foreach this.animations animNum:
    anim := aptr(this.animations, animNum)
    Animation:init anim *(source.mAnimations+animNum) this.nodes
  end

  /// cameras
  CameraInfo_Array:init &this.cameras source.mNumCameras
  Array:foreach this.cameras camNum:
    camInfo := aptr this.cameras camNum
    CameraInfo:init camInfo *(source.mCameras+camNum) &this.nodes
  end
end

func void SceneGraph:updateTransforms(SceneGraph* this):
  /// apply hierarchical node transforms
  if (this.nodes.length > 0):
    rootNode := aptr this.nodes 0
    rootNode.globalSpace = rootNode.relativeTransform
  end

  Array:foreach this.edges edgeNum:
    edge := aget this.edges edgeNum
    parent := aptr this.nodes edge.parent
    child := aptr this.nodes edge.child
    child.globalSpace = RBTransform:concat &parent.globalSpace &child.relativeTransform
  end

  /// apply mesh transforms
  Array:foreach this.nodes nodeNum:
    node := aptr this.nodes nodeNum
    Array:foreach node.meshes meshNum:
      meshIndex := aget node.meshes meshNum
      info := aptr this.meshes meshIndex
      info.transform = node.globalSpace
    end
  end

  /// apply transforms to cameras
  Array:foreach2 this.cameras camNum camInfo:
    unless isNull(camInfo.parentNode):
      t := camInfo*.parentNode*.globalSpace
      camInfo.camera.transform = t
    end
  end
end

func void SceneGraph:visualizeCameras(SceneGraph* this):
  glMatrixMode GL_MODELVIEW
  Array:foreach2 this.cameras camNum camInfo:
    unless isNull(camInfo*.parentNode):
      t := camInfo*.parentNode*.globalSpace
      glPushMatrix()
      applyTransformGL &t
      // drawCoordSys 1.0
      rendergl GL_LINES:
        glColor3f 1. 0.4 0.0
        glVertex3f 0. 0. 0.
        glVertex3f 0.5 0. 0.
        glVertex3f 0. 0. 0.
        glVertex3f 0. 1. 0.
        glColor3f 1. 0.8 0.0
        glVertex3f 0. 0. 0.
        glVertex3f 0. 0. -1.
      end
      glPopMatrix()
    end
  end
end

func void RBTransform:visualize(RBTransform* this):
  rendergl GL_LINES:
    glColor3f 1. 0. 0.
    glVertex this.origin
    glVertex (this.origin + this.xaxis)
    glColor3f 0. 1. 0.
    glVertex this.origin
    glVertex (this.origin + this.yaxis)
    glColor3f 0. 0. 1.
    glVertex this.origin
    glVertex (this.origin + this.zaxis)
  end
end

func void visualizeTransform(v3f origin, v3f xaxis, v3f yaxis, v3f zaxis, v3f scale):
  rendergl GL_LINES:
    glColor3f 1. 0. 0.
    glVertex origin
    glVertex (origin + xaxis * scale.x)
    glColor3f 0. 1. 0.
    glVertex origin
    glVertex (origin + yaxis * scale.y)
    glColor3f 0. 0. 1.
    glVertex origin
    glVertex (origin + zaxis * scale.z)
  end
end

func void NodeAnimation:visualize(NodeAnimation* this):
  count := this.transformKeyframes.length
  assert (count == this.rotationKeyFrames.length)
  assert (count == this.scaleKeyFrames.length)

  for kfnum 0 count:
    pos := aget this.transformKeyframes kfnum
    rot := aget this.rotationKeyFrames kfnum
    scale := aget this.scaleKeyFrames kfnum
    transform := undef RBTransform
    RBTransform:setPosRotScale &transform pos rot 1.0
    visualizeTransform pos transform.xaxis transform.yaxis transform.zaxis scale
  end

  rendergl GL_LINE_STRIP:
    glColor3f 1. 0.4 0.
    for kfnum2 0 count:
      pos2 := aget this.transformKeyframes kfnum2
      rot2 := aget this.rotationKeyFrames kfnum2
      scale2 := aget this.scaleKeyFrames kfnum2
      transform2 := undef RBTransform
      RBTransform:setPosRotScale &transform2 pos2 rot2 1.0
      glVertex transform2.origin
    end
  end
end

func void Animation:visualize(Animation* this):
  Array:foreach2 this.channels num channel:
    NodeAnimation:visualize channel
  end
end

///-----------------------------------------------------------------------------
/// Section: application and unsorted stuff
///-----------------------------------------------------------------------------

var float angle 0.0
var int visAnim -1
var int visNodeAnim 0
var int camNum 0

var float farPlaneFactor 1.0
var float nearPlaneFactor 1.0
var float keyboardCamSpeedFactor 1.0

func float deg2rad(float degree):
  degree * math:pi * 2.0 / 360.0
end

func void renderRotationTest():
  trans := local RBTransform
  trans.origin = mv3f 1.5 3.5 0.5
  rotQ := quatf:fromAxisAngle mv3f(0.,1.,0.) toFloat(0.5d * glfwGetTime())
  // rotQ := quatf:fromAxisAngle mv3f(0.,1.,0.) 0.0
  RBTransform:setRotation trans rotQ
  // trans.xaxis = quatf:rotate rotQ trans.xaxis
  // trans.yaxis = quatf:rotate rotQ trans.yaxis
  // trans.zaxis = quatf:rotate rotQ trans.zaxis

  trans2 := local RBTransform
  trans2.origin = mv3f 1. 0. 0.

  global := RBTransform:concat trans trans2

  saveTransforms:
    applyTransformGL &global
    glColor3f 1. 0. 0.
    drawCoordSys 1.0
  end
end

var RBTransform* keyboardCameraOrientation null
var GLSLParameter_List* shaderParameterValues null

func void printlnMatrix44(float* mat, int indent):
  times indent printChar(' ')
  println (mat+0)* " " (mat+4)* " " (mat+8)* " " (mat+12)*
  times indent printChar(' ')
  println (mat+1)* " " (mat+5)* " " (mat+9)* " " (mat+13)*
  times indent printChar(' ')
  println (mat+2)* " " (mat+6)* " " (mat+10)* " " (mat+14)*
  times indent printChar(' ')
  println (mat+3)* " " (mat+7)* " " (mat+11)* " " (mat+15)*
end

/// ripped from lighting.zomp
macro showTextures textureList:
  count := textureList.childCount
  code := ${}

  width := 1.0 / toFloat count
  height := width

  x := 0.
  y := 0.

  forEachAstChild tex textureList:
    ast:addChild code ${showTextureAt #tex #x #y #width #height}
    x = x + width
  end

  ret code
end

func void onPlayPauseButton(void* ignored):
  if (playbackSpeed <= 0.0):
    playbackSpeed = 1.0
  else:
    playbackSpeed = 0.0
  end
end

///-----------------------------------------------------------------------------
/// Section: Timeline
///-----------------------------------------------------------------------------

struct Timeline:
  float* currentTime
  float totalTime

  float startTime
  float endTime

  float restrictedStartTime restrictedEndTime

  Rect screenPos
end

func void Timeline:init(Timeline* this, float totalTime, float* currentTime):
  this.currentTime = currentTime
  this.startTime = 0.2
  this.endTime = 0.4
  this.totalTime = totalTime
  this.screenPos = makeRect 0.03 0.03 0.97 0.13
  this.restrictedStartTime = this.startTime
  this.restrictedEndTime = this.endTime
end

func void Timeline:render(Timeline* this):
  // glColor3f 0. 1. 1.
  // rendergl GL_LINES:
  //   glVertex2f this.screenPos.left this.screenPos.top
  //   glVertex2f this.screenPos.right this.screenPos.bottom
  // end

  saveAttribs:
    glDisable GL_DEPTH_TEST
    scaleTo2dArea this.screenPos.left this.screenPos.top
        this.screenPos.right this.screenPos.bottom
    markers := malloc float 3
    colors := malloc Color 3
    onReturn:
      dealloc markers
      dealloc colors
    end
    markers[0] = *(this.currentTime)
    colors[0] = color 0.3 0.8 0.2
    markers[1] = this.startTime
    colors[1] = color 0.6 0.3 0.0
    markers[2] = this.endTime
    colors[2] = color 0.6 0.3 0.0
    renderTimeline 0. this.totalTime 3 markers colors
  end
end

struct FrameStat:
  int size
  int first
  float* data
end

func void FrameStat:init(FrameStat* this, int size):
  this.size = size
  this.data = malloc float size

  for i 0 size:
    value := cosf(toFloat i * 0.1)
    this.data[i] = value
  end
end

func void FrameStat:delete(FrameStat* this):
  dealloc this.data
  this.data = nullptr float
  this.size = 0
  this.first = 0
end

func void FrameStat:write(FrameStat* this, float newValue):
  idx := this*.first
  this*.data[idx] = newValue
  // this*.data[this*.first] = newValue
  // this.first = (this.first + 1) % this.size
end

var float averageFPS 0.0

func void FrameStat:render(FrameStat* this, Rect area):
  dx := 1.0 / toFloat this.size

  maxy := -10000.0
  miny := 10000.0
  total := 0.0
  for i1 0 this.size:
    miny = float:min miny this.data[i1]
    maxy = float:max maxy this.data[i1]
    total += this.data[i1]
  end
  averageFPS = total / toFloat this.size

  // glqtPrintfAt 0. 0. 0. 10.0 "foobar"

  glColor3f 1. 1. 0.
  rendergl GL_LINE_STRIP:
    for i 0 this.size:
      x := toFloat i * dx
      // y := 0.5
      idx := (i + this.first) % this.size
      y := this.data[idx] * 3.0
      // y := remapRange this.data[idx] miny maxy 0.0 1.0
      glVertex2f x y
    end
  end
end

var int timelineSelectedItem -1
var Timeline* timeline null
var float timelineLastButtonClickTime 0.0

func void timelineOnMouseMove(int x, int y):
  if isNull(timeline):
    return
  end

  csMouseX := toFloat x / toFloat app*.windowWidth
  csMouseY := toFloat (app*.windowHeight - y) / toFloat app*.windowHeight
  if insideRect(csMouseX, csMouseY, &timeline.screenPos):
    relativePos &csMouseX &csMouseY &timeline.screenPos
    if (timelineSelectedItem == 0):
      timeline.startTime = csMouseX * timeline.totalTime
      timeline.restrictedStartTime = timeline.startTime
    elseif (timelineSelectedItem == 1):
      timeline.endTime = csMouseX * timeline.totalTime
      timeline.restrictedEndTime = timeline.endTime
    elseif (timelineSelectedItem == 2):
      (timeline.currentTime)* = csMouseX * timeline.totalTime
    end
  end
end

var float doubleClickTime 0.3

func void onTimelineButton(KeyEvent* keyEvent):
  csMouseX := toFloat keyEvent.mouseX / toFloat app*.windowWidth
  csMouseY := toFloat (app*.windowHeight - keyEvent.mouseY) / toFloat app*.windowHeight

  if (keyEvent.action == GLFW_PRESS):
    sinceLastClick := toFloat glfwGetTime() - timelineLastButtonClickTime
    if (sinceLastClick < doubleClickTime):
      println "Double click! " sinceLastClick "s"
      isUnrestricted := timeline.startTime == 0.0 && timeline.endTime == timeline.totalTime
      if isUnrestricted:
        println "unrestricted"
        timeline.startTime = timeline.restrictedStartTime
        timeline.endTime = timeline.restrictedEndTime
      else:
        println "restricted"
        timeline.startTime = 0.0
        timeline.endTime = timeline.totalTime
      end
      println "timeline.startTime = " timeline.startTime
      println "timeline.endTime = " timeline.endTime
    else:
      if insideRect(csMouseX, csMouseY, &timeline.screenPos):
        relativePos &csMouseX &csMouseY &timeline.screenPos
        relStartTime := timeline.startTime / timeline.totalTime
        relEndTime := timeline.endTime / timeline.totalTime
        startDistance := fabsf( csMouseX - relStartTime )
        endDistance := fabsf( csMouseX - relEndTime )
        if (float:min startDistance endDistance < 0.02):
          if (startDistance < endDistance):
            timelineSelectedItem = 0
          else:
            timelineSelectedItem = 1
          end
        else:
          (timeline.currentTime)* = csMouseX * timeline.totalTime
          timelineSelectedItem = 2
        end
      end
    end
    timelineLastButtonClickTime = toFloat glfwGetTime()
  else:
    timelineSelectedItem = -1
  end
end

func int ast:printLimited(ast* tree, int maxLength):
  remaining := maxLength

  if (remaining < 2):
    if (maxLength > 0):
      print ".."
    end
    ret 0
  end

  count := strlen tree.id
  if (tree.childCount > 0):
    print "("
    remaining--
  end
  print tree.id
  remaining = maxLength - count

  forEachAstChild child tree:
    if (tree.childCount > 0):
      print " "
      remaining--
    end

    remaining = ast:printLimited(child, remaining)
    if (remaining <= 2):
      print ".."
      ret 0
    end
  end

  if (tree.childCount > 0):
    print ")"
    remaining -= 1
  end

  ret remaining
end

macro log args...:
  if (args.childCount == 0):
    ret ${}
  end

  body := ast:child args (args.childCount - 1)
  // println "body = " body
  // println "args = " args

  newArgs := nullptr ast
  if (args.childCount == 1):
    // println "single arg"
    newArgs = ${seq DUMMY}
  else:
    // println "multi args"
    newArgs = ast:shiftLeft args
  end
  // println "newArgs = " newArgs

  if (body.id ==_str "seq" || body.id ==_str "opseq"):
    // println "Instrumenting body"

    instrumentedBody := ${seq}
    forEachAstChild statement body:
      descr := cstring:quote statement.id
      ast:addChild instrumentedBody $:
        print "Running "
        ast:printLimited(${#statement}, 80)
        println()
      end
      ast:addChild instrumentedBody statement
    end

    ast:setChild newArgs (newArgs.childCount-1) instrumentedBody
  end

  // println "returning " newArgs
  ret newArgs
end

macro lfunc retType nameAndArgs body:
  name := ast:child nameAndArgs 0
  quotedName := cstring:quote name.id
  ret ${func #retType #nameAndArgs:
    println "Called function " #quotedName
    log #body
  end}
end

func int main():
  if isNull(app):
    app = new AppInfo
    app*.windowWidth = 400
    app*.windowHeight = 300
    app*.fsaaSamples = 2
    app*.vsync = true
    app*.customInit = &myInit
  end
  init(app)

  println "triggering event startup..."
  triggerEvent startup

  // sceneFilename := "data/pixeljourney/shared/obj/Reagenztest_tri.obj"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test5.dae"
  // sceneFilename := "data/pixeljourney/move_cube2.dae"
  // sceneFilename := "data/pixeljourney/pipetest/combined.dae"
  sceneFilename :=
      // "data/pixeljourney/pipetest/check_scale.dae"
      // "data/pixeljourney/shared/pipeline_tests/COLLADA_maya/091228_D_Collada_maya_test_szene_02.dae"
      // "data/pixeljourney/shared/pipeline_tests/COLLADA_maya/091228_D_Collada_maya_test_cube_01.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/091129_Colldada_Test7_rolling_cube.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/100131_cube_translate_rotate_x_300.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/091129_Colldada_Test1_tri.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/100208_camrot_03.dae"
      // "data/pixeljourney/mayatest.dae"
      // "data/pixeljourney/pipetest/car_w_mat.dae"
      "data/pixeljourney/pipetest/ringed.dae"
      // "data/pixeljourney/pipetest/platform.dae"
      // "data/blender_scripting_learn.dae"
      // "data/pixeljourney/first_scene_mats.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/100207_Pixeljums_cambaked_singlecube.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/091129_Colldada_Test6.dae"
      // "data/pixeljourney/shared/obj/100321_D01_racetrack_01.obj"
      // "data/pixeljourney/camera_import/test_cam_rig_rue_modified2.dae"
      // "data/pixeljourney/pipetest/soft_hard_normals_test_01.dae"
      // "data/pixeljourney/pipetest/untitled.dae"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test7_rolling_cube.dae"
  // sceneFilename := "data/collada_test2.dae"
  // sceneFilename := "data/pjm2.obj"
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  println "loading scene " sceneFilename "..."
  loadOptions :=
      aiProcess_Triangulate | aiProcess_SortByPType | aiProcess_GenSmoothNormals
  // | aiProcess_PreTransformVertices

  scene := aiImportFile sceneFilename loadOptions
  abortIf isNull(scene):
    println "assimp error when loading scene: " aiGetErrorString()
  end
  onReturn:
    aiReleaseImport scene
    scene = nullptr aiScene
  end

  // aiScene:print scene

  var SceneGraph sg
  SceneGraph:init &sg scene
  SceneGraph:updateTransforms &sg
  // SceneGraph:print &sg 0

  meshes := sg.meshes
  // abortIf (isNull meshes) (println "Failed to convert scene to meshes")
  onReturn:
    Array:foreach meshes meshNum:
      pMesh2 := meshes.elements + meshNum
      Mesh:delete &pMesh2.mesh
    end
  end

  animations := sg.animations
  println "Loaded " animations.length " animations"
  animDuration := 10.0
  if (animations.length > 0):
    firstAnim := aptr animations 0
    animDuration = firstAnim.duration
  end

  // objmat := loadGLSLShader "data/simple.vert" "data/simple.frag"
  // objmat := loadGLSLShader "data/incidence.vert" "data/incidence.frag"
  // objmat := loadGLSLShader "data/pixeljourney/shared/Shaders/Exported/constant_color_v.gl" "data/pixeljourney/shared/Shaders/Exported/constant_color_f.gl"
  // objmat := loadGLSLShader "data/pixeljourney/test_incidence_v.gl" "data/pixeljourney/test_incidence_f.gl"
  objmat := createObjectMaterial()
  // objmat := debugMaterial()
  onReturn Shader:delete(objmat)
  assert isNotNull(objmat)

  objmat_pj_CameraMatrix := glGetUniformLocation objmat.glname "pj_CameraMatrix"
  objmat_pj_ModelMatrix := glGetUniformLocation objmat.glname "pj_ModelMatrix"

  objmat_color := glGetUniformLocation objmat.glname "msl_constant_color_1_color"
  // println "objmat_color = " objmat_color
  objmat_obj2cam := glGetUniformLocation objmat.glname "_object_to_ndc"
  objmat_falloff_amount :=
      glGetUniformLocation objmat.glname "_msl_Component_falloff_1_amount"
  // println "objmat_obj2cam = " objmat_obj2cam
  // println "objmat_falloff_amount = " objmat_falloff_amount
  objmat_dampening := 0.0
  objmat_loc_dampening := glGetUniformLocation objmat.glname "dampening"

  postprocessMaterial := simplePPMaterial()
  postprocessMaterial_texture := glGetUniformLocation postprocessMaterial "texture"
  onReturn:
    glDeleteShader postprocessMaterial
  end

  cam := local Camera
  if isNull(keyboardCameraOrientation):
    cam.transform.origin = mv3f 1.5 0. 5.
  else:
    cam.transform = keyboardCameraOrientation*
  end

  mainBar := TwNewBar "Settings"
  TwDefine " Settings refresh=0.01 color='0 0 0' alpha=102 "
  twMoveBar "Settings" 0 20 200 (app*.windowHeight-150)
  shaderBar := TwNewBar "Shaders"
  twMoveBar "Shaders" (app*.windowWidth-300) 20 (app*.windowWidth-2) (app*.windowHeight-150)
  TwDefine " Shaders color='0 0 0' alpha=102 "
  onReturn TwDeleteAllBars()

  specialCamCount := 2
  camCount := sg.cameras.length + specialCamCount
  cameraEnums := malloc TwEnumVal camCount
  onReturn (dealloc cameraEnums)
  cameraEnums[0].value = 0
  cameraEnums[0].label = "Rotate around scene"
  cameraEnums[1].value = 1
  cameraEnums[1].label = "Keyboard navigation"
  Array:foreach sg.cameras camIndex:
    cameraEnums[camIndex+specialCamCount].value = camIndex + specialCamCount
    cam2 := aptr sg.cameras camIndex
    cameraEnums[camIndex+specialCamCount].label = cam2.camera.id
  end
  cameraEnumType := TwDefineEnum("Camera", cameraEnums, camCount)

  backgroundColor := arraylit float 0. 0. 0.3
  // var float[3] backgroundColor
  // zmp:array:set backgroundColor 0 0.0
  // zmp:array:set backgroundColor 1 0.0
  // zmp:array:set backgroundColor 2 0.3

  twgroup mainBar "group=options precision=2":
    button "Play/Pause" &onPlayPauseButton nullptr(void)
    rw TW_TYPE_FLOAT "playback speed" playbackSpeed
    separator
    rw TW_TYPE_FLOAT "cam dx" cameraOffsetX
    rw TW_TYPE_FLOAT "cam dy" cameraOffsetY
    rw TW_TYPE_FLOAT "cam dz" cameraOffsetZ
    rw TW_TYPE_FLOAT "rot. speed" rotationSpeed
    rw TW_TYPE_FLOAT "keyboard movement factor" keyboardCamSpeedFactor
    rw TW_TYPE_INT32 "cam num" camNum
    rw cameraEnumType "Camera" camNum
    separator
    rw TW_TYPE_FLOAT "far planefactor" farPlaneFactor
    rw TW_TYPE_FLOAT "near plane factor" nearPlaneFactor
    separator
    rw TW_TYPE_FLOAT "Double click" doubleClickTime
    rw TW_TYPE_COLOR3F "bg color" backgroundColor
    // rw TW_TYPE_FLOAT "dampening" objmat_dampening
  end

  twgroup mainBar "group=debugging ":
    rw TW_TYPE_BOOL8 "wireframe" wireframe
    rw TW_TYPE_BOOL8 "mesh pointers" showMeshPointers
    rw TW_TYPE_BOOL8 "camera positions" showCameraPositions
    rw TW_TYPE_BOOL8 "show keyframes" showAnimationKeyframes
    rw TW_TYPE_INT32 "  anim num" visAnim
    rw TW_TYPE_INT32 "  channel num" visNodeAnim
  end

  // objmat_params := addControlsForUniforms objmat.glname shaderBar "objmat"
  // shaderParameterValues = objmat_params
  shaderValueFileName := "data/settings/shader_params.cfg"
  // GLSLParameter:loadParamsFromFile shaderValueFileName shaderParameterValues
  pp_params := addControlsForUniforms postprocessMaterial shaderBar "postprocessing"
  // onReturn:
  //   /// only save if shader compiled successfully
  //   if (objmat.glname != 0):
  //     GLSLParameter:saveParamsToFile shaderValueFileName shaderParameterValues
  //   end
  // end

  fbo := new Framebuffer 1024 1024
  Framebuffer:attachColorTexture fbo
  Framebuffer:attachDepthTexture fbo
  Framebuffer:create fbo
  // println "FBO status: " Framebuffer:statusMessage(fbo)

  onReturn:
    Framebuffer:delete fbo
  end

  // List:foreach objmat_params paramIndex param:
  //   println param
  // end

  var AABB meshBB
  // Mesh:calcAABB &meshBB mesh
  Mesh:calcAABB &meshBB &(meshes.elements)*.mesh
  // Mesh:calcAABB &meshBB &meshes.data.mesh
  meshSize := AABB:diagonalLength &meshBB

  println "Mesh BB = " meshBB

  meshCenter := AABB:center &meshBB

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL
  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  animTime := 0.0
  if isNull(timeline):
    timeline = new Timeline animDuration &animTime
  else:
    timeline.currentTime = &animTime
  end
  fpsStat := local FrameStat 100
  onReturn:
    FrameStat:delete fpsStat
  end

  shaderMngr := local ShaderManager shaderValueFileName shaderBar
  onReturn:
    shaderMngrData = ShaderManager:serializeParams(shaderMngr)
    file:makeBackup(shaderValueFileName)
    Section:writeTo(shaderMngrData, shaderValueFileName)
    Section:delete(shaderMngrData)
    ShaderManager:delete(shaderMngr)
  end

  lambert := lambertMaterial()

  ShaderManager:add shaderMngr objmat.glname "objmat"
  ShaderManager:add shaderMngr lambert "lambert"
  ShaderManager:add shaderMngr postprocessMaterial "simple-pp-material"
  ShaderManager:add shaderMngr ditherMaterial() "npr-dithered"
  // ShaderManager:dump shaderMngr
  ShaderManager:addMaterialArray shaderMngr &sg.materials
  ShaderManager:createControls(shaderMngr)
  shaderMngrData := new Section ""
  Section:loadFrom(shaderMngrData, shaderValueFileName)
  ShaderManager:applySettings(shaderMngr, shaderMngrData)
  Section:delete(shaderMngrData)

  mainloop:
    FrameStat:write(fpsStat, frameDuration)
    // FrameStat:write(fpsStat, 0.2 * cosf(toFloat frameNum * 0.1))
    
    /// update logic
    angle = fmodf(angle + rotationSpeed * frameDuration, 360.)
    
    animTime -= timeline.startTime
    animTime = animTime + playbackSpeed * frameDuration
    animTime = fmodf(animTime, timeline.endTime - timeline.startTime)
    animTime += timeline.startTime
    
    Array:foreach animations animNum:
      Animation:apply (animations.elements+animNum) animTime
    end
    SceneGraph:updateTransforms &sg

    /// input events
    keyEvent := default KeyEvent
    while fetchNextKeyEvent(&keyEvent):
      if (keyEvent.key == GLFW_MOUSE_BUTTON_LEFT):
        onTimelineButton &keyEvent
      elseif (keyEvent.action == GLFW_PRESS):
        if (keyEvent.key == GLFW_KEY_P):
          if (keyDown GLFW_KEY_LSHIFT):
            aiScene:print scene
          else:
            SceneGraph:print &sg 0
            // meshI := aptr sg.meshes 1
            // Mesh:printDetailed &meshI.mesh
          end
        elseif (keyEvent.key == GLFW_KEY_C):
          if (keyDown GLFW_KEY_LSHIFT):
            camNum = camNum - 1
          else:
            camNum = camNum + 1
          end
        elseif (keyEvent.key == GLFW_KEY_X):
          camInfo2 := aptr(sg.cameras, camNum - specialCamCount)
          print "Camera transform = " camInfo2*.parentNode*.globalSpace
        end
      end
    end
    if (visAnim < -1) (visAnim = -1)
    if (visAnim >= sg.animations.length) (visAnim = sg.animations.length - 1)
    if (visAnim >= 0):
      anim := aptr sg.animations visAnim
      visNodeAnim %= anim.channels.length
    end
    Camera:move(cam, frameDuration * keyboardCamSpeedFactor)
    
    // var int[2] mainBarSize
    // TwGetParam mainBar nullptr(char) "size" TW_TYPE_INT32 2 (cast void* &mainBarSize)
    // zmp:array:set mainBarSize 1 (windowHeight * 17 / 20 - 20)
    // TwSetParam mainBar nullptr(char) "size" TW_TYPE_INT32 2 (cast void* &mainBarSize)
    
    /// rendering
    autoSetupViewport()
    
    renderToTarget fbo:
      bgcol := zmp:array:addr &backgroundColor
      glClearColor bgcol[0] bgcol[1] bgcol[2] 1.0
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    
      glEnable GL_DEPTH_TEST
      glEnable GL_BLEND
    
      glMatrixMode GL_PROJECTION
      glLoadIdentity()
      aspect := toDouble(app*.windowWidth) / toDouble(app*.windowHeight)
      camDistance := 0.8
      farPlaneDist := camDistance * meshSize * 2.0 +
        float:max(sqrtf (20.*20.*2.), 0.5 * meshSize + v3f:length mv3f(cameraOffsetX, cameraOffsetY, cameraOffsetZ) * 10.0)
      nearPlaneDist := float:max(1.0, camDistance - meshSize)
      farPlaneDist *= farPlaneFactor
      nearPlaneDist *= nearPlaneFactor
      gluPerspective toDouble(cam.horizontalFOV) aspect toDouble(nearPlaneDist) toDouble(farPlaneDist)
    
      glMatrixMode GL_MODELVIEW
      glLoadIdentity()
      camNum = camNum % (specialCamCount + sg.cameras.length)
      if (camNum == 0):
        gluLookAtf cameraOffsetX cameraOffsetY cameraOffsetZ 0. 0. 0. 0. 1. 0.
        glRotatef angle 0. 1. 0.
        Camera:draw cam
      elseif (camNum == 1):
        Camera:applyGL cam
      else:
        camInfo := aptr(sg.cameras, camNum - specialCamCount)
        Camera:applyGL &camInfo.camera
      end
    
      var float[16] pj_CameraMatrix
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &pj_CameraMatrix)
      // println "pj_CameraMatrix:"
      // printlnMatrix44 (cast float* &pj_CameraMatrix) 4
      // running = false
    
      AABB:render &meshBB
      // withShader objmat.glname:
      //   glUniformMatrix4fv objmat_pj_CameraMatrix 1 false (cast float* &pj_CameraMatrix)
      //   // var float[16] viewMat
      //   // var float[16] projMat
      //   // var float[16] ndc
      //   // readGLMatrix GL_MODELVIEW_MATRIX (cast float* &viewMat)
      //   // readGLMatrix GL_PROJECTION_MATRIX (cast float* &projMat)
      //   // glMatrixMode GL_MODELVIEW
      //   // glPushMatrix()
      //   // glMultMatrixf(cast float* &viewMat)
      //   // glMultMatrixf(cast float* &projMat)
      //   // readGLMatrix GL_MODELVIEW_MATRIX (cast float* &ndc)
      //   // glPopMatrix()
      //   // for num 0 16
      //   //   zmp:array:set viewMat num 0.0
      //   // end
      //   // for num2 0 4
      //   //   zmp:array:set viewMat (num*4+num) 1.0
      //   // end
      //   // glUniformMatrix1fv objmat_obj2cam 1 false (cast float* &viewMat)
      //   // glUniform4fv objmat_obj2cam 4 (cast float* &ndc)
      //   // glUniform1f objmat_falloff_amount 0.5
      //   glUniform4f objmat_color 1.0 0.5 0.0 1.0
      //   // glUniform1f objmat_loc_dampening objmat_dampening
      //   List:foreach objmat_params paramIndex2 param2:
      //   //   // param2.apply &param2
      //     GLSLParameter:apply &param2
      //   end
      //   Array:foreach meshes meshNum2:
      //     pMeshInfo := (meshes.elements + meshNum2)
      //     glPushMatrix()
      //     // applyTransformGL &pMeshInfo.transform
      //     var float[16] pj_ModelMatrix
      //     RBTransform:toMatrix4x4 &pMeshInfo.transform (cast float* &pj_ModelMatrix)
      //     glUniformMatrix4fv objmat_pj_ModelMatrix 1 false (cast float* &pj_ModelMatrix)
      //     glMultMatrixf (cast float* &pj_ModelMatrix)
      //     if wireframe:
      //       Mesh:render &pMeshInfo.mesh GL_POINTS 0
      //     else:
      //       Mesh:render &pMeshInfo.mesh GL_TRIANGLES 0
      //     end
      //     drawCoordSys 1.0
      //     glPopMatrix()
      //   end
      // end

      Array:foreach meshes meshNum2:
        // glUniformMatrix4fv objmat_pj_CameraMatrix 1 false (cast float* &pj_CameraMatrix)
        // glUniform4f objmat_color 1.0 0.5 0.0 1.0
        pMeshInfo := (meshes.elements + meshNum2)
        glPushMatrix()
        meshmat := pMeshInfo.material
        meshshader := objmat
        if (isNotNull meshmat && isNotNull meshmat.shader):
          meshshader = meshmat.shader
        end
        glname := 0
        if isNotNull(meshshader):
          glname = meshshader.glname
        end
        withShader glname:
          unless isNull(meshmat):
            List:foreach meshmat.params paramIndex2 param2:
              GLSLParameter:apply &param2
            end
          end
          applyTransformGL &pMeshInfo.transform
          // var float[16] pj_ModelMatrix
          // RBTransform:toMatrix4x4 &pMeshInfo.transform (cast float* &pj_ModelMatrix)
          // glUniformMatrix4fv objmat_pj_ModelMatrix 1 false (cast float* &pj_ModelMatrix)
          // glMultMatrixf (cast float* &pj_ModelMatrix)
          if wireframe:
            Mesh:render &pMeshInfo.mesh GL_POINTS 0
          else:
            Mesh:render &pMeshInfo.mesh GL_TRIANGLES 0
          end
          drawCoordSys 1.0
        end
        glPopMatrix()
      end
    
      if showMeshPointers:
        Array:foreach meshes meshNum3:
          pMeshInfo2 := meshes.elements + meshNum3
          rendergl GL_LINES:
            glColor3f 1. 1. 1.
            glVertex3f 0. 0. 0.
            glVertex pMeshInfo2.transform.origin
          end
          saveAttribs GL_POINTS:
            glPointSize 5.0
            rendergl GL_POINTS:
              glColor3f 1. 1. 0.
              glVertex pMeshInfo2.transform.origin
            end
          end
        end
      end
    
      // drawOrientationGrid2 0.2 1.0
    
      renderRotationTest()
    
      if showCameraPositions:
        SceneGraph:visualizeCameras &sg
      end
    
      if (visAnim >= 0):
        anim2 := aptr sg.animations visAnim
        NodeAnimation:visualize (aptr anim2.channels visNodeAnim)
      elseif (showAnimationKeyframes):
        Array:foreach2 sg.animations anim3Num anim3:
          Animation:visualize anim3
        end
      end
    end
    
    // renderToTarget fbo:
    //   glClearColor 0. 0. 0. 0.
    //   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    //
    //   glMatrixMode GL_PROJECTION
    //   glLoadIdentity()
    //   aspect := toDouble(windowWidth) / toDouble(windowHeight)
    //   gluPerspective 60.0d aspect 1.0d 20.0d
    //
    //   glMatrixMode GL_MODELVIEW
    //   glLoadIdentity()
    //   glTranslatef -2. -1. -8.
    //
    //   glutSolidSphere 3.0d 30 30
    //   drawOrientationGrid2 1.0 1.0
    // end renderToTarget
    
    Framebuffer:makeDepthTexture fbo
    Framebuffer:makeColorTexture fbo
    
    /// render final frame
    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    makeGLIdentityTransforms()
    glDisable GL_DEPTH_TEST
    glDisable GL_BLEND
    withShader postprocessMaterial:
      List:foreach pp_params paramIndex3 param3:
        GLSLParameter:apply &param3
      end
      showTextureAt fbo.colorTexture -1. -1. 2. 2.
    end
    
    // glScalef (1. / toFloat aspect) 1. 1.
    // glTranslatef 1.0 -0.5 0.
    // glTranslatef -0.5 -0.5 0.
    // saveAttribs:
    //   glDisable GL_DEPTH_TEST
    //   glDisable GL_BLEND
    //   showTextures:
    //     fbo.colorTexture
    //     fbo.depthTexture
    //   end
    // end
    
    // saveTransforms:
    //   makeGLIdentityTransforms()
    //   glColor3f 1. 1. 1.
    //   fdString := float2cstring frameDuration
    //   glqtPrintfAt(0., 0., 0., 0.001, fdString)
    //   dealloc fdString
    // end

    Timeline:render timeline
    FrameStat:render fpsStat timeline.screenPos

    // makeGLIdentityTransforms()
    // glColor3f 1. 1. 1.
    // glqtPrintfAt -1. -0.6 0. 0.002 int2cstring(visNodeAnim)
    // glqtPrintfAt -1. -0.7 0. 0.002 int2cstring(visAnim)
    
    printGLError()
    
    TwDraw()
    flushStdout()
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  println()
  println (toDouble frameNum / (glfwGetTime() - toDouble startTime)) " fps"

  /// store persistent values

  unless isNull(keyboardCameraOrientation):
    dealloc keyboardCameraOrientation
  end
  keyboardCameraOrientation = new RBTransform
  keyboardCameraOrientation* = cam.transform

  return 0
end


