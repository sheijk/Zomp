/**
 * Experiments with pipeline export from XSI
 */

linkclib "libglfw.dylib" "libGLEW.dylib"

static:setRequireLibDebug true

requireLibs opengl20 glfw glutils mathvis assimp libcee anttweakbar array unittest quicktext stdio

///-----------------------------------------------------------------------------
/// Section: list
///-----------------------------------------------------------------------------

func cstring List:listTypeName(cstring memberType):
  ret (memberType ++ "_List")
end

macro defineListType memberT:
  listT := ast:fromString List:listTypeName(memberT.id)
  code := ${seq:
    struct #listT:
      #memberT data
      #listT* next
    end
    func void INITFUNCNAME(#listT* this, #memberT data, #listT* next):
      this.data = data
      this.next = next
    end
  end}
  ast:replace code "INITFUNCNAME" ast:fromString(listT.id ++ ":init")
  ret code
end

defineListType int
defineArrayType int

defineListType float
defineArrayType float


macro makeList type nums...:
  listT := ast:fromString(type.id ++ "_List")
  list := ${nullptr #listT}
  i := nums.childCount - 1
  while (i >= 0):
    num := ast:child(nums, i)
    list = ${new #listT #num #list}
    --i
  end

  ret list
end

macro List:foreach_ptr list indexVar dataVar code:
  uniqueId current "Current_list_item"

  ret ${seq:
    #current := #list
    #indexVar := 0
    while isNotNull(#current):
      #dataVar := fieldptr #current data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

macro List:foreach list indexVar dataVar code:
  uniqueId current "Current_list_item"

  ret ${seq:
    #current := #list
    #indexVar := 0
    while isNotNull(#current):
      #dataVar := #current.data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

macro printList list name printMemberF:
  uniqueId ptr "printList"
  uniqueId index "printList"
  ret ${seq:
    println #name ": "
    List:foreach_ptr #list #index #ptr:
      #printMemberF #ptr
    end
  end}
end

macro List:length count listPtr:
  uniqueId ptr "List:length"
  ret ${seq:
    #ptr := #listPtr
    #count = 0
    while isNotNull(#ptr):
      #count += 1
      #ptr = #ptr.next
    end
  end}
end

macro List:prepend type listVar newElement:
  listType := List:listTypeName type.id

  ret ${#listVar = new #listType #newElement #listVar}
end

///-----------------------------------------------------------------------------
/// Section: experimental library extensions
///-----------------------------------------------------------------------------

/// returns the default value for the given type
macro default type:
  ctorName := type.id ++ ":default"
  ret ${#ctorName()}
end

macro isOneOf value firstLegalValue moreLegalValues...:
  code := ${#value == #firstLegalValue}
  forEachAstChild legalVal moreLegalValues:
    code = ${#value == #legalVal || #code}
  end
  ret code
end

macro initMemory startAddressExpr valueExpr countExpr:
  uniqueId startAddress "initMemory"
  uniqueId value "initMemory"
  uniqueId count "initMemory"
  uniqueId counter "initMemory"

  ret ${seq:
    #startAddress := #startAddressExpr
    #value := #valueExpr
    #count := #countExpr
    for #counter 0 #count:
      store (#startAddress + #counter) #value
    end
  end}
end

/// TODO fix mem leaks
func cstring floatArrayToString(int count, float* data):
  str := ""
  for i 0 count:
    f := (data+i)*
    fstr := toCString f
    if (i > 0):
      str = str ++ " "
    end
    str = str ++ fstr
    dealloc fstr
  end
  ret str
end

func bool readUntil2(FILE* file, char stopper, int maxLength, cstring* target):
  eof := false
  pos := 0

  writeTarget := target*
  store writeTarget '\0'

  while !eof:
    if (pos >= maxLength):
      ret false
    end

    result := getc(file)
    chr := toChar result
    if (result < 0):
      ret false
    end

    if (chr == stopper):
      store writeTarget '\0'
      ret true
    else:
      store writeTarget chr
    end
    ++pos
    writeTarget = writeTarget + 1
  end

  ret false
end

func int readFloats(FILE* file, int count, float* target):
  read := 0
  for i 0 count:
    value := 0.0
    newlyRead := readFloat(file, target+i)
    if (newlyRead < 0):
      ret -1
    end
    read += newlyRead
  end
  ret read
end

func bool file:copy(cstring old_name, cstring new_name):
  result := system("cp " ++ old_name ++ " " ++ new_name)
  ret (result == 0)
end

func bool file:makeBackup(cstring fileName):
  num := 0
  maxAttempts := 1000
  succeeded := false
  goOnTrying := true

  while (goOnTrying):
    goOnTrying = num <= maxAttempts

    bkFileName := fileName ++ ".bk_" ++ toCString num

    bkfile := fopen bkFileName "r"
    if isNull(bkfile):
      succeeded = file:copy fileName bkFileName
      goOnTrying = false
    else:
      closeFile bkfile
    end

    ++num
  end
  
  ret succeeded
end

///-----------------------------------------------------------------------------
/// Section: math
///-----------------------------------------------------------------------------

/// calculates a 4x4 column major float matrix from the rotation component
func void RBTransform:toRotMatrix4x4(RBTransform* this, float* mat44):
  mat44[0] = this.xaxis.x
  mat44[1] = this.yaxis.x
  mat44[2] = this.zaxis.x
  mat44[3] = 0.0
  mat44[4] = this.xaxis.y
  mat44[5] = this.yaxis.y
  mat44[6] = this.zaxis.y
  mat44[7] = 0.0
  mat44[8] = this.xaxis.z
  mat44[9] = this.yaxis.z
  mat44[10] = this.zaxis.z
  mat44[11] = 0.0
  mat44[12] = 0.0
  mat44[13] = 0.0
  mat44[14] = 0.0
  mat44[15] = 1.0
end

/// calculates a 4x4 column major float matrix from the translation component
func void RBTransform:toTransMatrix44(RBTransform* this, float* mat44):
  for i 0 16 (mat44[i] = 0.0)
  mat44[0] = 1.0
  mat44[5] = 1.0
  mat44[10] = 1.0
  mat44[15] = 1.0
  mat44[12] = -this.origin.x
  mat44[13] = -this.origin.y
  mat44[14] = -this.origin.z
end

func v3f RBTransform:rotate2(RBTransform* this, v3f v):
  ret (v.x * this.xaxis + v.y * this.yaxis + v.z * this.zaxis)
end

func RBTransform RBTransform:concat(RBTransform* first, RBTransform* relative):
  result := undef RBTransform
  result.xaxis = RBTransform:rotate2 first relative.xaxis
  result.yaxis = RBTransform:rotate2 first relative.yaxis
  result.zaxis = RBTransform:rotate2 first relative.zaxis
  result.origin = first.origin + RBTransform:rotate2 first relative.origin * first.scale
  result.scale = first.scale * relative.scale
  ret result
end

func float lerp(float t, float a, float b):
  return ((1. - t) * a + t * b)
end

unittest:testCase float_lerp:
  unittest:assertAll:
    lerp 0.0 10. 20. == 10.
    lerp 0.5 10. 20. == 15.
    lerp 1.0 10. 20. == 20.
  end
end

// proof of 'unlerp(lerp(t,a,b), a, b) = t', no unit tests needed for this
//   unlerp(lerp(t,a,b), a, b)
// = unlerp(((1-t)*a + t*b), a, b)
// = ((((1-t)*a + t*b) - a) / (b - a))
// = ((a - t*a + t*b - a) / (b - a))
// = ((-t*a + t*b) / (b - a)
// = t * (b-a) / (b-a)
// = t
func float unlerp(float t, float a, float b):
  return ((t - a) / (b - a))
end

func float remapRange(
    float t,
    float oldMin, float oldMax,
    float newMin, float newMax):
  return lerp(unlerp t oldMin oldMax, newMin, newMax)
end

func bool op==_eps(float l, float r):
  // stupid value..
  eps := 0.0001
  return (fabsf (l-r) < eps)
end

unittest:testCase remapRange:
  unittest:assertAll:
    remapRange 10.0 10. 20. 50. 100. ==_eps 50.
    remapRange 20.0 10. 20. 50. 100. ==_eps 100.
    remapRange 15.0 10. 20. 50. 100. ==_eps 75.
  end
end

func float smoothstep(float t):
  return ((3. - 2. * t)*(t*t))
end

func float cubicBezier1d(float t, float p0, float p1, float p2, float p3):
  i := 1. - t
  return (i*i*i*p0 + 3.*i*i*t*p1 + 3.*i*t*t*p2 + t*t*t*p3)
end

struct quatf:
  float x y z w
end

func void quatf:makeConjugate(quatf* this):
  this.x = float:neg this.x
  this.y = float:neg this.y
  this.z = float:neg this.z
end

func quatf quatf:conjugate(quatf q):
  conj := q
  quatf:makeConjugate &conj
  ret conj
end

func float quatf:magnitude(quatf q):
  ret sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w)
end

func void quatf:makeNormalized(quatf* this):
  mag := quatf:magnitude *this
  this.x *= mag
  this.y *= mag
  this.z *= mag
  this.w *= mag
end

func quatf quatf:normalized(quatf q):
  r := q
  quatf:makeNormalized &r
  ret r
end

/// adpated from gmtl
func quatf quatf:lerp(float t, quatf a, quatf b):
  // calc cosine theta
  cosom := a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

  // adjust signs (if necessary)
  b2 := b
  if (cosom < 0.0):
    cosom = float:neg cosom
    b2.x = float:neg b2.x
    b2.y = float:neg b2.y
    b2.z = float:neg b2.z
    b2.w = float:neg b2.w
  end

  // Calculate coefficients
  sclp := 0.0
  sclq := 0.0

  if ( (1.0f - cosom) > 0.0001f): // 0.0001 -> some epsillon
    // Standard case (slerp)
    omega := acosf cosom
    sinom := sinf omega // extract theta from dot product's cos theta
    sclp  = sinf( (1.0 - t) * omega) / sinom
    sclq  = sinf( t * omega) / sinom
  else:
    // Very close, do linear interp (because it's faster)
    sclp = 1.0f - t
    sclq = t
  end

  result := undef quatf
  result.x = sclp * a.x + sclq * b2.x
  result.y = sclp * a.y + sclq * b2.y
  result.z = sclp * a.z + sclq * b2.z
  result.w = sclp * a.w + sclq * b2.w
  ret result
end

defineArrayType quatf

func quatf aiQuaternion:quatf(aiQuaternion q):
  ret (structlit quatf x q.x y q.y z q.z w q.w)
end

/// approach by fg
func v3f quatf:rotate(quatf rot, v3f v):
  rot_xyz := mv3f rot.x rot.y rot.z
  t := 2.0 * (rot_xyz *_cross v)
  rv := v + rot.w * t + rot_xyz *_cross t
  ret rv
end

/// axis is the normal (yes, that implies it needs to be normalized!) of the
/// plane of rotation
/// angleRad is the counter clockwise rotation angle (as seen when looking down
/// on the plane of rotation from the direction the normal points to)
func quatf quatf:fromAxisAngle(v3f axis, float angleRad):
  r := undef quatf
  sinr := sinf (0.5 * angleRad)
  cosr := cosf (0.5 * angleRad)

  r.x = axis.x * sinr
  r.y = axis.y * sinr
  r.z = axis.z * sinr
  r.w = cosr

  ret r
end

defineArrayType v3f

///-----------------------------------------------------------------------------
/// Section: events
///-----------------------------------------------------------------------------

defineListType astp

func cstring eventVarName(cstring id):
  ret ("event_" ++ id)
end

macro defineEvent id:
  varname := eventVarName id.id
  ret ${seq:
    var astp_List* #varname null
  end}
end

macro onEvent id code:
  varname := eventVarName id.id
  ret ${seq:
    macro mtmp:
      newList := malloc astp_List
      newList.next = #varname
      newList.data = ${#code}
      #varname = newList
      ret ${}
    end
    mtmp
  end}
end

macro triggerEvent id:
  varname := eventVarName id.id
  ret ${seq:
    macro mtmp:
      code := ${}
      List:foreach #varname i icode:
        ast:addChild code icode
      end
      ret code
    end
    mtmp
  end}
end

///-----------------------------------------------------------------------------
/// Section: initialization
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init():
  if bool:not(initCalled):
    glfwInit()
    glfwOpenWindowHint GLFW_FSAA_SAMPLES 2
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glfwSwapInterval 1
    glewInit()
    times 2 glfwPollEvents()

    if (TwInit(TW_OPENGL, nullptr void) == 0):
      println "AntTweakBar initialization failed, exiting"
      glfwTerminate()
      exit 2
    end

    printString "Initialized"
    println()

    initCalled = true
  else:
    printString "Already initialized"
    println()
  end
end

/// when the main app starts
defineEvent startup

///-----------------------------------------------------------------------------
/// Section: event handling
///-----------------------------------------------------------------------------

func void onTweakbarError(char* msg):
  println "AntTweakBar error: " msg
end

func void onWindowResize(int newWidth, int newHeight):
  // desiredAspect := toFloat windowWidth / toFloat windowHeight
  // correctHeight := toFloat newWidth / desiredAspect
  // glfwSetWindowSize newWidth toInt(correctHeight)
  // windowWidth = newWidth
  // windowHeight = toInt correctHeight
  // TwWindowSize windowWidth windowHeight
  windowWidth = newWidth
  windowHeight = newHeight
  glfwSetWindowSize windowWidth windowHeight
  TwWindowSize windowWidth windowHeight
  ret void
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

dfunc void timelineOnMouseMove(int x, int y)

func void onMouseMove(int x, int y):
  TwEventMousePosGLFW x y

  timelineOnMouseMove x y

  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos):
  TwEventMouseWheelGLFW pos

  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

struct KeyEvent:
  int key
  int action
  double time
  int mouseX mouseY
end

func KeyEvent KeyEvent:default():
  event := undef KeyEvent
  event.key = 0
  event.action = 0
  event.time = 0.0d
  event.mouseX = 0
  event.mouseY = 0
  ret event
end

defineListType KeyEvent

var KeyEvent_List* keyEvents null

func KeyEvent* storeKeyEvent(int key, int action, double time):
  event := malloc KeyEvent_List
  event.data.key = key
  event.data.action = action
  event.data.time = time
  event.next = keyEvents
  keyEvents = event
  ret &event.data
end

func bool fetchNextKeyEvent(KeyEvent* event):
  if isNull(keyEvents):
    return false
  end

  event* = keyEvents*.data
  toDelete := keyEvents
  keyEvents = keyEvents.next
  dealloc toDelete
  return true
end

func void clearKeyEvents():
  ignore := default KeyEvent
  while fetchNextKeyEvent(&ignore) void
end

func int onKey(int key, int action):
  storeKeyEvent key action glfwGetTime()
  TwEventKeyGLFW key action
  ret 0
end

func int onMouseButton(int button, int action):
  notHandled := 0
  if (TwEventMouseButtonGLFW button action == notHandled):
    event := storeKeyEvent button action glfwGetTime()
    event.mouseX = lastMouseX
    event.mouseY = lastMouseY
  end
  
  ret 0
end

onEvent startup:
  glfwSetWindowSizeCallback (cast void* &onWindowResize)
  TwHandleErrors &onTweakbarError
  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)
  glfwSetKeyCallback (cast void* &onKey)
  glfwSetMouseButtonCallback (cast void* &onMouseButton)
  glfwSetCharCallback (cast void* &TwEventCharGLFW)
end

///-----------------------------------------------------------------------------
/// Section: code
///-----------------------------------------------------------------------------


func void renderGrid3d(v3f min, v3f max, float step):
  rendergl GL_POINTS:
    ffor x min.x max.x step:
      ffor y min.y max.y step:
        ffor z min.x max.z step:
          glVertex3f x y z
        end
      end
    end
  end
end

macro twgroup bar optionString settings:
  code := ${}
  forEachAstChild s settings:
    if ast:matchesShape(s, ${rw _ _ __}):
      typeId := ast:child s 1
      name := ast:child s 2
      var := ast:child s 3
      ast:addChild code ${TwAddVarRW #bar #name #typeId (cast void* &#var) #optionString}
    elseif ast:matchesShape(s, ${separator}):
      ast:addChild code ${TwAddSeparator #bar nullptr(char) #optionString}
    elseif ast:matchesShape(s, ${button _ __ __}):
      buttonName := ast:child s 1
      buttonCallback := ast:child s 2
      buttonClientData := ast:child s 3
      ast:addChild code ${TwAddButton #bar #buttonName #buttonCallback #buttonClientData #optionString}
    else:
      ret ${error "Expected rw TYPE NAME VAR" #s}
    end
  end

  ret code
end

var float rotationSpeed 64.0
var float playbackSpeed 1.0
var float cameraOffsetX 0.
var float cameraOffsetY 2.
var float cameraOffsetZ 10.
var bool wireframe false
var bool showCameraPositions false
var bool showAnimationKeyframes false
/// draw lines from origin to center of each mesh
var bool showMeshPointers false

template abortIf cond onFail:
  if #cond:
    #onFail
    ret 0
  end
end

func GLint loadGLSLShader(cstring vsFileName, cstring fsFileName):
  vsSource := nullptr char
  onReturn (dealloc vsSource)
  if (zompLoadFileToMemory(vsFileName, &vsSource) == -1):
    println "Error: could not load " vsFileName
    return 0
  end
  fsSource := nullptr char
  onReturn (dealloc fsSource)
  if (zompLoadFileToMemory fsFileName &fsSource == -1):
    println "Error: could not load " fsFileName
    dealloc vsSource
    return 0
  end

  shader := createShader "" vsSource fsSource

  return shader
end

//------------------------------------------------------------------------------

func void printGLMatrixStacks():
  modelview_stack_depth := 0
  glGetIntegerv GL_MODELVIEW_STACK_DEPTH &modelview_stack_depth
  println "GL_MODELVIEW_STACK_DEPTH = " modelview_stack_depth
  projection_stack_depth := 0
  glGetIntegerv GL_PROJECTION_STACK_DEPTH &projection_stack_depth
  println "GL_PROJECTION_STACK_DEPTH = " projection_stack_depth
end

func void readGLMatrix(GLenum matrix, float* f16):
  glGetFloatv matrix f16
end

func GLint debugMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_NormalMatrix * gl_Normal;
    }"
  fragmentSource := "
  uniform float dampening;
  uniform float red;
  void main(void) {
    float intensity = 1.0 - dampening;
    gl_FragColor = vec4((normalize(normal)*0.5+vec3(0.5))*intensity,1.0);
    gl_FragColor.r = red;
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func GLint objectMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 wsNormal;
  varying vec3 wsLightDir;
  varying float depth;
  uniform mat4 pj_ModelMatrix;
  uniform mat4 pj_CameraMatrix; // guaranteed to be "nice"
  "
  vertexSource := "
  vec3 unhomo(vec4 v) { return v.xyz / v.w; }

  void main(void) {
    gl_Position = ftransform();
    // wsNormal = gl_NormalMatrix * gl_Normal;
    wsNormal = (pj_ModelMatrix * vec4(gl_Normal,0.0)).xyz;
    vec3 wsPos = unhomo(pj_ModelMatrix * gl_Vertex);
    vec3 wsLightPos = vec3(10., 10., 10.);
    wsLightDir = wsLightPos - wsPos;
    depth = gl_Position.z;
    }"
  fragmentSource := "
  uniform vec2 red_green;
  uniform float diffuseFactor = 1.0;
  uniform vec3 ambientGroundColor = vec3(0.1,0.2,0.05);
  uniform vec3 ambientSkyColor = vec3(0.,0.,0.2);
  uniform vec4 testColor2 = vec4(0.,0.,0.,0.);
  uniform vec3 fogColor;
  uniform float fogNear;
  uniform float fogFar;

  uniform bool debugEnabled;
  uniform float debugDistance;

  void main(void) {
    // gl_FragColor = vec4(normalize(lightDir) * 0.5 + 0.5, 1.0);
    // gl_FragColor = vec4(length(wsLightDir), length(wsLightDir), length(wsLightDir), 1.0);
    // gl_FragColor = vec4(normalize(wsLightDir)*0.5+vec3(0.5),1.0);
    vec3 diffuse = diffuseFactor * vec3(dot(normalize(wsLightDir), normalize(wsNormal)));

    vec3 ambientHemi = 3.*mix(
        ambientGroundColor,
        ambientSkyColor,
        dot(wsNormal, vec3(0.,1.,0.))*0.5+0.5);

    vec3 color = diffuse + ambientHemi + vec3(red_green.r, red_green.g, 0.);
    float fog = (depth - fogNear) / (fogFar - fogNear);
    fog = min(1.0, max(0.0, fog));

    if( debugEnabled && debugDistance > 0 && abs(depth-debugDistance) < 0.1 ) {
        gl_FragColor = vec4(1.0,0.,0.,1.);
    }
    else {
        gl_FragColor = vec4(mix(color, fogColor, fog*0.8), 1.0);
        // vec4 tc = testColor2;
        // gl_FragColor = vec4(tc.rgb,1.0);
    }
  }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func GLint simplePPMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec2 screenSpaceCoord;
  "
  vertexSource := "
  void main(void) {
      gl_Position = ftransform();
      screenSpaceCoord = gl_Position.xy * 0.5 + vec2(0.5);
    }"
  fragmentSource := "
  uniform sampler2D texture;
  uniform float blurStepDeltaInv;
  void main(void) {
      // gl_FragColor = vec4(screenSpaceCoord.x, screenSpaceCoord.y, 0.0, 1.0);
      // gl_FragColor = texture2D(texture, screenSpaceCoord);
      vec3 color = vec3(0.);
      int blurSteps = 5;
      for(int i = 0; i < blurSteps; ++i) {
          color += texture2D(texture, screenSpaceCoord + vec2(float(i-float(blurSteps/2))/blurStepDeltaInv,0.)).xyz;
      }
      gl_FragColor = vec4(color / float(blurSteps), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func void gluLookAtf(
    float eyex, float eyey, float eyez,
    float cx, float cy, float cz,
    float ux, float uy, float uz):
  gluLookAt
    (toDouble eyex) (toDouble eyey) (toDouble eyez)
    (toDouble cx) (toDouble cy) (toDouble cz)
    (toDouble ux) (toDouble uy) (toDouble uz)
end

func void RBTransform:toMatrix4x4(RBTransform* this, float* mat44):
  mat44[0] = this.xaxis.x * this.scale
  mat44[1] = this.xaxis.y * this.scale
  mat44[2] = this.xaxis.z * this.scale
  mat44[3] = 0.0
  mat44[4] = this.yaxis.x * this.scale
  mat44[5] = this.yaxis.y * this.scale
  mat44[6] = this.yaxis.z * this.scale
  mat44[7] = 0.0
  mat44[8] =  this.zaxis.x * this.scale
  mat44[9] =  this.zaxis.y * this.scale
  mat44[10] = this.zaxis.z * this.scale
  mat44[11] = 0.0
  mat44[12] = this.origin.x
  mat44[13] = this.origin.y
  mat44[14] = this.origin.z
  mat44[15] = 1.0
end

func void applyTransformGL(RBTransform* this):
  // converting to matrix, then applying. not pretty...
  var float[16] mat_
  mat := zmp:array:addr &mat_
  RBTransform:toMatrix4x4 this mat

  glMultMatrixf mat
end

// TODO move to libcee <<<
funcd int toupper(int chr)
funcd int tolower(int chr)

func char char:upperCase(char chr):
  ret toChar(toupper(toInt chr))
end

func char char:lowerCase(char chr):
  ret toChar(tolower(toInt chr))
end
// >>>

struct KeyFrameVector:
  double time
  v3f value
end

ofunc void print(KeyFrameVector kfv):
  print "KeyFrameVector(time=" kfv.time ", value=" kfv.value ")"
end

struct KeyFrameQuat:
  double time
  quatf value
end

ofunc void print(quatf q):
  print "quatf(x=" q.x ", y=" q.y ", z=" q.z ", w=" q.w ")"
end

ofunc void print(KeyFrameQuat kfq):
  print "KeyFrameQuat(time=" kfq.time ", value=" kfq.value ")"
end

func v3f aiVector3D:vec3f(aiVector3D v):
  var v3f r
  r.x = v.x
  r.y = v.y
  r.z = v.z
  ret r
end

ofunc void print(aiVector3D v):
  aiVector3D:print &v
end

ofunc void print(aiVectorKey vk):
  aiVectorKey:print &vk
end

func KeyFrameVector aiVectorKey:toKeyFrameVector(aiVectorKey* this):
  var KeyFrameVector v
  v.time = this.mTime
  v.value = aiVector3D:vec3f this.mValue
  println "input = " *this
  println "outpt = " v
  ret v
end

defineArrayType KeyFrameVector
defineArrayType KeyFrameQuat

struct NodeAnimation:
  float duration //TODO remove
  RBTransform* targetTransform
  // float ticksPerSecond

  float_Array transformTimes
  v3f_Array transformKeyframes
  float_Array scaleTimes
  v3f_Array scaleKeyFrames
  float_Array rotatationTimes
  quatf_Array rotationKeyFrames
end

defineArrayType NodeAnimation

struct Animation:
  NodeAnimation_Array channels
  float duration
  cstring name
  // float ticksPerSecond
end

defineArrayType Animation

macro hasType var type:
  uniqueId tmp "hasType"
  ret ${seq:
    #tmp := nullptr #type
    #tmp = &#var
  end}
end

struct KeyframeInterpol:
  int first
  /// t in [0,1], result = lerp(t, keyframe first, keyframe first+1)
  float t
end

func KeyframeInterpol KeyframeInterpol:default():
  ret (structlit KeyframeInterpol first 0 t 0.0)
end

func KeyframeInterpol interpolKeyframeAt(float_Array* keyframeTimes, float time):
  rem := time
  // if (this.duration > 0.0)
  //   rem = fmodf time this.duration
  // end
  keyNum := -1
  found := false

  if (keyframeTimes.length == 1):
    ret (structlit KeyframeInterpol first 0 t 0.)
  elseif (keyframeTimes.length == 0):
    ret (structlit KeyframeInterpol first -1 t 0.)
  end

  result := default KeyframeInterpol

  firstFrameTime := aget(keyframeTimes,0)
  if (firstFrameTime < rem):
    while bool:not(found):
      ++keyNum
      if (keyNum >= keyframeTimes.length):
        found = true
      else:
        key := aget(keyframeTimes, keyNum)
        if (key > rem):
          found = true
        end
      end
    end

    if (keyNum < keyframeTimes.length):
      kfpre := aget(keyframeTimes, keyNum - 1)
      kfpost := aget(keyframeTimes, keyNum)
      result.first = keyNum - 1
      result.t = (rem - kfpre) / (kfpost - kfpre)
    else:
      /// ok, because keyframeTimes.length >= 2 checked above
      result.first = keyframeTimes.length - 2
      result.t = 1.0
    end
  end

  ret result
end

func v3f interpolTransform(float_Array* times, v3f_Array* positions, float time):
  assert (positions.length == times.length)

  if (times.length == 1):
    ret aget(positions*,0)
  end

  interp := interpolKeyframeAt times time
  posA := aget(positions, interp.first)
  posB := aget(positions, interp.first+1)
  ret v3f:lerp(interp.t, posA, posB)
end

func v3f NodeAnimation:transformAt(NodeAnimation* this, float time):
  ret interpolTransform(&this.transformTimes, &this.transformKeyframes, time)
end

func v3f NodeAnimation:scaleAt(NodeAnimation* this, float time):
  ret interpolTransform(&this.scaleTimes, &this.scaleKeyFrames, time)
end

func quatf NodeAnimation:rotationAt(NodeAnimation* this, float time):
  if (this.rotatationTimes.length == 1):
    ret aget(this.rotationKeyFrames, 0)
  end

  interp := interpolKeyframeAt &this.rotatationTimes time
  quatA := aget this.rotationKeyFrames interp.first
  quatB := aget this.rotationKeyFrames (interp.first+1)
  ret quatf:lerp(interp.t, quatA, quatB)
end

func void RBTransform:setRotation(RBTransform* this, quatf rot):
  xx := rot.x * rot.x
  xy := rot.x * rot.y
  xz := rot.x * rot.z
  xw := rot.x * rot.w
  yy := rot.y * rot.y
  yz := rot.y * rot.z
  yw := rot.y * rot.w
  zz := rot.z * rot.z
  zw := rot.z * rot.w

  this.xaxis.x = 1. - 2. * (yy + zz)
  this.yaxis.x = 2. * (xy - zw)
  this.zaxis.x = 2. * (xz + yw)
  this.xaxis.y = 2. * (xy + zw)
  this.yaxis.y = 1. - 2. * (xx + zz)
  this.zaxis.y = 2. * (yz - xw)
  this.xaxis.z = 2. * (xz - yw)
  this.yaxis.z = 2. * (yz + xw)
  this.zaxis.z = 1. - 2. * (xx + yy)

  // this.xaxis.x = 1. - 2. * (yy + zz)
  // this.xaxis.y = 2. * (xy - zw)
  // this.xaxis.z = 2. * (xz + yw)
  // this.yaxis.x = 2. * (xy + zw)
  // this.yaxis.y = 1. - 2. * (xx + zz)
  // this.yaxis.z = 2. * (yz - xw)
  // this.zaxis.x = 2. * (xz - yw)
  // this.zaxis.y = 2. * (yz + xw)
  // this.zaxis.z = 1. - 2. * (xx + yy)
end

func void RBTransform:setPosRotScale(RBTransform* this, v3f pos, quatf rot, float scale):
  this.origin = pos
  RBTransform:setRotation this rot
  this.scale = scale
  RBTransform:makeNormalized this
end

func void NodeAnimation:apply(NodeAnimation* this, float time):
  rem := time
  if (this.duration > 0.0):
    rem = fmodf time this.duration
  end

  targetTransform := this.targetTransform
  if isNotNull(targetTransform):
    // scale := mv3f 1.0 1.0 1.0
    // rot := quatf:fromAxisAngle mv3f(0.,1.,0.) 0.
    // pos := mv3f 0. 10. 0.
    scale := NodeAnimation:scaleAt this rem
    rot := NodeAnimation:rotationAt this rem
    pos := NodeAnimation:transformAt this rem
    // pos = pos * scale
    // pos = quatf:rotate rot pos
    RBTransform:setPosRotScale targetTransform pos rot ((scale.x + scale.y + scale.z) / 3.0)
    // RBTransform:makeNormalized targetTransform
  end
end

func void NodeAnimation:init(NodeAnimation* this, aiNodeAnim* source):
  this.duration = 0.0
  this.targetTransform = nullptr RBTransform
  this.transformTimes = *makeArray(float, source.mNumPositionKeys)
  this.transformKeyframes = *makeArray(v3f, source.mNumPositionKeys)
  this.scaleTimes = *makeArray(float, source.mNumScalingKeys)
  this.scaleKeyFrames = *makeArray(v3f, source.mNumScalingKeys)
  this.rotatationTimes = *makeArray(float, source.mNumRotationKeys)
  this.rotationKeyFrames = *makeArray(quatf, source.mNumRotationKeys)

  for transnum 0 source.mNumPositionKeys:
    aikey := *(source.mPositionKeys +_ptr transnum)
    var KeyFrameVector key
    key.time = aikey.mTime
    key.value = aiVector3D:vec3f aikey.mValue
    aset this.transformTimes transnum toFloat(key.time)
    aset this.transformKeyframes transnum key.value
  end

  for scalenum 0 source.mNumScalingKeys:
    skey := *(source.mScalingKeys +_ptr scalenum)
    aset this.scaleTimes scalenum toFloat(skey.mTime)
    scale := aiVector3D:vec3f(skey.mValue)
    aset this.scaleKeyFrames scalenum scale
    if (float:max(fabsf(scale.x - scale.y), fabsf(scale.x - scale.z)) > 0.0001 * (scale.x + scale.y + scale.z)):
      println "Found non uniform scaling " scale
    end
  end

  for rotnum 0 source.mNumRotationKeys:
    rkey := *(source.mRotationKeys +_ptr rotnum)
    aset this.rotatationTimes rotnum toFloat(rkey.mTime)
    aset this.rotationKeyFrames rotnum aiQuaternion:quatf(rkey.mValue)
  end
end

func NodeAnimation* aiNodeAnim:toNodeAnimation(aiNodeAnim* this):
  ret new(NodeAnimation, this)
end

func void Animation:apply(Animation* this, float time):
  for channelNum 0 this.channels.length:
    NodeAnimation:apply (this.channels.elements+channelNum) time
  end
end

struct Color:
  float red green blue
end

func Color color(float red, float green, float blue):
  ret (structlit Color red red green green blue blue)
end

func void renderTimeline(
    float startTime,
    float endTime, int markerCount,
    float* markerPos,
    Color* markerColors):

  if (startTime >= endTime):
    return void
  end

  saveAttribs:
    glEnable GL_BLEND
    glBlendFunc GL_ONE GL_SRC_ALPHA
    rendergl GL_QUADS:
      glColor4f 0. 0. 0. 0.4
      xborder := 0.02
      yborder := 0.1
      glVertex2f -xborder -yborder
      glVertex2f (1.+xborder) -yborder
      glVertex2f (1.+xborder) (1.+yborder)
      glVertex2f -xborder (1.+yborder)
    end
  end saveAttribs

  rendergl GL_LINES:
    glColor3f 1. 1. 1.
    glVertex3f 0. 0. 0.
    glVertex3f 1. 0. 0.

    glVertex3f 0. 0. 0.
    glVertex3f 0. 1. 0.

    glVertex3f 1. 0. 0.
    glVertex3f 1. 1. 0.

    fullSecond := startTime - fmodf startTime 1.0
    while (fullSecond < endTime):
      x2 := remapRange(fullSecond, startTime, endTime, 0., 1.)
      glVertex3f x2 0. 0.
      glVertex3f x2 0.1 0.
      fullSecond += 1.0
    end

    pos := markerPos
    color := markerColors
    for markerNum 0 markerCount:
      x := remapRange pos* startTime endTime 0. 1.
      glColor3fv (cast float* color)
      glVertex3f x 0. 0.
      glVertex3f x 1. 0.
      ++pos
      ++color
    end
  end
end

func void scaleTo2dArea(float left, float bottom, float right, float top):
  makeGLIdentityTransforms
  glMatrixMode GL_MODELVIEW
  glTranslatef -1. -1. 0.
  glScalef 2. 2. 1.
  glTranslatef left bottom 0.
  glScalef (right-left) (top-bottom) 1.
end

///-----------------------------------------------------------------------------
/// Section: camera
///-----------------------------------------------------------------------------

struct Camera:
  RBTransform transform
  cstring id
  float horizontalFOV aspect
  float nearPlaneDist farPlaneDist
end

defineArrayType Camera

func void Camera:init(Camera* this):
  makeOrigin &this.transform
  this.id = "-camera-"
  this.horizontalFOV = 60.0
  this.aspect = 1.0
  this.nearPlaneDist = 1.0
  this.farPlaneDist = 100.0
end

func void Camera:print(Camera* this, int indent):
  iprintln indent "Camera '" this.id "'"
  iprintln indent "aspect = " this.aspect
  iprintln indent "horizontalFOV = " this.horizontalFOV
  iprintln indent "nearPlaneDist = " this.nearPlaneDist
  iprintln indent "farPlaneDist = " this.farPlaneDist
  RBTransform:print &this.transform (indent+2)
end

func void Camera:applyGL(Camera* this):
  var float[16] mat_
  mat := zmp:array:addr(&mat_)

  RBTransform:toRotMatrix4x4 &this.transform mat
  glMultMatrixf mat

  RBTransform:toTransMatrix44 &this.transform mat
  glMultMatrixf mat
end

func void Camera:draw(Camera* this):
  rendergl GL_LINES:
    glColor3f 0. 0. 1.
    glVertex this.transform.origin
    glVertex (this.transform.origin - this.transform.zaxis)
    glColor3f 0. 1. 0.
    glVertex this.transform.origin
    glVertex (this.transform.origin + this.transform.yaxis)
  end
end

func bool keyDown(GLint key):
  ret(glfwGetKey key == GLFW_PRESS)
end

func bool mouseButtonDown(int button):
  glfwGetMouseButton button == GLFW_PRESS
end

func void Camera:move(Camera* this, float time):
  delta := mv3f 0. 0. 0.

  if (keyDown GLFW_KEY_A) (delta.x -= 1.0)
  if (keyDown GLFW_KEY_D) (delta.x += 1.0)
  if (keyDown GLFW_KEY_W) (delta.z -= 1.0)
  if (keyDown GLFW_KEY_S) (delta.z += 1.0)
  if (keyDown GLFW_KEY_F) (delta.y -= 1.0)
  if (keyDown GLFW_KEY_R) (delta.y += 1.0)

  speed := 2.0
  rspeed := 2.0
  if (keyDown GLFW_KEY_LSHIFT):
    speed *= 4.0
    rspeed *= 4.0
  elseif (keyDown GLFW_KEY_LCTRL):
    speed *= 0.25
    rspeed *= 0.25
  end

  delta = RBTransform:rotate2 &this.transform delta
  delta *= time * speed

  rot := mv3f 0. 0. 0.

  if (keyDown GLFW_KEY_UP) (rot.x += 1.0)
  if (keyDown GLFW_KEY_DOWN) (rot.x -= 1.0)
  if (keyDown GLFW_KEY_RIGHT) (rot.y -= 1.0)
  if (keyDown GLFW_KEY_LEFT) (rot.y += 1.0)
  if (keyDown GLFW_KEY_Q) (rot.z += 1.0)
  if (keyDown GLFW_KEY_E) (rot.z -= 1.0)

  rot *= time * rspeed

  if (rot.x != 0.0):
    rx := quatf:fromAxisAngle this.transform.xaxis rot.x
    this.transform.yaxis = quatf:rotate rx this.transform.yaxis
    this.transform.zaxis = quatf:rotate rx this.transform.zaxis
  end
  if (rot.y != 0.0):
    ry := quatf:fromAxisAngle this.transform.yaxis rot.y
    this.transform.xaxis = quatf:rotate ry this.transform.xaxis
    this.transform.zaxis = quatf:rotate ry this.transform.zaxis
  end
  if (rot.z != 0.0):
    rz := quatf:fromAxisAngle this.transform.zaxis rot.z
    this.transform.xaxis = quatf:rotate rz this.transform.xaxis
    this.transform.yaxis = quatf:rotate rz this.transform.yaxis
  end

  this.transform.origin += delta
end


///-----------------------------------------------------------------------------
/// Section: shader parameters
///-----------------------------------------------------------------------------

struct GLSLParameter:
  cstring name
  GLint location
  GLenum gltype
  void* data
end

defineListType GLSLParameter

struct Shader:
  cstring name
  GLint glname
  GLSLParameter_List* params
end

defineListType Shader

struct ShaderManager:
  Shader_List* shaders
  cstring settingsFile
  TwBar* bar
end

func cstring GLSLParameter:valueToString(GLSLParameter* param):
  /// dispatching based on gltype
  if (param.gltype == GL_FLOAT):
    ret float2cstring(*(cast float* param.data))
  elseif (param.gltype == GL_FLOAT_VEC2):
    ret floatArrayToString(2, cast float* param.data)
  elseif (param.gltype == GL_FLOAT_VEC3):
    ret floatArrayToString(3, cast float* param.data)
  elseif (param.gltype == GL_FLOAT_VEC4):
    ret floatArrayToString(4, cast float* param.data)
  elseif (param.gltype == GL_BOOL):
    ret bool2cstring(*(cast bool* param.data))
  end
  ret ""
end

ofunc void print(GLSLParameter param):
  print "(GLSLParameter name='" param.name
  print "', location=" param.location
  print ", type=" glenum2cstring(param.gltype)
  print ", data=" GLSLParameter:valueToString(&param)
  print ")"
end

func void GLSLParameter:apply(GLSLParameter* param):
  /// dispatching based on gltype
  if (param.gltype == GL_FLOAT):
    pFloat := cast float* param.data
    glUniform1f param.location pFloat*
  elseif (param.gltype == GL_FLOAT_VEC2):
    pFloat2 := cast float* param.data
    glUniform2f param.location (pFloat2+0)* (pFloat2+1)*
  elseif (param.gltype == GL_FLOAT_VEC3):
    pFloat3 := cast float* param.data
    glUniform3f param.location (pFloat3+0)* (pFloat3+1)* (pFloat3+2)*
  elseif (param.gltype == GL_FLOAT_VEC4):
    pFloat4 := cast float* param.data
    glUniform4f param.location (pFloat4+0)* (pFloat4+1)* (pFloat4+2)* (pFloat4+3)*
  elseif (param.gltype == GL_BOOL):
    pBool := cast int* param.data
    glUniform1i param.location *pBool
  end
end

func GLSLParameter GLSLParameter:make(cstring name, GLint location, GLenum type):
  var GLSLParameter param
  param.name = strdup(name)
  param.location = location
  param.gltype = type
  /// dispatching based on gltype
  floatCount := 0
  boolCount := 0
  if (type == GL_FLOAT):
    floatCount = 1
  elseif (type == GL_FLOAT_VEC2):
    floatCount = 2
  elseif (type == GL_FLOAT_VEC3):
    floatCount = 3
  elseif (type == GL_FLOAT_VEC4):
    floatCount = 4
  elseif (type == GL_BOOL):
    boolCount = 1
  else:
    param.gltype = 0
  end

  if (floatCount > 0):
    pFloat := malloc float floatCount
    initMemory pFloat 1.0 floatCount
    param.data = cast void* pFloat
  elseif (boolCount > 0):
    pBool := malloc int floatCount
    initMemory pBool 0 boolCount
    param.data = cast void* pBool
  end

  ret param
end

func GLSLParameter* GLSLParameter:findByName(cstring name, GLSLParameter_List* params):
  if isNull(params):
    ret nullptr(GLSLParameter)
  elseif (params.data.name ==_str name):
    ret &params.data
  end
  ret GLSLParameter:findByName(name, params.next)
end

func bool GLSLParameter:isSupportedType(GLenum gltype):
  ret (isOneOf gltype GL_FLOAT GL_FLOAT_VEC2 GL_FLOAT_VEC3 GL_FLOAT_VEC4 GL_BOOL)
end

func GLSLParameter_List* addControlsForUniforms(GLenum shader, TwBar* bar, cstring group):
  paramList := makeList GLSLParameter

  // TODO release memory, again
  optionForFloat := " group='" ++ group ++ "' step=0.1"
  optionGroup := " group='" ++ group ++ "'"

  withShader shader:
    paramNum := 0
    abort := false
    index := 0
    name := malloc char 100
    onReturn dealloc(name)

    println "Shader parameters:"
    while !abort:
      length := 0
      size := 0
      gltype := 0

      glGetActiveUniform shader index 100 &length &size &gltype name
      flushGLErrors()

      if (gltype == 0):
        abort = true
      else:
        print "  index = " index ", name = " name ", gltype = " glenum2cstring(gltype)
            ", size = " size

        if (GLSLParameter:isSupportedType gltype):
          location := glGetUniformLocation shader name
          List:prepend GLSLParameter paramList GLSLParameter:make(name, location, gltype)

          GLSLParameter:apply &paramList.data

          param := paramList.data.data
          if (gltype == GL_FLOAT):
            TwAddVarRW bar name TW_TYPE_FLOAT param optionForFloat
          elseif (gltype == GL_FLOAT_VEC2):
            // TODO investigate why (name++".x") results in ".x"
            TwAddVarRW bar (name ++ ".x") TW_TYPE_FLOAT (param+0) optionForFloat
            TwAddVarRW bar (name ++ ".y") TW_TYPE_FLOAT (param+4) optionForFloat
          elseif (gltype == GL_FLOAT_VEC3):
            TwAddVarRW bar name TW_TYPE_COLOR3F param optionGroup
          elseif (gltype == GL_FLOAT_VEC4):
            TwAddVarRW bar name TW_TYPE_COLOR4F param optionGroup
          elseif (gltype == GL_BOOL):
            TwAddVarRW bar name TW_TYPE_BOOL32 param optionGroup
          end
        else:
          print " (unsupported type, skipping)"
        end
        println()
      end

      maxParamCount := 100
      if (index > maxParamCount):
        abort = true
        println "max param limit (" maxParamCount ") reached, skipping all following params"
      end

      ++index
    end
  end
  flushGLErrors()
  return paramList
end

func void GLSLParameter:saveParamsToFileDescr(FILE* file, GLSLParameter_List* paramList):
  if isNull(paramList):
    ret void
  end

  param := &paramList.data

  writeCString file param.name
  writeCString file "="
  str := GLSLParameter:valueToString param
  writeCString file str
  dealloc str
  writeNewline file

  GLSLParameter:saveParamsToFileDescr file paramList.next
end

func void GLSLParameter:saveParamsToFile(cstring fileName, GLSLParameter_List* paramList):
  if !file:makeBackup(fileName):
    println "warning: could not backup shader settings file " fileName
  end

  file := fopen fileName "w"
  GLSLParameter:saveParamsToFileDescr file paramList
  closeFile file
  ret void
end

func void GLSLParameter:readValueFromFile(GLSLParameter* this, FILE* file):
  bufferSize := 100
  buffer := malloc char bufferSize

  readSomething := true

  /// dispatching based on gltype
  if (this.gltype == GL_FLOAT):
    value := 0.0
    readFloat file (cast float* this.data)
  elseif (this.gltype == GL_FLOAT_VEC2):
    readFloats file 2 (cast float* this.data)
  elseif (this.gltype == GL_FLOAT_VEC3):
    readFloats file 3 (cast float* this.data)
  elseif (this.gltype == GL_FLOAT_VEC4):
    readFloats file 4 (cast float* this.data)
  elseif (this.gltype == GL_BOOL):
    readInt file (cast int* this.data)
  else:
    readSomething = false
  end

  if readSomething:
    println "read new value for " this*
  end

  // skip until end of line
  readUntil2(file, '\n', bufferSize, &buffer)

  dealloc buffer

  ret void
end

func void GLSLParameter:loadParamsFromFile(cstring fileName, GLSLParameter_List* paramList):
  file := fopen fileName "r"
  if isNull(file):
    ret void
  end

  eof := false

  maxNameLength := 100
  name := malloc char maxNameLength

  while !eof:
    eof = !readUntil2(file, '=', maxNameLength, &name)
    unless eof:
      param := GLSLParameter:findByName(name, paramList)
      if isNotNull(param):
        GLSLParameter:readValueFromFile(param, file)
      end
    end
  end

  dealloc name
  closeFile file
  ret void
end

func void ShaderManager:init(ShaderManager* this, cstring settingsFile, TwBar* bar):
  this.shaders = nullptr Shader_List
  this.settingsFile = settingsFile
  this.bar = bar
end

func Shader* ShaderManager:add(ShaderManager* this, GLint glname, cstring name):
  var Shader shader
  shader.name = name
  shader.glname = glname
  shader.params = nullptr GLSLParameter_List

  List:prepend Shader this.shaders shader

  tmp := this.shaders
  ret &tmp.data
end

///-----------------------------------------------------------------------------
/// Section: scene graph
///-----------------------------------------------------------------------------

struct MeshInfo:
  Mesh mesh
  cstring id
  RBTransform transform
end

defineListType Mesh
defineListType MeshInfo
defineArrayType MeshInfo

struct SceneGraphNode:
  RBTransform globalSpace
  RBTransform relativeTransform
  int_Array meshes
  cstring id
end

struct CameraInfo:
  Camera camera
  SceneGraphNode* parentNode
  // TODO: maintain original relative transform of the aiCamera
end

defineArrayType CameraInfo

defineArrayType SceneGraphNode

struct SceneGraphEdge:
  int parent child
end

defineArrayType SceneGraphEdge
defineListType SceneGraphEdge
defineArrayType Mesh

struct SceneGraph:
  SceneGraphNode_Array nodes
  SceneGraphEdge_Array edges
  MeshInfo_Array meshes
  Animation_Array animations
  CameraInfo_Array cameras
end

//--- functions

func MeshInfo_Array collectMeshes(aiScene* scene):
  var MeshInfo_Array meshes
  MeshInfo_Array:init &meshes scene.mNumMeshes

  for meshnum 0 scene.mNumMeshes:
    aimesh := *(scene.mMeshes+meshnum)
    info := meshes.elements + meshnum
    newMesh := aiMesh:toMesh aimesh
    info.mesh = newMesh*
    info.id = ""
    makeOrigin &info.transform
  end

  ret meshes
end

func MeshInfo* lookupMesh(MeshInfo_Array meshes, cstring id):
  Array:foreach meshes num:
    mesh := meshes.elements + num
    if (mesh.id ==_str id):
      ret mesh
    end
  end
  ret nullptr(MeshInfo)
end

func void SceneGraphEdge:init(SceneGraphEdge* this, int parent, int child):
  this.parent = parent
  this.child = child
end


func void SceneGraphEdge:print(SceneGraphEdge* this):
  println this.parent " -> " this.child
end

ofunc void print(SceneGraphEdge edge):
  SceneGraphEdge:print &edge
end

func void SceneGraphNode:init(SceneGraphNode* this, aiNode* source):
  makeOrigin &this.globalSpace
  // makeOrigin &this.relativeTransform
  this.relativeTransform = aiMatrix4x4:toRBTransform &source.mTransformation
  int_Array:init &this.meshes source.mNumMeshes
  Array:foreach this.meshes meshNum:
    aset this.meshes meshNum *(source.mMeshes + meshNum)
  end
  this.id = aiString:cstring &source.mName
end

func int SceneGraphNode:lookup(SceneGraphNode_Array* this, cstring id):
  Array:foreach this nodeNum:
    node := aptr this nodeNum
    if (node.id ==_str id):
      ret nodeNum
    end
  end
  ret -1
end

func void CameraInfo:init(CameraInfo* this, aiCamera* aicam, SceneGraphNode_Array* nodes):
  Camera:init &this.camera
  this.camera.id = aiString:cstring(&aicam.mName)
  parentNodeIndex := SceneGraphNode:lookup nodes this.camera.id
  if (parentNodeIndex >= 0):
    this.parentNode = aptr(nodes, parentNodeIndex)
  else:
    this.parentNode = nullptr SceneGraphNode
  end
end

func void "print_void*"(void* ptr):
  printPtr ptr
end

func void SceneGraph:collectNodes(
    SceneGraph* this,
    aiNode* source,
    int* nodeNum,
    int* edgeNum,
    SceneGraphEdge_List** edges,
    RBTransform parentTransform):

  node := aptr this.nodes nodeNum*
  SceneGraphNode:init node source

  node.relativeTransform = aiMatrix4x4:toRBTransform &source.mTransformation
  node.globalSpace = RBTransform:concat &parentTransform &node.relativeTransform

  parentIndex := nodeNum*
  nodeNum* += 1
  for childNum 0 source.mNumChildren:
    childIndex := nodeNum*
    // relTransform := aiMatrix4x4:toRBTransform &srcNode.mTransformation
    // childTransform := RBTransform:concat &transform &relTransform
    srcNode := *(source.mChildren + childNum)
    SceneGraph:collectNodes this srcNode nodeNum edgeNum edges node.globalSpace

    pParent := aptr this.nodes parentIndex
    pChild := aptr this.nodes childNum

    edge := local SceneGraphEdge parentIndex childIndex
    edgeList := new SceneGraphEdge_List *edge edges*
    edges* = edgeList
  end
end

func void MeshInfo:print(MeshInfo* this, int indent):
  iprintln indent "MeshInfo '" this.id "':"
  Mesh:print &this.mesh (indent+2)
  RBTransform:print &this.transform (indent+2)
end

func void SceneGraphNode:print(SceneGraphNode* this, int indent):
  printIndent indent
  print "SceneGraphNode('" this.id "', " this.meshes.length " meshes = ["
  for num 0 this.meshes.length:
    if (num > 0):
      print ", "
    end
    print aget(this.meshes, num)
  end
  println "])"
  iprintln indent "  relativeTransform =:"
  RBTransform:print &this.relativeTransform (indent+4)
  iprintln indent "  globalSpace =:"
  RBTransform:print &this.globalSpace (indent+4)
end

func void SceneGraphNode:printUnindented(SceneGraphNode* this):
  SceneGraphNode:print this 0
end

func void NodeAnimation:print(NodeAnimation* this, int indent):
  iprint indent "NodeAnimation(" this.transformKeyframes.length
  print "/" this.rotationKeyFrames.length "/" this.scaleKeyFrames.length
  if isNull(this.targetTransform):
    print " no target!"
  end
  println ")"
  Array:foreach this.transformKeyframes tnum:
    pos := aget this.transformKeyframes tnum
    ttime := aget this.transformTimes tnum
    iprintln (indent+2) "time=" ttime ", pos=" pos
  end
  Array:foreach this.scaleKeyFrames snum:
    scale := aget this.scaleKeyFrames snum
    stime := aget this.scaleTimes snum
    iprintln (indent+2) "time=" stime ", scale=" scale
  end
  Array:foreach this.rotationKeyFrames rnum:
    rot := aget this.rotationKeyFrames rnum
    rtime := aget this.rotatationTimes rnum
    iprintln (indent+2) "time=" rtime ", rot=" rot
  end
end

func void Animation:print(Animation* this, int indent):
  iprintln indent "Animation '" this.name "', duration=" this.duration
  iprintArray this.channels "channels" NodeAnimation:print (indent+2)
end

func cstring SceneGraph:nodeName(SceneGraph* this, int nodeNum):
  if (nodeNum < 0 || nodeNum >= this.nodes.length):
    ret "-out of bounds-"
  end

  pNode := aptr this.nodes nodeNum
  ret pNode.id
end

func void CameraInfo:print(CameraInfo* this, int indent):
  iprint indent "CameraInfo"
  if isNull(this.parentNode):
    print "(connected)"
  else:
    println "(not in scene graph)"
  end
  Camera:print &this.camera (indent+2)
end

func void SceneGraph:print(SceneGraph* this, int indent):
  iprintln indent "SceneGraph:"

  iprintArray this.nodes "nodes" SceneGraphNode:print (indent+2)
  iprintln (indent+2) this.edges.length " edges:"
  Array:foreach this.edges edgeNum:
    edge := aptr this.edges edgeNum
    iprintln (indent+2) "  " SceneGraph:nodeName(this, edge.parent)
        " (nr. " edge.parent ") -> " SceneGraph:nodeName(this, edge.child)
        "(nr. " edge.child ")"
  end
  iprintArray this.animations "animations" Animation:print (indent+2)
  iprintArray this.meshes "meshes" MeshInfo:print (indent+2)
  iprintArray this.cameras "cameras" CameraInfo:print (indent+2)
end

func void Animation:init(Animation* this, aiAnimation* source, SceneGraphNode_Array nodes):
  this.duration = toFloat source.mDuration
  this.name = aiString:cstring &source.mName
  NodeAnimation_Array:init &this.channels source.mNumChannels
  Array:foreach this.channels channelNum:
    channel := this.channels.elements + channelNum
    aianim := *(source.mChannels+channelNum)
    NodeAnimation:init channel aianim
    channel.duration = toFloat this.duration

    /// connect to target node
    name := aiString:cstring &aianim.mNodeName
    nodeNum := SceneGraphNode:lookup &nodes name
    if (nodeNum >= 0):
      node := aptr nodes nodeNum
      channel.targetTransform = fieldptr node relativeTransform
    else:
      println "warning, could not connect anim channel " this.name
    end
  end
end

func void SceneGraph:init(SceneGraph* this, aiScene* source):
  /// meshes
  MeshInfo_Array:init &this.meshes source.mNumMeshes

  Array:foreach this.meshes meshNum:
    aimesh := *(source.mMeshes + meshNum)
    newMesh := aiMesh:toMesh aimesh
    info := aptr this.meshes meshNum
    info.mesh = newMesh*
    info.id = "- SceneGraph mesh-"
    makeOrigin &info.transform
  end

  /// nodes and edges
  SceneGraphNode_Array:init &this.nodes aiScene:totalNodeCount(source)
  nodeNum := 0
  edgeNum := 0
  edgeList := nullptr SceneGraphEdge_List
  SceneGraph:collectNodes
      this source.mRootNode &nodeNum &edgeNum &edgeList RBTransform:identity()
  edgeCount := 0
  List:length edgeCount edgeList
  SceneGraphEdge_Array:init &this.edges edgeCount
  List:foreach_ptr edgeList edgeNum2 pEdge:
    aset this.edges edgeNum2 pEdge*
  end

  // TODO: find nodes using the same mesh with different transform matrices,
  // add relative transforms or split those meshes (maybe even consider animations?)

  /// animations
  Animation_Array:init &this.animations source.mNumAnimations
  Array:foreach this.animations animNum:
    anim := aptr(this.animations, animNum)
    Animation:init anim *(source.mAnimations+animNum) this.nodes
  end

  /// cameras
  CameraInfo_Array:init &this.cameras source.mNumCameras
  Array:foreach this.cameras camNum:
    camInfo := aptr this.cameras camNum
    CameraInfo:init camInfo *(source.mCameras+camNum) &this.nodes
  end
end

func void SceneGraph:updateTransforms(SceneGraph* this):
  /// apply hierarchical node transforms
  if (this.nodes.length > 0):
    rootNode := aptr this.nodes 0
    rootNode.globalSpace = rootNode.relativeTransform
  end

  Array:foreach this.edges edgeNum:
    edge := aget this.edges edgeNum
    parent := aptr this.nodes edge.parent
    child := aptr this.nodes edge.child
    child.globalSpace = RBTransform:concat &parent.globalSpace &child.relativeTransform
  end

  /// apply mesh transforms
  Array:foreach this.nodes nodeNum:
    node := aptr this.nodes nodeNum
    Array:foreach node.meshes meshNum:
      meshIndex := aget node.meshes meshNum
      info := aptr this.meshes meshIndex
      info.transform = node.globalSpace
    end
  end

  /// apply transforms to cameras
  Array:foreach2 this.cameras camNum camInfo:
    unless isNull(camInfo.parentNode):
      t := (camInfo.parentNode)*.globalSpace
      camInfo.camera.transform = t
    end
  end
end

func void SceneGraph:visualizeCameras(SceneGraph* this):
  glMatrixMode GL_MODELVIEW
  Array:foreach2 this.cameras camNum camInfo:
    unless isNull(camInfo.parentNode):
      t := (camInfo.parentNode)*.globalSpace
      glPushMatrix()
      applyTransformGL &t
      // drawCoordSys 1.0
      rendergl GL_LINES:
        glColor3f 1. 0.4 0.0
        glVertex3f 0. 0. 0.
        glVertex3f 0.5 0. 0.
        glVertex3f 0. 0. 0.
        glVertex3f 0. 1. 0.
        glColor3f 1. 0.8 0.0
        glVertex3f 0. 0. 0.
        glVertex3f 0. 0. -1.
      end
      glPopMatrix()
    end
  end
end

func void RBTransform:visualize(RBTransform* this):
  rendergl GL_LINES:
    glColor3f 1. 0. 0.
    glVertex this.origin
    glVertex (this.origin + this.xaxis)
    glColor3f 0. 1. 0.
    glVertex this.origin
    glVertex (this.origin + this.yaxis)
    glColor3f 0. 0. 1.
    glVertex this.origin
    glVertex (this.origin + this.zaxis)
  end
end

func void visualizeTransform(v3f origin, v3f xaxis, v3f yaxis, v3f zaxis, v3f scale):
  rendergl GL_LINES:
    glColor3f 1. 0. 0.
    glVertex origin
    glVertex (origin + xaxis * scale.x)
    glColor3f 0. 1. 0.
    glVertex origin
    glVertex (origin + yaxis * scale.y)
    glColor3f 0. 0. 1.
    glVertex origin
    glVertex (origin + zaxis * scale.z)
  end
end

func void NodeAnimation:visualize(NodeAnimation* this):
  count := this.transformKeyframes.length
  assert (count == this.rotationKeyFrames.length)
  assert (count == this.scaleKeyFrames.length)

  for kfnum 0 count:
    pos := aget this.transformKeyframes kfnum
    rot := aget this.rotationKeyFrames kfnum
    scale := aget this.scaleKeyFrames kfnum
    transform := undef RBTransform
    RBTransform:setPosRotScale &transform pos rot 1.0
    visualizeTransform pos transform.xaxis transform.yaxis transform.zaxis scale
  end

  rendergl GL_LINE_STRIP:
    glColor3f 1. 0.4 0.
    for kfnum2 0 count:
      pos2 := aget this.transformKeyframes kfnum2
      rot2 := aget this.rotationKeyFrames kfnum2
      scale2 := aget this.scaleKeyFrames kfnum2
      transform2 := undef RBTransform
      RBTransform:setPosRotScale &transform2 pos2 rot2 1.0
      glVertex transform2.origin
    end
  end
end

func void Animation:visualize(Animation* this):
  Array:foreach2 this.channels num channel:
    NodeAnimation:visualize channel
  end
end


struct Rect:
  float left right top bottom
end

var float angle 0.0
var int visAnim -1
var int visNodeAnim 0
var int camNum 0

var float farPlaneFactor 1.0
var float nearPlaneFactor 1.0
var float keyboardCamSpeedFactor 1.0

func float deg2rad(float degree):
  degree * math:pi * 2.0 / 360.0
end

func void renderRotationTest():
  trans := local RBTransform
  trans.origin = mv3f 1.5 3.5 0.5
  rotQ := quatf:fromAxisAngle mv3f(0.,1.,0.) toFloat(0.5d * glfwGetTime())
  // rotQ := quatf:fromAxisAngle mv3f(0.,1.,0.) 0.0
  RBTransform:setRotation trans rotQ
  // trans.xaxis = quatf:rotate rotQ trans.xaxis
  // trans.yaxis = quatf:rotate rotQ trans.yaxis
  // trans.zaxis = quatf:rotate rotQ trans.zaxis

  trans2 := local RBTransform
  trans2.origin = mv3f 1. 0. 0.

  global := RBTransform:concat trans trans2

  saveTransforms:
    applyTransformGL &global
    glColor3f 1. 0. 0.
    drawCoordSys 1.0
  end
end

var RBTransform* keyboardCameraOrientation null
var GLSLParameter_List* shaderParameterValues null

func void printlnMatrix44(float* mat, int indent):
  times indent printChar(' ')
  println (mat+0)* " " (mat+4)* " " (mat+8)* " " (mat+12)*
  times indent printChar(' ')
  println (mat+1)* " " (mat+5)* " " (mat+9)* " " (mat+13)*
  times indent printChar(' ')
  println (mat+2)* " " (mat+6)* " " (mat+10)* " " (mat+14)*
  times indent printChar(' ')
  println (mat+3)* " " (mat+7)* " " (mat+11)* " " (mat+15)*
end

/// ripped from lighting.zomp
macro showTextures textureList:
  count := textureList.childCount
  code := ${}

  width := 1.0 / toFloat count
  height := width

  x := 0.
  y := 0.

  forEachAstChild tex textureList:
    ast:addChild code ${showTextureAt #tex #x #y #width #height}
    x = x + width
  end

  ret code
end

func void onPlayPauseButton2(void* ignored):
  if (playbackSpeed <= 0.0):
    playbackSpeed = 1.0
  else:
    playbackSpeed = 0.0
  end
end

func void twMoveBar(cstring barName, int left, int top, int right, int bottom):
  leftStr := int2cstring left
  topStr := int2cstring top
  widthStr := int2cstring(right - left)
  heightStr := int2cstring(bottom - top)

  options := barName ++ " position='" ++ leftStr ++ " " ++ topStr ++
      "' size='" ++ widthStr ++ " " ++ heightStr ++ "'"
  TwDefine options
  // TODO clean up memory
  ret void
end

func Rect makeRect(float l, float t, float r, float b):
  var Rect rect
  rect.left = l
  rect.top = t
  rect.right = r
  rect.bottom = b
  ret rect
end

struct Timeline2:
  float* currentTime
  float totalTime

  float startTime
  float endTime

  Rect screenPos
end

func void Timeline2:init(Timeline2* this, float totalTime, float* currentTime):
  this.currentTime = currentTime
  this.startTime = 0.2
  this.endTime = 0.4
  this.totalTime = totalTime
  this.screenPos = makeRect 0.03 0.03 0.97 0.13
end

func void Timeline2:render(Timeline2* this):
  saveAttribs:
    glDisable GL_DEPTH_TEST
    // nowColor := color 0.3 0.8 0.2
    scaleTo2dArea 0.03 0.03 0.97 0.13
    markers := malloc float 3
    colors := malloc Color 3
    onReturn:
      dealloc markers
      dealloc colors
    end
    markers[0] = *(this.currentTime)
    colors[0] = color 0.3 0.8 0.2
    markers[1] = this.startTime
    colors[1] = color 0.6 0.3 0.0
    markers[2] = this.endTime
    colors[2] = color 0.6 0.3 0.0
    // renderTimeline 0. this.totalTime 1 this.currentTime &nowColor
    renderTimeline 0. this.totalTime 3 markers colors
  end
end

func cstring glfw:keyName(int key):
  if (key == GLFW_KEY_SPACE):
    ret "Space"
  elseif (key == GLFW_KEY_SPECIAL):
    ret "Special"
  elseif (key == GLFW_KEY_ESC):
    ret "Esc"
  elseif (key == GLFW_KEY_F1):
    ret "F1"
  elseif (key == GLFW_KEY_F2):
    ret "F2"
  elseif (key == GLFW_KEY_F3):
    ret "F3"
  elseif (key == GLFW_KEY_F4):
    ret "F4"
  elseif (key == GLFW_KEY_F5):
    ret "F5"
  elseif (key == GLFW_KEY_F6):
    ret "F6"
  elseif (key == GLFW_KEY_F7):
    ret "F7"
  elseif (key == GLFW_KEY_F8):
    ret "F8"
  elseif (key == GLFW_KEY_F9):
    ret "F9"
  elseif (key == GLFW_KEY_F10):
    ret "F10"
  elseif (key == GLFW_KEY_F11):
    ret "F11"
  elseif (key == GLFW_KEY_F12):
    ret "F12"
  elseif (key == GLFW_KEY_F13):
    ret "F13"
  elseif (key == GLFW_KEY_F14):
    ret "F14"
  elseif (key == GLFW_KEY_F15):
    ret "F15"
  elseif (key == GLFW_KEY_F16):
    ret "F16"
  elseif (key == GLFW_KEY_F17):
    ret "F17"
  elseif (key == GLFW_KEY_F18):
    ret "F18"
  elseif (key == GLFW_KEY_F19):
    ret "F19"
  elseif (key == GLFW_KEY_F20):
    ret "F20"
  elseif (key == GLFW_KEY_F21):
    ret "F21"
  elseif (key == GLFW_KEY_F22):
    ret "F22"
  elseif (key == GLFW_KEY_F23):
    ret "F23"
  elseif (key == GLFW_KEY_F24):
    ret "F24"
  elseif (key == GLFW_KEY_F25):
    ret "F25"
  elseif (key == GLFW_KEY_UP):
    ret "Cursor up"
  elseif (key == GLFW_KEY_DOWN):
    ret "Cursor down"
  elseif (key == GLFW_KEY_LEFT):
    ret "Cursor left"
  elseif (key == GLFW_KEY_RIGHT):
    ret "Cursor right"
  elseif (key == GLFW_KEY_LSHIFT):
    ret "Left shift"
  elseif (key == GLFW_KEY_RSHIFT):
    ret "Right shift"
  elseif (key == GLFW_KEY_LCTRL):
    ret "Left control"
  elseif (key == GLFW_KEY_RCTRL):
    ret "Right control"
  elseif (key == GLFW_KEY_LALT):
    ret "Left alt"
  elseif (key == GLFW_KEY_RALT):
    ret "Right alt"
  elseif (key == GLFW_KEY_TAB):
    ret "Tab"
  elseif (key == GLFW_KEY_ENTER):
    ret "Enter"
  elseif (key == GLFW_KEY_BACKSPACE):
    ret "Backspace"
  elseif (key == GLFW_KEY_INSERT):
    ret "Insert"
  elseif (key == GLFW_KEY_DEL):
    ret "Del"
  elseif (key == GLFW_KEY_PAGEUP):
    ret "Pageup"
  elseif (key == GLFW_KEY_PAGEDOWN):
    ret "Pagedown"
  elseif (key == GLFW_KEY_HOME):
    ret "Home"
  elseif (key == GLFW_KEY_END):
    ret "End"
  elseif (key == GLFW_KEY_KP_0):
    ret "Keypad 0"
  elseif (key == GLFW_KEY_KP_1):
    ret "Keypad 1"
  elseif (key == GLFW_KEY_KP_2):
    ret "Keypad 2"
  elseif (key == GLFW_KEY_KP_3):
    ret "Keypad 3"
  elseif (key == GLFW_KEY_KP_4):
    ret "Keypad 4"
  elseif (key == GLFW_KEY_KP_5):
    ret "Keypad 5"
  elseif (key == GLFW_KEY_KP_6):
    ret "Keypad 6"
  elseif (key == GLFW_KEY_KP_7):
    ret "Keypad 7"
  elseif (key == GLFW_KEY_KP_8):
    ret "Keypad 8"
  elseif (key == GLFW_KEY_KP_9):
    ret "Keypad 9"
  elseif (key == GLFW_KEY_KP_DIVIDE):
    ret "Keypad divide"
  elseif (key == GLFW_KEY_KP_MULTIPLY):
    ret "Keypad multiply"
  elseif (key == GLFW_KEY_KP_SUBTRACT):
    ret "Keypad subtract"
  elseif (key == GLFW_KEY_KP_ADD):
    ret "Keypad add"
  elseif (key == GLFW_KEY_KP_DECIMAL):
    ret "Keypad decimal"
  elseif (key == GLFW_KEY_KP_EQUAL):
    ret "Keypad equal"
  elseif (key == GLFW_KEY_KP_ENTER):
    ret "Keypad enter"
  elseif (key == GLFW_KEY_LAST):
    ret "Last"
  elseif (key == GLFW_KEY_A):
    ret "A"
  elseif (key == GLFW_KEY_B):
    ret "B"
  elseif (key == GLFW_KEY_C):
    ret "C"
  elseif (key == GLFW_KEY_D):
    ret "D"
  elseif (key == GLFW_KEY_E):
    ret "E"
  elseif (key == GLFW_KEY_F):
    ret "F"
  elseif (key == GLFW_KEY_G):
    ret "G"
  elseif (key == GLFW_KEY_H):
    ret "H"
  elseif (key == GLFW_KEY_I):
    ret "I"
  elseif (key == GLFW_KEY_J):
    ret "J"
  elseif (key == GLFW_KEY_K):
    ret "K"
  elseif (key == GLFW_KEY_L):
    ret "L"
  elseif (key == GLFW_KEY_M):
    ret "M"
  elseif (key == GLFW_KEY_N):
    ret "N"
  elseif (key == GLFW_KEY_O):
    ret "O"
  elseif (key == GLFW_KEY_P):
    ret "P"
  elseif (key == GLFW_KEY_Q):
    ret "Q"
  elseif (key == GLFW_KEY_R):
    ret "R"
  elseif (key == GLFW_KEY_S):
    ret "S"
  elseif (key == GLFW_KEY_T):
    ret "T"
  elseif (key == GLFW_KEY_U):
    ret "U"
  elseif (key == GLFW_KEY_V):
    ret "V"
  elseif (key == GLFW_KEY_W):
    ret "W"
  elseif (key == GLFW_KEY_X):
    ret "X"
  elseif (key == GLFW_KEY_Y):
    ret "Y"
  elseif (key == GLFW_KEY_Z):
    ret "Z"
  elseif (key == GLFW_KEY_0):
    ret "0"
  elseif (key == GLFW_KEY_1):
    ret "1"
  elseif (key == GLFW_KEY_2):
    ret "2"
  elseif (key == GLFW_KEY_3):
    ret "3"
  elseif (key == GLFW_KEY_4):
    ret "4"
  elseif (key == GLFW_KEY_5):
    ret "5"
  elseif (key == GLFW_KEY_6):
    ret "6"
  elseif (key == GLFW_KEY_7):
    ret "7"
  elseif (key == GLFW_KEY_8):
    ret "8"
  elseif (key == GLFW_KEY_9):
    ret "9"
  elseif (key == GLFW_MOUSE_BUTTON_LEFT):
    ret "Left mouse button"
  elseif (key == GLFW_MOUSE_BUTTON_RIGHT):
    ret "Right mouse button"
  elseif (key == GLFW_MOUSE_BUTTON_MIDDLE):
    ret "Middle mouse button"
  elseif (key == GLFW_MOUSE_BUTTON_4):
    ret "Mouse button 4"
  elseif (key == GLFW_MOUSE_BUTTON_5):
    ret "Mouse button 5"
  elseif (key == GLFW_MOUSE_BUTTON_6):
    ret "Mouse button 6"
  elseif (key == GLFW_MOUSE_BUTTON_7):
    ret "Mouse button 7"
  elseif (key == GLFW_MOUSE_BUTTON_8):
    ret "Mouse button 8"
  end

  ret "Unknown key"
end

func bool insideRect(float x, float y, Rect* r):
  ret (x >= r.left && x < r.right && y >= r.top && y < r.bottom)
end

func void relativePos(float* x, float* y, Rect* r):
  x* = (x* - r.left) / (r.right - r.left)
  y* = (y* - r.bottom) / (r.top - r.bottom)
end

var int timelineSelectedItem -1
var Timeline2* timeline null

func void timelineOnMouseMove(int x, int y):
  if isNull(timeline):
    ret void
  end

  csMouseX := toFloat x / toFloat windowWidth
  csMouseY := toFloat (windowHeight - y) / toFloat windowHeight
  if insideRect(csMouseX, csMouseY, &timeline.screenPos):
    relativePos &csMouseX &csMouseY &timeline.screenPos
    if (timelineSelectedItem == 0):
      timeline.startTime = csMouseX * timeline.totalTime
    elseif (timelineSelectedItem == 1):
      timeline.endTime = csMouseX * timeline.totalTime
    elseif (timelineSelectedItem == 2):
      (timeline.currentTime)* = csMouseX * timeline.totalTime
    end
  end
end

func void onTimelineButton2(KeyEvent* keyEvent):
  csMouseX := toFloat keyEvent.mouseX / toFloat windowWidth
  csMouseY := toFloat (windowHeight - keyEvent.mouseY) / toFloat windowHeight
  
  if (keyEvent.action == GLFW_PRESS):
    if insideRect(csMouseX, csMouseY, &timeline.screenPos):
      relativePos &csMouseX &csMouseY &timeline.screenPos
      relStartTime := timeline.startTime / timeline.totalTime
      relEndTime := timeline.endTime / timeline.totalTime
      startDistance := fabsf( csMouseX - relStartTime )
      endDistance := fabsf( csMouseX - relEndTime )
      if (float:min startDistance endDistance < 0.02):
        if (startDistance < endDistance):
          timelineSelectedItem = 0
        else:
          timelineSelectedItem = 1
        end
      else:
        (timeline.currentTime)* = csMouseX * timeline.totalTime
        timelineSelectedItem = 2
      end
    end
  else:
    timelineSelectedItem = -1
  end
end

func int main():
  init()

  println "triggering event startup..."
  triggerEvent startup

  println "loading scene..."
  // sceneFilename := "data/pixeljourney/shared/obj/Reagenztest_tri.obj"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test5.dae"
  // sceneFilename := "data/pixeljourney/move_cube2.dae"
  // sceneFilename := "data/pixeljourney/pipetest/combined.dae"
  sceneFilename :=
      // "data/pixeljourney/pipetest/check_scale.dae"
      // "data/pixeljourney/shared/pipeline_tests/COLLADA_maya/091228_D_Collada_maya_test_szene_02.dae"
      // "data/pixeljourney/shared/pipeline_tests/COLLADA_maya/091228_D_Collada_maya_test_cube_01.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/091129_Colldada_Test7_rolling_cube.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/100131_cube_translate_rotate_x_300.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/091129_Colldada_Test1_tri.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/100208_camrot_03.dae"
      // "data/pixeljourney/mayatest.dae"
      // "data/pixeljourney/pipetest/car_w_mat.dae"
      "data/pixeljourney/pipetest/ringed.dae"
      // "data/pixeljourney/first_scene_mats.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/100207_Pixeljums_cambaked_singlecube.dae"
      // "data/pixeljourney/shared/pipeline_tests/from_xsi/091129_Colldada_Test6.dae"
      // "data/pixeljourney/shared/obj/100321_D01_racetrack_01.obj"
      // "data/pixeljourney/camera_import/test_cam_rig_rue_modified2.dae"
      // "data/pixeljourney/pipetest/soft_hard_normals_test_01.dae"
      // "data/pixeljourney/pipetest/untitled.dae"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test7_rolling_cube.dae"
  // sceneFilename := "data/collada_test2.dae"
  // sceneFilename := "data/pjm2.obj"
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  loadOptions :=
      aiProcess_Triangulate | aiProcess_SortByPType | aiProcess_GenSmoothNormals
  // | aiProcess_PreTransformVertices

  scene := aiImportFile sceneFilename loadOptions
  abortIf isNull(scene):
    println "assimp error when loading scene: " aiGetErrorString()
  end
  onReturn:
    aiReleaseImport scene
    scene = nullptr aiScene
  end

  // aiScene:print scene

  var SceneGraph sg
  SceneGraph:init &sg scene
  SceneGraph:updateTransforms &sg
  // SceneGraph:print &sg 0

  meshes := sg.meshes
  // abortIf (isNull meshes) (println "Failed to convert scene to meshes")
  onReturn:
    Array:foreach meshes meshNum:
      pMesh2 := meshes.elements + meshNum
      Mesh:delete &pMesh2.mesh
    end
  end

  animations := sg.animations
  println "Loaded " animations.length " animations"
  animDuration := 10.0
  if (animations.length > 0):
    firstAnim := aptr animations 0
    animDuration = firstAnim.duration
  end

  // objmat := loadGLSLShader "data/simple.vert" "data/simple.frag"
  // objmat := loadGLSLShader "data/incidence.vert" "data/incidence.frag"
  // objmat := loadGLSLShader "data/pixeljourney/shared/Shaders/Exported/constant_color_v.gl" "data/pixeljourney/shared/Shaders/Exported/constant_color_f.gl"
  // objmat := loadGLSLShader "data/pixeljourney/test_incidence_v.gl" "data/pixeljourney/test_incidence_f.gl"
  objmat := objectMaterial()
  // objmat := debugMaterial()
  onReturn glDeleteProgram(objmat)

  objmat_pj_CameraMatrix := glGetUniformLocation objmat "pj_CameraMatrix"
  objmat_pj_ModelMatrix := glGetUniformLocation objmat "pj_ModelMatrix"

  objmat_color := glGetUniformLocation objmat "msl_constant_color_1_color"
  println "objmat_color = " objmat_color
  objmat_obj2cam := glGetUniformLocation objmat "_object_to_ndc"
  objmat_falloff_amount :=
      glGetUniformLocation objmat "_msl_Component_falloff_1_amount"
  println "objmat_obj2cam = " objmat_obj2cam
  println "objmat_falloff_amount = " objmat_falloff_amount
  objmat_dampening := 0.0
  objmat_loc_dampening := glGetUniformLocation objmat "dampening"

  postprocessMaterial := simplePPMaterial()
  postprocessMaterial_texture := glGetUniformLocation postprocessMaterial "texture"
  onReturn:
    glDeleteShader postprocessMaterial
  end

  cam := local Camera
  if isNull(keyboardCameraOrientation):
    cam.transform.origin = mv3f 1.5 0. 5.
  else:
    cam.transform = keyboardCameraOrientation*
  end

  mainBar := TwNewBar "Settings"
  TwDefine " Settings refresh=0.01 color='0 0 0' alpha=102 "
  twMoveBar "Settings" 0 20 200 (windowHeight-150)
  shaderBar := TwNewBar "Shaders"
  twMoveBar "Shaders" (windowWidth-300) 20 (windowWidth-2) (windowHeight-150)
  TwDefine " Shaders color='0 0 0' alpha=102 "
  onReturn TwDeleteAllBars()

  specialCamCount := 2
  camCount := sg.cameras.length + specialCamCount
  cameraEnums := malloc TwEnumVal camCount
  onReturn (dealloc cameraEnums)
  cameraEnums[0].value = 0
  cameraEnums[0].label = "Rotate around scene"
  cameraEnums[1].value = 1
  cameraEnums[1].label = "Keyboard navigation"
  Array:foreach sg.cameras camIndex:
    cameraEnums[camIndex+specialCamCount].value = camIndex + specialCamCount
    cam2 := aptr sg.cameras camIndex
    cameraEnums[camIndex+specialCamCount].label = cam2.camera.id
  end
  cameraEnumType := TwDefineEnum("Camera", cameraEnums, camCount)

  // TwAddButton(mainBar, "Pause", &onPlayPauseButton2, nullptr void, "group=options")
  twgroup mainBar "group=options precision=2":
    button "Play/Pause" &onPlayPauseButton2 nullptr(void)
    rw TW_TYPE_FLOAT "playback speed" playbackSpeed
    separator
    rw TW_TYPE_FLOAT "cam dx" cameraOffsetX
    rw TW_TYPE_FLOAT "cam dy" cameraOffsetY
    rw TW_TYPE_FLOAT "cam dz" cameraOffsetZ
    rw TW_TYPE_FLOAT "rot. speed" rotationSpeed
    rw TW_TYPE_FLOAT "keyboard movement factor" keyboardCamSpeedFactor
    rw TW_TYPE_INT32 "cam num" camNum
    rw cameraEnumType "Camera" camNum
    separator
    rw TW_TYPE_FLOAT "far planefactor" farPlaneFactor
    rw TW_TYPE_FLOAT "near plane factor" nearPlaneFactor
    separator
    // rw TW_TYPE_COLOR4F "bg color" backgroundColor
    // rw TW_TYPE_FLOAT "dampening" objmat_dampening
  end

  twgroup mainBar "group=debugging ":
    rw TW_TYPE_BOOL8 "wireframe" wireframe
    rw TW_TYPE_BOOL8 "mesh pointers" showMeshPointers
    rw TW_TYPE_BOOL8 "camera positions" showCameraPositions
    rw TW_TYPE_BOOL8 "show keyframes" showAnimationKeyframes
    rw TW_TYPE_INT32 "  anim num" visAnim
    rw TW_TYPE_INT32 "  channel num" visNodeAnim
  end

  objmat_params := addControlsForUniforms objmat shaderBar "objmat"
  shaderParameterValues = objmat_params
  shaderValueFileName := "data/settings/shader_params.cfg"
  GLSLParameter:loadParamsFromFile shaderValueFileName shaderParameterValues
  pp_params := addControlsForUniforms postprocessMaterial shaderBar "postprocessing"
  onReturn:
    /// only save if shader compiled successfully
    if (objmat != 0):
      GLSLParameter:saveParamsToFile shaderValueFileName shaderParameterValues
    end
  end

  fbo := new Framebuffer 1024 1024
  Framebuffer:attachColorTexture fbo
  Framebuffer:attachDepthTexture fbo
  Framebuffer:create fbo
  println "FBO status: " Framebuffer:statusMessage(fbo)

  onReturn:
    Framebuffer:delete fbo
  end

  // List:foreach objmat_params paramIndex param:
  //   println param
  // end

  var AABB meshBB
  // Mesh:calcAABB &meshBB mesh
  Mesh:calcAABB &meshBB &(meshes.elements)*.mesh
  // Mesh:calcAABB &meshBB &meshes.data.mesh
  meshSize := AABB:diagonalLength &meshBB

  println "Mesh BB = " meshBB

  meshCenter := AABB:center &meshBB

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL
  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  animTime := 0.0
  timeline = local Timeline2 animDuration &animTime

  mainloop:
    /// update logic
    angle = angle + rotationSpeed * frameDuration
    animTime -= timeline.startTime
    animTime = animTime + playbackSpeed * frameDuration
    animTime = fmodf(animTime, timeline.endTime - timeline.startTime)
    animTime += timeline.startTime

    Array:foreach animations animNum:
      Animation:apply (animations.elements+animNum) animTime
    end
    SceneGraph:updateTransforms &sg

    /// input events
    keyEvent := default KeyEvent
    while fetchNextKeyEvent(&keyEvent):
      if (keyEvent.key == GLFW_MOUSE_BUTTON_LEFT):
        onTimelineButton2 &keyEvent
      elseif (keyEvent.action == GLFW_PRESS):
        if (keyEvent.key == GLFW_KEY_P):
          if (keyDown GLFW_KEY_LSHIFT):
            aiScene:print scene
          else:
            SceneGraph:print &sg 0
            // meshI := aptr sg.meshes 1
            // Mesh:printDetailed &meshI.mesh
          end
        elseif (keyEvent.key == GLFW_KEY_C):
          if (keyDown GLFW_KEY_LSHIFT):
            --camNum
          else:
            ++camNum
          end
        elseif (keyEvent.key == GLFW_KEY_X):
          camInfo2 := aptr(sg.cameras, camNum - specialCamCount)
          print "Camera transform = " (camInfo2.parentNode)*.globalSpace
        end
      end
    end
    if (visAnim < -1) (visAnim = -1)
    if (visAnim >= sg.animations.length) (visAnim = sg.animations.length - 1)
    if (visAnim >= 0):
      anim := aptr sg.animations visAnim
      visNodeAnim %= anim.channels.length
    end
    Camera:move(cam, frameDuration * keyboardCamSpeedFactor)

    /// rendering
    autoSetupViewport()

    renderToTarget fbo:
      glClearColor 0. 0. 0.3 0.
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    
      glEnable GL_DEPTH_TEST
      glEnable GL_BLEND

      glMatrixMode GL_PROJECTION
      glLoadIdentity()
      aspect := toDouble(windowWidth) / toDouble(windowHeight)
      camDistance := 0.8
      farPlaneDist := camDistance * meshSize * 2.0 +
        float:max(sqrtf (20.*20.*2.), 0.5 * meshSize + v3f:length mv3f(cameraOffsetX, cameraOffsetY, cameraOffsetZ) * 10.0)
      nearPlaneDist := float:max(1.0, camDistance - meshSize)
      farPlaneDist *= farPlaneFactor
      nearPlaneDist *= nearPlaneFactor
      gluPerspective toDouble(cam.horizontalFOV) aspect toDouble(nearPlaneDist) toDouble(farPlaneDist)
    
      glMatrixMode GL_MODELVIEW
      glLoadIdentity()
      camNum = camNum % (specialCamCount + sg.cameras.length)
      if (camNum == 0):
        gluLookAtf cameraOffsetX cameraOffsetY cameraOffsetZ 0. 0. 0. 0. 1. 0.
        glRotatef angle 0. 1. 0.
        Camera:draw cam
      elseif (camNum == 1):
        Camera:applyGL cam
      else:
        camInfo := aptr(sg.cameras, camNum - specialCamCount)
        Camera:applyGL &camInfo.camera
      end
    
      var float[16] pj_CameraMatrix
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &pj_CameraMatrix)
      // println "pj_CameraMatrix:"
      // printlnMatrix44 (cast float* &pj_CameraMatrix) 4
      // running = false
    
      AABB:render &meshBB
      withShader objmat:
        glUniformMatrix4fv objmat_pj_CameraMatrix 1 false (cast float* &pj_CameraMatrix)
        // var float[16] viewMat
        // var float[16] projMat
        // var float[16] ndc
        // readGLMatrix GL_MODELVIEW_MATRIX (cast float* &viewMat)
        // readGLMatrix GL_PROJECTION_MATRIX (cast float* &projMat)
        // glMatrixMode GL_MODELVIEW
        // glPushMatrix()
        // glMultMatrixf(cast float* &viewMat)
        // glMultMatrixf(cast float* &projMat)
        // readGLMatrix GL_MODELVIEW_MATRIX (cast float* &ndc)
        // glPopMatrix()
        // for num 0 16
        //   zmp:array:set viewMat num 0.0
        // end
        // for num2 0 4
        //   zmp:array:set viewMat (num*4+num) 1.0
        // end
        // glUniformMatrix1fv objmat_obj2cam 1 false (cast float* &viewMat)
        // glUniform4fv objmat_obj2cam 4 (cast float* &ndc)
        // glUniform1f objmat_falloff_amount 0.5
        glUniform4f objmat_color 1.0 0.5 0.0 1.0
        // glUniform1f objmat_loc_dampening objmat_dampening
        List:foreach objmat_params paramIndex2 param2:
        //   // param2.apply &param2
          GLSLParameter:apply &param2
        end
        Array:foreach meshes meshNum2:
          pMeshInfo := (meshes.elements + meshNum2)
          glPushMatrix()
          // applyTransformGL &pMeshInfo.transform
          var float[16] pj_ModelMatrix
          RBTransform:toMatrix4x4 &pMeshInfo.transform (cast float* &pj_ModelMatrix)
          glUniformMatrix4fv objmat_pj_ModelMatrix 1 false (cast float* &pj_ModelMatrix)
          glMultMatrixf (cast float* &pj_ModelMatrix)
          if wireframe:
            Mesh:render &pMeshInfo.mesh GL_POINTS 0
          else:
            Mesh:render &pMeshInfo.mesh GL_TRIANGLES 0
          end
          drawCoordSys 1.0
          glPopMatrix()
        end
      end
      if showMeshPointers:
        Array:foreach meshes meshNum3:
          pMeshInfo2 := meshes.elements + meshNum3
          rendergl GL_LINES:
            glColor3f 1. 1. 1.
            glVertex3f 0. 0. 0.
            glVertex pMeshInfo2.transform.origin
          end
          saveAttribs GL_POINTS:
            glPointSize 5.0
            rendergl GL_POINTS:
              glColor3f 1. 1. 0.
              glVertex pMeshInfo2.transform.origin
            end
          end
        end
      end
    
      drawOrientationGrid2 0.2 1.0
    
      renderRotationTest()
    
      if showCameraPositions:
        SceneGraph:visualizeCameras &sg
      end
    
      if (visAnim >= 0):
        anim2 := aptr sg.animations visAnim
        NodeAnimation:visualize (aptr anim2.channels visNodeAnim)
      elseif (showAnimationKeyframes):
        Array:foreach2 sg.animations anim3Num anim3:
          Animation:visualize anim3
        end
      end
    end

    // renderToTarget fbo:
    //   glClearColor 0. 0. 0. 0.
    //   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    //   
    //   glMatrixMode GL_PROJECTION
    //   glLoadIdentity()
    //   aspect := toDouble(windowWidth) / toDouble(windowHeight)
    //   gluPerspective 60.0d aspect 1.0d 20.0d
    // 
    //   glMatrixMode GL_MODELVIEW
    //   glLoadIdentity()
    //   glTranslatef -2. -1. -8.
    // 
    //   glutSolidSphere 3.0d 30 30
    //   drawOrientationGrid2 1.0 1.0
    // end renderToTarget

    Framebuffer:makeDepthTexture fbo
    Framebuffer:makeColorTexture fbo

    /// render final frame
    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    makeGLIdentityTransforms()
    glDisable GL_DEPTH_TEST
    glDisable GL_BLEND
    withShader postprocessMaterial:
      List:foreach pp_params paramIndex3 param3:
        GLSLParameter:apply &param3
      end
      showTextureAt fbo.colorTexture -1. -1. 2. 2.
    end
    
    // glScalef (1. / toFloat aspect) 1. 1.
    // glTranslatef 1.0 -0.5 0.
    // glTranslatef -0.5 -0.5 0.
    // saveAttribs:
    //   glDisable GL_DEPTH_TEST
    //   glDisable GL_BLEND
    //   showTextures:
    //     fbo.colorTexture
    //     fbo.depthTexture
    //   end
    // end

    Timeline2:render timeline

    // makeGLIdentityTransforms()
    // glColor3f 1. 1. 1.
    // glqtPrintfAt -1. -0.6 0. 0.002 int2cstring(visNodeAnim)
    // glqtPrintfAt -1. -0.7 0. 0.002 int2cstring(visAnim)

    printGLError()

    TwDraw()
    flushStdout()
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  println()
  println (toDouble frameNum / (glfwGetTime() - toDouble startTime)) " fps"

  /// store persistent values

  unless isNull(keyboardCameraOrientation):
    dealloc keyboardCameraOrientation
  end
  keyboardCameraOrientation = new RBTransform
  keyboardCameraOrientation* = cam.transform

  return 0
end


