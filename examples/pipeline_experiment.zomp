/**
 * Experiments with pipeline export from XSI
 */

linkclib "libglfw.dylib" "libGLEW.dylib"

static:setRequireLibDebug true

requireLibs opengl20 glfw glutils mathvis assimp libcee anttweakbar array
  unittest quicktext

///-----------------------------------------------------------------------------
/// Section: list
///-----------------------------------------------------------------------------

func cstring List:listTypeName(cstring memberType):
  ret (memberType ++ "_List")
end

macro defineListType memberT:
  listT := ast:fromString List:listTypeName(memberT.id)
  code := ${seq:
    struct #listT:
      #memberT data
      #listT* next
    end
    func void INITFUNCNAME(#listT* this, #memberT data, #listT* next):
      this.data = data
      this.next = next
    end
  end}
  ast:replace code "INITFUNCNAME" ast:fromString(listT.id ++ ":init")
  ret code
end

defineListType int
defineArrayType int

defineListType float
defineArrayType float


macro makeList type nums...:
  listT := ast:fromString(type.id ++ "_List")
  list := ${nullptr #listT}
  i := nums.childCount - 1
  while (i >= 0):
    num := ast:child(nums, i)
    list = ${new #listT #num #list}
    --i
  end

  ret list
end

macro List:foreach_ptr list indexVar dataVar code:
  uniqueId current "Current_list_item"

  ret ${seq:
    #current := #list
    #indexVar := 0
    while isNotNull(#current):
      #dataVar := fieldptr #current data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

macro List:foreach list indexVar dataVar code:
  uniqueId current "Current_list_item"

  ret ${seq:
    #current := #list
    #indexVar := 0
    while isNotNull(#current):
      #dataVar := #current.data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

///-----------------------------------------------------------------------------
/// Section: experimental library extensions
///-----------------------------------------------------------------------------

/// returns the default value for the given type
macro default type:
  ctorName := type.id ++ ":default"
  ret ${#ctorName()}
end

///-----------------------------------------------------------------------------
/// Section: events
///-----------------------------------------------------------------------------

defineListType astp

func cstring eventVarName(cstring id):
  ret ("event_" ++ id)
end

macro defineEvent id:
  varname := eventVarName id.id
  ret ${seq:
    var astp_List* #varname null
  end}
end

macro onEvent id code:
  varname := eventVarName id.id
  ret ${seq:
    macro mtmp:
      newList := malloc astp_List
      newList.next = #varname
      newList.data = ${#code}
      #varname = newList
      ret ${}
    end
    mtmp
  end}
end

macro triggerEvent id:
  varname := eventVarName id.id
  ret ${seq:
    macro mtmp:
      code := ${}
      List:foreach #varname i icode:
        ast:addChild code icode
      end
      ret code
    end
    mtmp
  end}
end

///-----------------------------------------------------------------------------
/// Section: initialization
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init():
  if bool:not(initCalled):
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    if (TwInit(TW_OPENGL, nullptr void) == 0):
      println "AntTweakBar initialization failed, exiting"
      glfwTerminate()
      exit 2
    end

    printString "Initialized"
    println()

    initCalled = true
  else:
    printString "Already initialized"
    println()
  end
end

/// when the main app starts
defineEvent startup

///-----------------------------------------------------------------------------
/// Section: event handling
///-----------------------------------------------------------------------------

func void onTweakbarError(char* msg):
  println "AntTweakBar error: " msg
end

func void onWindowResize(int newWidth, int newHeight):
  // desiredAspect := toFloat windowWidth / toFloat windowHeight
  // correctHeight := toFloat newWidth / desiredAspect
  // glfwSetWindowSize newWidth toInt(correctHeight)
  // windowWidth = newWidth
  // windowHeight = toInt correctHeight
  // TwWindowSize windowWidth windowHeight
  windowWidth = newWidth
  windowHeight = newHeight
  glfwSetWindowSize windowWidth windowHeight
  TwWindowSize windowWidth windowHeight
  ret void
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y):
  TwEventMousePosGLFW x y

  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos):
  TwEventMouseWheelGLFW pos

  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

struct KeyEvent:
  int key
  int action
  double time
end

func KeyEvent KeyEvent:default():
  event := undef KeyEvent
  event.key = 0
  event.action = 0
  event.time = 0.0d
  ret event
end

defineListType KeyEvent

var KeyEvent_List* keyEvents null

func void storeKeyEvent(int key, int action, double time):
  event := malloc KeyEvent_List
  event.data.key = key
  event.data.action = action
  event.data.time = time
  event.next = keyEvents
  keyEvents = event
end

func bool fetchNextKeyEvent(KeyEvent* event):
  if isNull(keyEvents):
    return false
  end

  event* = keyEvents*.data
  toDelete := keyEvents
  keyEvents = keyEvents.next
  dealloc toDelete
  return true
end

func void clearKeyEvents():
  ignore := default KeyEvent
  while fetchNextKeyEvent(&ignore) void
end

func int onKey(int key, int action):
  // if (action == GLFW_PRESS)
  // end

  storeKeyEvent key action glfwGetTime()

  TwEventKeyGLFW key action

  ret 0
end

onEvent startup:
  glfwSetWindowSizeCallback (cast void* &onWindowResize)
  TwHandleErrors &onTweakbarError
  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)
  glfwSetKeyCallback (cast void* &onKey)
  glfwSetMouseButtonCallback (cast void* &TwEventMouseButtonGLFW)
  glfwSetCharCallback (cast void* &TwEventCharGLFW)
end

///-----------------------------------------------------------------------------
/// Section: code
///-----------------------------------------------------------------------------


func void renderGrid3d(v3f min, v3f max, float step):
  rendergl GL_POINTS:
    ffor x min.x max.x step:
      ffor y min.y max.y step:
        ffor z min.x max.z step:
          glVertex3f x y z
        end
      end
    end
  end
end

macro twgroup optionString settings:
  code := ${}
  forEachAstChild s settings:
    if ast:matchesShape(s, ${rw _ _ __}):
      typeId := ast:child s 1
      name := ast:child s 2
      var := ast:child s 3
      ast:addChild code ${TwAddVarRW bar #name #typeId (cast void* &#var)
        #optionString}
    else:
      ret ${error "Expected rw TYPE NAME VAR" #s}
    end
  end

  ret code
end

func GLint objectMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // gl_FragColor = vec4(normalize(normal) * 0.5 + 0.5, 1.0);
    float br = dot(normalize(normal), vec3(0,0,1));
    br += 0.5;
    gl_FragColor = vec4(br, br, br, 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

var float rotationSpeed 64.0
var float playbackSpeed 1.0
var float cameraOffsetX 0.
var float cameraOffsetY 2.
var float cameraOffsetZ 10.

template abortIf cond onFail:
  if #cond:
    #onFail
    ret 0
  end
end

func GLint loadGLSLShader(cstring vsFileName, cstring fsFileName):
  vsSource := nullptr char
  onReturn (dealloc vsSource)
  if (zompLoadFileToMemory(vsFileName, &vsSource) == -1):
    println "Error: could not load " vsFileName
    return 0
  end
  fsSource := nullptr char
  onReturn (dealloc fsSource)
  if (zompLoadFileToMemory fsFileName &fsSource == -1):
    println "Error: could not load " fsFileName
    dealloc vsSource
    return 0
  end

  shader := createShader "" vsSource fsSource

  return shader
end

//------------------------------------------------------------------------------

func void printGLMatrixStacks():
  modelview_stack_depth := 0
  glGetIntegerv GL_MODELVIEW_STACK_DEPTH &modelview_stack_depth
  println "GL_MODELVIEW_STACK_DEPTH = " modelview_stack_depth
  projection_stack_depth := 0
  glGetIntegerv GL_PROJECTION_STACK_DEPTH &projection_stack_depth
  println "GL_PROJECTION_STACK_DEPTH = " projection_stack_depth
end

func void readGLMatrix(GLenum matrix, float* f16):
  glGetFloatv matrix f16
end

func GLint debugMaterial():
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_NormalMatrix * gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    gl_FragColor = vec4(normalize(normal)*0.5+vec3(0.5),1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func void gluLookAtf(
    float eyex, float eyey, float eyez,
    float cx, float cy, float cz,
    float ux, float uy, float uz):
  gluLookAt
    (toDouble eyex) (toDouble eyey) (toDouble eyez)
    (toDouble cx) (toDouble cy) (toDouble cz)
    (toDouble ux) (toDouble uy) (toDouble uz)
end

struct MeshInfo:
  Mesh mesh
  cstring id
  RBTransform transform
end

defineListType Mesh
defineListType MeshInfo
defineArrayType MeshInfo

func MeshInfo_Array collectMeshes(aiScene* scene):
  var MeshInfo_Array meshes
  MeshInfo_Array:init &meshes scene.mNumMeshes

  for meshnum 0 scene.mNumMeshes:
    aimesh := *(scene.mMeshes+meshnum)
    info := meshes.elements + meshnum
    newMesh := aiMesh:toMesh aimesh
    info.mesh = newMesh*
    info.id = ""
    makeOrigin &info.transform
  end

  ret meshes
end

func MeshInfo* lookupMesh(MeshInfo_Array meshes, cstring id):
  Array:foreach meshes num:
    mesh := meshes.elements + num
    if (mesh.id ==_str id):
      ret mesh
    end
  end
  ret nullptr(MeshInfo)
end

func void applyTransform(RBTransform* this):
  // converting to matrix, then applying. not pretty...
  var float[16] mat_
  mat := zmp:array:addr &mat_
  mat[0] = this.xaxis.x
  mat[1] = this.xaxis.y
  mat[2] = this.xaxis.z
  mat[3] = 0.0
  mat[4] = this.yaxis.x
  mat[5] = this.yaxis.y
  mat[6] = this.yaxis.z
  mat[7] = 0.0
  mat[8] =  this.zaxis.x
  mat[9] =  this.zaxis.y
  mat[10] = this.zaxis.z
  mat[11] = 0.0
  mat[12] = this.origin.x
  mat[13] = this.origin.y
  mat[14] = this.origin.z
  mat[15] = 1.0

  glMultMatrixf mat
end

func float lerp(float t, float a, float b):
  return ((1. - t) * a + t * b)
end

unittest:testCase float_lerp:
  unittest:assertAll:
    lerp 0.0 10. 20. == 10.
    lerp 0.5 10. 20. == 15.
    lerp 1.0 10. 20. == 20.
  end
end

// proof of 'unlerp(lerp(t,a,b), a, b) = t', no unit tests needed for this
//   unlerp(lerp(t,a,b), a, b)
// = unlerp(((1-t)*a + t*b), a, b)
// = ((((1-t)*a + t*b) - a) / (b - a))
// = ((a - t*a + t*b - a) / (b - a))
// = ((-t*a + t*b) / (b - a)
// = t * (b-a) / (b-a)
// = t
func float unlerp(float t, float a, float b):
  return ((t - a) / (b - a))
end

func float remapRange(
    float t,
    float oldMin, float oldMax,
    float newMin, float newMax):
  return lerp(unlerp t oldMin oldMax, newMin, newMax)
end

func bool op==_eps(float l, float r):
  // stupid value..
  eps := 0.0001
  return (fabsf (l-r) < eps)
end

unittest:testCase remapRange:
  unittest:assertAll:
    remapRange 10.0 10. 20. 50. 100. ==_eps 50.
    remapRange 20.0 10. 20. 50. 100. ==_eps 100.
    remapRange 15.0 10. 20. 50. 100. ==_eps 75.
  end
end

func float smoothstep(float t):
  return ((3. - 2. * t)*(t*t))
end

func float cubicBezier1d(float t, float p0, float p1, float p2, float p3):
  i := 1. - t
  return (i*i*i*p0 + 3.*i*i*t*p1 + 3.*i*t*t*p2 + t*t*t*p3)
end

struct quatf:
  float x y z w
end

func void quatf:makeConjugate(quatf* this):
  this.x = float:neg this.x
  this.y = float:neg this.y
  this.z = float:neg this.z
end

func quatf quatf:conjugate(quatf q):
  conj := q
  quatf:makeConjugate &conj
  ret conj
end

func float quatf:magnitude(quatf q):
  ret sqrtf(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w)
end

func void quatf:makeNormalized(quatf* this):
  mag := quatf:magnitude *this
  this.x *= mag
  this.y *= mag
  this.z *= mag
  this.w *= mag
end

func quatf quatf:normalized(quatf q):
  r := q
  quatf:makeNormalized &r
  ret r
end

/// adpated from gmtl
func quatf quatf:lerp(float t, quatf a, quatf b):
  // calc cosine theta
  cosom := a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w

  // adjust signs (if necessary)
  b2 := b
  if (cosom < 0.0):
    cosom = float:neg cosom
    b2.x = float:neg b2.x
    b2.y = float:neg b2.y
    b2.z = float:neg b2.z
    b2.w = float:neg b2.w
  end

  // Calculate coefficients
  sclp := 0.0
  sclq := 0.0

  if ( (1.0f - cosom) > 0.0001f): // 0.0001 -> some epsillon
    // Standard case (slerp)
    omega := acosf cosom
    sinom := sinf omega // extract theta from dot product's cos theta
    sclp  = sinf( (1.0 - t) * omega) / sinom
    sclq  = sinf( t * omega) / sinom
  else:
    // Very close, do linear interp (because it's faster)
    sclp = 1.0f - t
    sclq = t
  end

  result := undef quatf
  result.x = sclp * a.x + sclq * b2.x
  result.y = sclp * a.y + sclq * b2.y
  result.z = sclp * a.z + sclq * b2.z
  result.w = sclp * a.w + sclq * b2.w
  ret result
end

// TODO move to libcee <<<
funcd int toupper(int chr)
funcd int tolower(int chr)

func char char:upperCase(char chr):
  ret toChar(toupper(toInt chr))
end

func char char:lowerCase(char chr):
  ret toChar(tolower(toInt chr))
end
// >>>

defineArrayType quatf

func quatf aiQuaternion:quatf(aiQuaternion q):
  ret (structlit quatf x q.x y q.y z q.z w q.w)
end

/// approach by fg
func v3f quatf:rotate(quatf rot, v3f v):
  rot_xyz := mv3f rot.x rot.y rot.z
  t := 2.0 * (rot_xyz *_cross v)
  rv := v + rot.w * t + rot_xyz *_cross t
  ret rv
end

struct KeyFrameVector:
  double time
  v3f value
end

ofunc void print(KeyFrameVector kfv):
  print "KeyFrameVector(time=" kfv.time ", value=" kfv.value ")"
end

struct KeyFrameQuat:
  double time
  quatf value
end

ofunc void print(quatf q):
  print "quatf(x=" q.x ", y=" q.y ", z=" q.z ", w=" q.w ")"
end

ofunc void print(KeyFrameQuat kfq):
  print "KeyFrameQuat(time=" kfq.time ", value=" kfq.value ")"
end

func v3f aiVector3D:vec3f(aiVector3D v):
  var v3f r
  r.x = v.x
  r.y = v.y
  r.z = v.z
  ret r
end

ofunc void print(aiVector3D v):
  aiVector3D:print &v
end

ofunc void print(aiVectorKey vk):
  aiVectorKey:print &vk
end

func KeyFrameVector aiVectorKey:toKeyFrameVector(aiVectorKey* this):
  var KeyFrameVector v
  v.time = this.mTime
  v.value = aiVector3D:vec3f this.mValue
  println "input = " *this
  println "outpt = " v
  ret v
end

defineArrayType KeyFrameVector
defineArrayType KeyFrameQuat

defineArrayType v3f

struct NodeAnimation:
  float duration //TODO remove
  RBTransform* targetTransform
  // float ticksPerSecond

  float_Array transformTimes
  v3f_Array transformKeyframes
  float_Array scaleTimes
  v3f_Array scaleKeyFrames
  float_Array rotatationTimes
  quatf_Array rotationKeyFrames
end

defineArrayType NodeAnimation

struct Animation:
  NodeAnimation_Array channels
  float duration
  cstring name
  // float ticksPerSecond
end

defineArrayType Animation

macro hasType var type:
  uniqueId tmp "hasType"
  ret ${seq:
    #tmp := nullptr #type
    #tmp = &#var
  end}
end

struct KeyframeInterpol:
  int first
  /// t in [0,1], result = lerp(t, keyframe first, keyframe first+1)
  float t
end

func KeyframeInterpol KeyframeInterpol:default():
  ret (structlit KeyframeInterpol first 0 t 0.0)
end

func KeyframeInterpol interpolKeyframeAt(float_Array* keyframeTimes, float time):
  rem := time
  // if (this.duration > 0.0)
  //   rem = fmodf time this.duration
  // end
  keyNum := -1
  found := false

  if (keyframeTimes.length == 1):
    ret (structlit KeyframeInterpol first 0 t 0.)
  elseif (keyframeTimes.length == 0):
    ret (structlit KeyframeInterpol first -1 t 0.)
  end

  result := default KeyframeInterpol

  firstFrameTime := aget(keyframeTimes,0)
  if (firstFrameTime < rem):
    while bool:not(found):
      ++keyNum
      if (keyNum >= keyframeTimes.length):
        found = true
      else:
        key := aget(keyframeTimes, keyNum)
        if (key > rem):
          found = true
        end
      end
    end

    if (keyNum < keyframeTimes.length):
      kfpre := aget(keyframeTimes, keyNum - 1)
      kfpost := aget(keyframeTimes, keyNum)
      result.first = keyNum - 1
      result.t = (rem - kfpre) / (kfpost - kfpre)
    else:
      /// ok, because keyframeTimes.length >= 2 checked above
      result.first = keyframeTimes.length - 2
      result.t = 1.0
    end
  end

  ret result
end

func v3f interpolTransform(float_Array* times, v3f_Array* positions, float time):
  assert (positions.length == times.length)

  if (times.length == 1):
    ret aget(positions*,0)
  end

  interp := interpolKeyframeAt times time
  posA := aget(positions, interp.first)
  posB := aget(positions, interp.first+1)
  ret v3f:lerp(interp.t, posA, posB)
end

func v3f NodeAnimation:transformAt(NodeAnimation* this, float time):
  ret interpolTransform(&this.transformTimes, &this.transformKeyframes, time)
end

func v3f NodeAnimation:scaleAt(NodeAnimation* this, float time):
  ret interpolTransform(&this.scaleTimes, &this.scaleKeyFrames, time)
end

func quatf NodeAnimation:rotationAt(NodeAnimation* this, float time):
  if (this.rotatationTimes.length == 1):
    ret aget(this.rotationKeyFrames, 0)
  end

  interp := interpolKeyframeAt &this.rotatationTimes time
  quatA := aget this.rotationKeyFrames interp.first
  quatB := aget this.rotationKeyFrames (interp.first+1)
  ret quatf:lerp(interp.t, quatA, quatB)
end

func void RBTransform:setRotation(RBTransform* this, quatf rot):
  xx := rot.x * rot.x
  xy := rot.x * rot.y
  xz := rot.x * rot.z
  xw := rot.x * rot.w
  yy := rot.y * rot.y
  yz := rot.y * rot.z
  yw := rot.y * rot.w
  zz := rot.z * rot.z
  zw := rot.z * rot.w

  var float[9] mat2
  mat := zmp:array:addr &mat2
  this.xaxis.x = 1. - 2. * ( yy + zz )
  this.xaxis.y = 2. * ( xy - zw )
  this.xaxis.z = 2. * ( xz + yw )
  this.yaxis.x = 2. * ( xy + zw )
  this.yaxis.y = 1. - 2. * ( xx + zz )
  this.yaxis.z = 2. * ( yz - xw )
  this.zaxis.x = 2. * ( xz - yw )
  this.zaxis.y = 2. * ( yz + xw )
  this.zaxis.z = 1. - 2. * ( xx + yy )
end

func void NodeAnimation:apply(NodeAnimation* this, float time):
  rem := time
  if (this.duration > 0.0):
    rem = fmodf time this.duration
  end

  targetTransform := this.targetTransform
  if isNotNull(targetTransform):
    targetTransform.origin = NodeAnimation:transformAt this rem
    scale := NodeAnimation:scaleAt this rem
    targetTransform.scale = scale.x
    rot := NodeAnimation:rotationAt this rem
    RBTransform:setRotation targetTransform rot
  end
end

func void test2():
  x := new float_Array 10
  y := newArray float 10
end

func void NodeAnimation:init(NodeAnimation* this, aiNodeAnim* source):
  this.duration = 0.0
  this.targetTransform = nullptr RBTransform
  this.transformTimes = makeArray(float, source.mNumPositionKeys)
  this.transformKeyframes = makeArray(v3f, source.mNumPositionKeys)
  this.scaleTimes = makeArray(float, source.mNumScalingKeys)
  this.scaleKeyFrames = makeArray(v3f, source.mNumScalingKeys)
  this.rotatationTimes = makeArray(float, source.mNumRotationKeys)
  this.rotationKeyFrames = makeArray(quatf, source.mNumRotationKeys)

  for transnum 0 source.mNumPositionKeys:
    aikey := *(source.mPositionKeys +_ptr transnum)
    var KeyFrameVector key
    key.time = aikey.mTime
    key.value = aiVector3D:vec3f aikey.mValue
    aset this.transformTimes transnum toFloat(key.time)
    aset this.transformKeyframes transnum key.value
  end

  for scalenum 0 source.mNumScalingKeys:
    skey := *(source.mScalingKeys +_ptr scalenum)
    aset this.scaleTimes scalenum toFloat(skey.mTime)
    aset this.scaleKeyFrames scalenum aiVector3D:vec3f(skey.mValue)
  end

  for rotnum 0 source.mNumRotationKeys:
    rkey := *(source.mRotationKeys +_ptr rotnum)
    aset this.rotatationTimes rotnum toFloat(rkey.mTime)
    aset this.rotationKeyFrames rotnum aiQuaternion:quatf(rkey.mValue)
  end
end

func NodeAnimation* aiNodeAnim:toNodeAnimation(aiNodeAnim* this):
  ret new(NodeAnimation, this)
end

func void Animation:apply(Animation* this, float time):
  for channelNum 0 this.channels.length:
    NodeAnimation:apply (this.channels.elements+channelNum) time
  end
end

struct Color:
  float red green blue
end

func Color color(float red, float green, float blue):
  ret (structlit Color red red green green blue blue)
end

func void renderTimeline(
    float startTime,
    float endTime, int markerCount,
    float* markerPos,
    Color* markerColors):

  if (startTime >= endTime):
    return void
  end

  rendergl GL_LINES:
    glColor3f 1. 1. 1.
    glVertex3f 0. 0. 0.
    glVertex3f 1. 0. 0.

    glVertex3f 0. 0. 0.
    glVertex3f 0. 1. 0.

    glVertex3f 1. 0. 0.
    glVertex3f 1. 1. 0.

    fullSecond := startTime - fmodf startTime 1.0
    while (fullSecond < endTime):
      x2 := remapRange(fullSecond, startTime, endTime, 0., 1.)
      glVertex3f x2 0. 0.
      glVertex3f x2 0.1 0.
      fullSecond += 1.0
    end
  
    pos := markerPos
    color := markerColors
    for markerNum 0 markerCount:
      x := remapRange pos* startTime endTime 0. 1.
      glColor3fv (cast float* color)
      glVertex3f x 0. 0.
      glVertex3f x 1. 0.
    end
  end
end

func void scaleTo2dArea(float left, float bottom, float right, float top):
  makeGLIdentityTransforms
  glMatrixMode GL_MODELVIEW
  glTranslatef -1. -1. 0.
  glScalef 2. 2. 1.
  glTranslatef left bottom 0.
  glScalef (right-left) (top-bottom) 1.
end

///-----------------------------------------------------------------------------
/// Section: scene graph
///-----------------------------------------------------------------------------

struct SceneGraphNode:
  RBTransform globalSpace
  RBTransform relativeTransform
  int_Array meshes
  cstring id
end

defineArrayType SceneGraphNode

struct SceneGraphEdge:
  int parent child
end

defineArrayType SceneGraphEdge
defineArrayType Mesh

struct SceneGraph:
  SceneGraphNode_Array nodes
  SceneGraphEdge_Array edges
  MeshInfo_Array meshes
  Animation_Array anims
end

func void SceneGraphNode:init(SceneGraphNode* this, aiNode* source):
  makeOrigin &this.globalSpace
  makeOrigin &this.relativeTransform
  int_Array:init &this.meshes source.mNumMeshes
  Array:foreach this.meshes meshNum:
    aset this.meshes meshNum *(source.mMeshes + meshNum)
  end
  this.id = aiString:cstring &source.mName
end

func void SceneGraph:collectNodes(
    SceneGraph* this, aiNode* source, int* nodeNum, int* edgeNum):
  node := aptr this.nodes nodeNum*
  SceneGraphNode:init node source
  nodeNum* += 1
  for childNum 0 source.mNumChildren:
    SceneGraph:collectNodes this *(source.mChildren + childNum) nodeNum edgeNum
    // TODO collect edges, too
  end
end

func void MeshInfo:print(MeshInfo* this):
  println "MeshInfo '" this.id "':"
  Mesh:print &this.mesh
  print this.transform
end

func void SceneGraphNode:print(SceneGraphNode* this):
  print "SceneGraphNode('" this.id "', " this.meshes.length " meshes = ["
  for num 0 this.meshes.length:
    if (num > 0):
      print(", ")
    end
    print aget(this.meshes, num)
  end
  println "])"
  println "  globalSpace = "
  print this.globalSpace
end

func void NodeAnimation:print(NodeAnimation* this):
  print "NodeAnimation(" this.transformKeyframes.length
  print "/" this.rotationKeyFrames.length "/" this.scaleKeyFrames.length
  if isNull(this.targetTransform):
    print " no target!"
  end
  println ")"
  Array:foreach this.transformKeyframes tnum:
    pos := aget this.transformKeyframes tnum
    ttime := aget this.transformTimes tnum
    println "  time=" ttime ", pos=" pos
  end
  Array:foreach this.scaleKeyFrames snum:
    scale := aget this.scaleKeyFrames snum
    stime := aget this.scaleTimes snum
    println "  time=" stime ", scale=" scale
  end
  Array:foreach this.rotationKeyFrames rnum:
    rot := aget this.rotationKeyFrames rnum
    rtime := aget this.rotatationTimes rnum
    println "  time=" rtime ", rot=" rot
  end
end

func void Animation:print(Animation* this):
  println "Animation '" this.name "', duration=" this.duration
  printArray this.channels "channels" NodeAnimation:print
end

func void SceneGraph:print(SceneGraph* this):
  println "SceneGraph:"
  print "  "
  printArray this.nodes "nodes" SceneGraphNode:print
  printArray this.anims "anims" Animation:print
  printArray this.meshes "meshes" MeshInfo:print
end

func int SceneGraphNode:lookup(SceneGraphNode_Array* this, cstring id):
  Array:foreach this nodeNum:
    node := aptr this nodeNum
    if (node.id ==_str id):
      ret nodeNum
    end
  end
  ret -1
end

func void Animation:init(
    Animation* this,
    aiAnimation* source,
    SceneGraphNode_Array nodes):
  this.duration = toFloat source.mDuration
  this.name = aiString:cstring &source.mName
  NodeAnimation_Array:init &this.channels source.mNumChannels
  Array:foreach this.channels channelNum:
    channel := this.channels.elements + channelNum
    aianim := *(source.mChannels+channelNum)
    NodeAnimation:init channel aianim
    channel.duration = toFloat this.duration
    println "channel.duration = " channel.duration

    /// connect to target node
    name := aiString:cstring &aianim.mNodeName
    nodeNum := SceneGraphNode:lookup &nodes name
    if (nodeNum >= 0):
      node := aptr nodes nodeNum
      channel.targetTransform = fieldptr node globalSpace
    else:
      println "warning, could not connect anim channel " this.name
    end
  end
end

func void SceneGraph:init(SceneGraph* this, aiScene* source):
  /// meshes
  MeshInfo_Array:init &this.meshes source.mNumMeshes

  Array:foreach this.meshes meshNum:
    aimesh := *(source.mMeshes + meshNum)
    newMesh := aiMesh:toMesh aimesh
    info := aptr this.meshes meshNum
    info.mesh = newMesh*
    info.id = "- SceneGraph mesh-"
    makeOrigin &info.transform
  end

  /// nodes
  SceneGraphNode_Array:init &this.nodes aiScene:totalNodeCount(source)
  SceneGraphEdge_Array:init &this.edges 0
  nodeNum := 0
  edgeNum := 0
  SceneGraph:collectNodes this source.mRootNode &nodeNum &edgeNum
  println "nodeNum = " nodeNum

  /// animations
  Animation_Array:init &this.anims source.mNumAnimations
  Array:foreach this.anims animNum:
    anim := aptr(this.anims, animNum)
    Animation:init anim *(source.mAnimations+animNum) this.nodes
    // targetNodeNum := SceneGraph:lookupNode this anim.name
    // TODO lookup target
  end
end

func void SceneGraph:updateTransforms(SceneGraph* this):
  Array:foreach this.nodes nodeNum:
    node := aptr this.nodes nodeNum
    Array:foreach node.meshes meshNum:
      meshIndex := aget node.meshes meshNum
      info := aptr this.meshes meshIndex
      info.transform = node.globalSpace
    end
  end
end

func int main():
  init()

  println "triggering event startup..."
  triggerEvent startup

  println "loading scene..."
  // sceneFilename := "data/pixeljourney/shared/obj/Reagenztest_tri.obj"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test5.dae"
  // sceneFilename := "data/pixeljourney/move_cube2.dae"
  sceneFilename := "data/pixeljourney/pipetest/combined.dae"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test7_rolling_cube.dae"
  // sceneFilename := "data/collada_test2.dae"
  // sceneFilename := "data/pjm2.obj"
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  loadOptions :=
    aiProcess_Triangulate | aiProcess_SortByPType | aiProcess_GenNormals
  // loadOptions := 0

  scene := aiImportFile sceneFilename loadOptions
  abortIf isNull(scene):
    println "assimp error when loading scene: " aiGetErrorString()
  end

  aiScene:print scene

  var SceneGraph sg
  SceneGraph:init &sg scene
  SceneGraph:print &sg

  meshes := sg.meshes
  // abortIf (isNull meshes) (println "Failed to convert scene to meshes")
  onReturn:
    Array:foreach meshes meshNum:
      pMesh2 := meshes.elements + meshNum
      Mesh:delete &pMesh2.mesh
    end
  end

  anims := sg.anims
  println "Loaded " anims.length " animations"
  animDuration := 10.0
  if (anims.length > 0):
    firstAnim := aptr anims 0
    animDuration = firstAnim.duration
  end

  aiReleaseImport scene
  scene = nullptr aiScene

  // objmat := objectMaterial()
  // objmat := loadGLSLShader "data/simple.vert" "data/simple.frag"
  // objmat := loadGLSLShader "data/incidence.vert" "data/incidence.frag"
  objmat := debugMaterial()
  onReturn glDeleteProgram(objmat)
  objmat_obj2cam := glGetUniformLocation objmat "_object_to_ndc"
  objmat_falloff_amount :=
    glGetUniformLocation objmat "_msl_Component_falloff_1_amount"
  println "objmat_obj2cam = " objmat_obj2cam
  println "objmat_falloff_amount = " objmat_falloff_amount

  bar := TwNewBar "Settings"
  onReturn TwDeleteAllBars()
  TwDefine "Settings refresh=0.01 position='0 20' size='200 200'"
  TwAddSeparator bar (nullptr char) " "

  twgroup "group=options precision=2":
    rw TW_TYPE_FLOAT "playback speed" playbackSpeed
    rw TW_TYPE_FLOAT "rot. speed" rotationSpeed
    rw TW_TYPE_FLOAT "cam dx" cameraOffsetX
    rw TW_TYPE_FLOAT "cam dy" cameraOffsetY
    rw TW_TYPE_FLOAT "cam dz" cameraOffsetZ
  end

  var AABB meshBB
  // Mesh:calcAABB &meshBB mesh
  Mesh:calcAABB &meshBB &(meshes.elements)*.mesh
  // Mesh:calcAABB &meshBB &meshes.data.mesh
  meshSize := AABB:diagonalLength &meshBB

  println "Mesh BB = " meshBB

  meshCenter := AABB:center &meshBB

  angle := 0.0

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL
  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  animTime := 0.0
  mainloop:
    angle = angle + rotationSpeed * frameDuration
    animTime = animTime + playbackSpeed * frameDuration
    animTime = fmodf animTime animDuration
    // if (frameNum <= 0)
    //   println "mesh translate = " meshes.data.transform.origin
    // end
    // if isNotNull(anim)
    //   NodeAnimation:apply anim time
    //   if (frameNum <= 0)
    //     println "anim transform[0] = " getField(aget(anim.transformKeyFrames, 0),value)
    //     println "anim transform[1] = " getField(aget(anim.transformKeyFrames, 1),value)
    //   end
    // end
    Array:foreach anims animNum:
      Animation:apply (anims.elements+animNum) animTime
    end
    SceneGraph:updateTransforms &sg

    keyEvent := default KeyEvent
    while fetchNextKeyEvent(&keyEvent):
      if (keyEvent.action == GLFW_PRESS):
        if (keyEvent.key == GLFW_KEY_P):
          SceneGraph:print &sg
        end
      end
    end

    autoSetupViewport()

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := toDouble(windowWidth) / toDouble(windowHeight)
    camDistance := 0.8
    farPlaneDist := camDistance * meshSize * 2.0 +
      float:max(sqrtf (20.*20.*2.), 0.5 * meshSize)
    nearPlaneDist := float:max(1.0, camDistance - meshSize)
    gluPerspective 90.0d aspect toDouble(nearPlaneDist) toDouble(farPlaneDist)

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    gluLookAtf cameraOffsetX cameraOffsetY cameraOffsetZ 0. 0. 0. 0. 1. 0.
    glRotatef angle 0. 1. 0.

    AABB:render &meshBB
    withShader objmat:
      var float[16] viewMat
      var float[16] projMat
      var float[16] ndc
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &viewMat)
      readGLMatrix GL_PROJECTION_MATRIX (cast float* &projMat)
      glMatrixMode GL_MODELVIEW
      glPushMatrix()
      glMultMatrixf(cast float* &viewMat)
      glMultMatrixf(cast float* &projMat)
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &ndc)
      glPopMatrix()
      // for num 0 16
      //   zmp:array:set viewMat num 0.0
      // end
      // for num2 0 4
      //   zmp:array:set viewMat (num*4+num) 1.0
      // end
      // glUniformMatrix1fv objmat_obj2cam 1 false (cast float* &viewMat)
      glUniform4fv objmat_obj2cam 4 (cast float* &ndc)
      glUniform1f objmat_falloff_amount 0.5
      Array:foreach meshes meshNum2:
        pMeshInfo := (meshes.elements + meshNum2)
        glPushMatrix()
        applyTransform &pMeshInfo.transform
        Mesh:render &pMeshInfo.mesh GL_TRIANGLES 0
        glPopMatrix()
      end
    end

    drawOrientationGrid2 0.2 1.0

    nowColor := color 0.3 0.8 0.2
    scaleTo2dArea 0.03 0.03 0.47 0.13
    renderTimeline 0. animDuration 1 &animTime &nowColor

    printGLError()

    TwDraw()
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  return 0
end


