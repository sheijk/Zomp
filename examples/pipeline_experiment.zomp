/**
 * Experiments with pipeline export from XSI
 */

linkclib "libglfw.dylib" "libGLEW.dylib"

static:setRequireLibDebug true

requireLibs opengl20 glfw glutils mathvis assimp libcee anttweakbar array

///-----------------------------------------------------------------------------
/// Section: list
///-----------------------------------------------------------------------------

func cstring List:listTypeName(cstring memberType)
  ret (memberType ++ "_List")
end

macro defineListType memberT
  listT := ast:fromString List:listTypeName(memberT.id)
  code := ${
    struct #listT
      #memberT data
      #listT* next
    end
    func void INITFUNCNAME(#listT* this, #memberT data, #listT* next)
      this.data = data
      this.next = next
    end
  end}
  ast:replace code "INITFUNCNAME" ast:fromString(listT.id ++ ":init")
  ret code
end

defineListType int
defineListType float

macro makeList type nums...
  listT := ast:fromString(type.id ++ "_List")
  list := ${nullptr #listT}
  i := nums.childCount - 1
  while (i >= 0)
    num := ast:child(nums, i)
    list = ${new #listT #num #list}
    --i
  end

  ret list
end

macro List:foreach_ptr list indexVar dataVar code
  uniqueId current "Current_list_item"

  ret ${
    #current := #list
    #indexVar := 0
    while isNotNull(#current)
      #dataVar := fieldptr #current data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

macro List:foreach list indexVar dataVar code
  uniqueId current "Current_list_item"

  ret ${
    #current := #list
    #indexVar := 0
    while isNotNull(#current)
      #dataVar := #current.data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

///-----------------------------------------------------------------------------
/// Section: events
///-----------------------------------------------------------------------------

defineListType astp

func cstring eventVarName(cstring id)
  ret ("event_" ++ id)
end

macro defineEvent id
  varname := eventVarName id.id
  ret ${
    var astp_List* #varname null
  end}
end

macro onEvent id code
  varname := eventVarName id.id
  ret ${
    macro mtmp
      newList := malloc astp_List
      newList.next = #varname
      newList.data = ${#code}
      #varname = newList
      ret ${}
    end
    mtmp
  end}
end

macro triggerEvent id
  varname := eventVarName id.id
  ret ${
    macro mtmp
      code := ${}
      List:foreach #varname i icode
        ast:addChild code icode
      end
      ret code
    end
    mtmp
  end}
end

///-----------------------------------------------------------------------------
/// Section: initialization
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if bool:not(initCalled)
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    if (TwInit(TW_OPENGL, nullptr void) == 0)
      println "AntTweakBar initialization failed, exiting"
      glfwTerminate()
      exit 2
    end

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

/// when the main app starts
defineEvent startup

///-----------------------------------------------------------------------------
/// Section: event handling
///-----------------------------------------------------------------------------

func void onTweakbarError(char* msg)
  println "AntTweakBar error: " msg
end

func void onWindowResize(int newWidth, int newHeight)
  desiredAspect := toFloat windowWidth / toFloat windowHeight
  correctHeight := toFloat newWidth / desiredAspect
  glfwSetWindowSize newWidth toInt(correctHeight)
  windowWidth = newWidth
  windowHeight = toInt correctHeight
  TwWindowSize windowWidth windowHeight
  ret void
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  TwEventMousePosGLFW x y

  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos)
  TwEventMouseWheelGLFW pos

  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

func int onKey(int key, int action)
  // if (action == GLFW_PRESS)
  // end

  TwEventKeyGLFW key action

  ret 0
end

onEvent startup
  glfwSetWindowSizeCallback (cast void* &onWindowResize)
  TwHandleErrors &onTweakbarError
  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)
  glfwSetKeyCallback (cast void* &onKey)
  glfwSetMouseButtonCallback (cast void* &TwEventMouseButtonGLFW)
  glfwSetCharCallback (cast void* &TwEventCharGLFW)
end

///-----------------------------------------------------------------------------
/// Section: code
///-----------------------------------------------------------------------------


func void renderGrid3d(v3f min, v3f max, float step)
  rendergl GL_POINTS
    ffor x min.x max.x step
      ffor y min.y max.y step
        ffor z min.x max.z step
          glVertex3f x y z
        end
      end
    end
  end
end

macro twgroup optionString settings
  code := ${}
  forEachAstChild s settings
    if ast:matchesShape(s, ${rw _ _ __})
      typeId := ast:child s 1
      name := ast:child s 2
      var := ast:child s 3
      ast:addChild code ${TwAddVarRW bar #name #typeId (cast void* &#var) #optionString}
    else
      ret ${error "Expected rw TYPE NAME VAR" #s}
    end
  end

  ret code
end

func GLint objectMaterial()
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // gl_FragColor = vec4(normalize(normal) * 0.5 + 0.5, 1.0);
    float br = dot(normalize(normal), vec3(0,0,1));
    br += 0.5;
    gl_FragColor = vec4(br, br, br, 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

var float rotationSpeed 64.0
var float cameraOffsetX 0.
var float cameraOffsetY 2.
var float cameraOffsetZ 10.

template abortIf cond onFail
  if #cond
    #onFail
    ret 0
  end
end

func GLint loadGLSLShader(cstring vsFileName, cstring fsFileName)
  vsSource := nullptr char
  onReturn (dealloc vsSource)
  if (zompLoadFileToMemory(vsFileName, &vsSource) == -1)
    println "Error: could not load " vsFileName
    return 0
  end
  fsSource := nullptr char
  onReturn (dealloc fsSource)
  if (zompLoadFileToMemory fsFileName &fsSource == -1)
    println "Error: could not load " fsFileName
    dealloc vsSource
    return 0
  end

  shader := createShader "" vsSource fsSource

  return shader
end

//------------------------------------------------------------------------------

func void printGLMatrixStacks()
  modelview_stack_depth := 0
  glGetIntegerv GL_MODELVIEW_STACK_DEPTH &modelview_stack_depth
  println "GL_MODELVIEW_STACK_DEPTH = " modelview_stack_depth
  projection_stack_depth := 0
  glGetIntegerv GL_PROJECTION_STACK_DEPTH &projection_stack_depth
  println "GL_PROJECTION_STACK_DEPTH = " projection_stack_depth
end

func void readGLMatrix(GLenum matrix, float* f16)
  glGetFloatv matrix f16
end

func GLint debugMaterial()
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_NormalMatrix * gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    gl_FragColor = vec4(normalize(normal)*0.5+vec3(0.5),1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func void gluLookAtf(float eyex, float eyey, float eyez, float cx, float cy, float cz, float ux, float uy, float uz)
  gluLookAt (toDouble eyex) (toDouble eyey) (toDouble eyez) (toDouble cx) (toDouble cy) (toDouble cz) (toDouble ux) (toDouble uy) (toDouble uz)
end

struct MeshInfo
  Mesh mesh
  cstring id
  RBTransform transform
end

defineListType Mesh
defineListType MeshInfo

func MeshInfo_List* addMesh(Mesh* newMesh, MeshInfo_List* tail)
  list := malloc MeshInfo_List
  list.data.mesh = *newMesh
  list.data.id = ""
  makeOrigin &list.data.transform
  list.next = tail
  return list
end

func MeshInfo_List* collectMeshes(aiScene* scene)
  list := nullptr MeshInfo_List
  for meshnum 0 scene.mNumMeshes
    aimesh := *(scene.mMeshes+meshnum)
    mesh := aiMesh:toMesh aimesh
    list = addMesh mesh list
  end
  ret list
end

func MeshInfo* lookupMesh(MeshInfo_List* list, cstring id)
  if isNull(list)
    ret nullptr(MeshInfo)
  elseif (id ==_str list.data.id)
    ret &list.data
  end

  ret lookupMesh(list.next, id)
end

func void applyTransform(RBTransform* this)
  glTranslatef this.origin.x this.origin.y this.origin.z
end

struct KeyFrameVector
  double time
  v3f value
end

ofunc void print(KeyFrameVector kfv)
  print "KeyFrameVector(time=" kfv.time ", value=" kfv.value ")"
end

func v3f aiVector3D:vec3f(aiVector3D v)
  var v3f r
  r.x = v.x
  r.y = v.y
  r.z = v.z
  ret r
end

ofunc void print(aiVector3D v)
  aiVector3D:print &v
end

ofunc void print(aiVectorKey vk)
  aiVectorKey:print &vk
end

func KeyFrameVector aiVectorKey:toKeyFrameVector(aiVectorKey* this)
  var KeyFrameVector v
  v.time = this.mTime
  v.value = aiVector3D:vec3f this.mValue
  println "input = " *this
  println "outpt = " v
  ret v
end

defineArrayType KeyFrameVector

struct NodeAnimation
  float duration //TODO remove
  MeshInfo* targetMesh
  // float ticksPerSecond
  KeyFrameVector_Array transformKeyFrames
end

macro hasType var type
  uniqueId tmp "hasType"
  ret ${
    #tmp := nullptr #type
    #tmp = &#var
  end}
end

func KeyFrameVector NodeAnimation:keyframeAt(NodeAnimation* this, float time)
  rem := time
  if (this.duration > 0.0)
    rem = fmodf time this.duration
  end
  keyNum := -1
  keyframes := this.transformKeyFrames
  found := false

  var KeyFrameVector result

  if (keyframes.length == 1)
    ret aget(keyframes,0)
  elseif (keyframes.length == 0)
    result.time = 0.0d
    result.value = mv3f 0. 0. 0.
    ret result
  end

  firstFrameTime := toFloat getField(aget(keyframes,0), time)
  if (firstFrameTime > rem)
    result = aget keyframes 0
  else
    while bool:not(found)
      ++keyNum
      if (keyNum >= keyframes.length)
        found = true
      else
        key := aget(keyframes, keyNum)
        if (toFloat key.time > rem)
          found = true
        end
      end
    end

    if (keyNum < keyframes.length)
      kfpre := aget keyframes (keyNum-1)
      kfpost := aget keyframes keyNum
      t := (rem - toFloat kfpre.time) / toFloat(kfpost.time - kfpre.time)
      result.time = toDouble rem
      pos := v3f:lerp t kfpre.value kfpost.value
      result.value = pos
    else
      result = aget(keyframes, keyframes.length - 1)
    end
  end

  ret result
end

func void NodeAnimation:apply(NodeAnimation* this, float time)
  keyframes := this.transformKeyFrames
  key := NodeAnimation:keyframeAt(this, time)
  // (this.targetMesh)*.transform.origin = mv3f 0. 5. 0.
  // p := mv3f(0.,10.,0.)
  pos := key.value
  // pos := mv3f 0. 5. 0.
  targetMesh := this.targetMesh
  transform := fieldptr targetMesh transform
  origin := fieldptr transform origin
  store origin pos
  hasType targetMesh MeshInfo*
  hasType transform RBTransform*
  hasType origin v3f*

  // mi := this.targetMesh
  // t := fieldptr mi transform
  // o := fieldptr t origin
  // store o mv3f(0.,10.,0.)
  // hasType mi MeshInfo*
  // hasType t RBTransform*
  // hasType o v3f*
end

func NodeAnimation* aiNodeAnim:toNodeAnimation(aiNodeAnim* this)
  anim := malloc NodeAnimation
  anim.targetMesh = nullptr MeshInfo
  // anim.transformKeyFrames = *newArray(KeyFrameVector, this.mNumPositionKeys)
  transformKeyFrames := *newArray(KeyFrameVector, this.mNumPositionKeys)

  for transnum 0 this.mNumPositionKeys
    // aset transformKeyFrames transnum aiVectorKey:toKeyFrameVector(this.mPositionKeys + transnum)
    aikey := *(this.mPositionKeys +_ptr transnum)
    print "xxx "
    aiVectorKey:print &aikey
    println()
    var KeyFrameVector key
    // key.time = 0.0d
    // key.value = mv3f(0.,5.,0.)
    key.time = aikey.mTime
    key.value = aiVector3D:vec3f aikey.mValue
    // key = aiVectorKey:toKeyFrameVector(this.mPositionKeys + transnum)
    aset transformKeyFrames transnum key
  end

  anim.transformKeyFrames = transformKeyFrames

  ret anim
end

// func AnimationDB* aiAnimation:toAnimationDB(aiAnimation* this)
//   db := malloc AnimationDB
//   db.duration = toFloat this.mDuration
// 
//   for animnum 0 mAnimations
// 
//   transformKeyFrames := newArray KeyFrameVector
// 
//   ret db
// end

func int main()
  init()

  println "triggering event startup..."
  triggerEvent startup

  println "loading scene..."
  // sceneFilename := "data/pixeljourney/shared/obj/Reagenztest_tri.obj"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test5.dae"
  sceneFilename := "data/pixeljourney/move_cube2.dae"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test7_rolling_cube.dae"
  // sceneFilename := "data/collada_test2.dae"
  // sceneFilename := "data/pjm2.obj"
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals)
  // loadOptions := 0

  scene := aiImportFile sceneFilename loadOptions
  abortIf isNull(scene)
    println "assimp error when loading scene: " aiGetErrorString()
  end

  aiScene:print scene
  // cam := malloc aiCamera
  // cam* = **scene.mCameras
  // aiCamera:print cam

  // return 1

  meshes := collectMeshes scene
  abortIf (isNull meshes) (println "Failed to convert scene to meshes")
  onReturn
    List:foreach_ptr meshes _ignore1 pMesh2
      Mesh:delete(&pMesh2.mesh)
    end
  end
  // onReturn Mesh:delete(mesh)
  // List:foreach_ptr meshes _ignore1 pMesh2
  //   Mesh:printDetailed pMesh2
  // end

  // mesh := aiScene:toMesh scene
  // abortIf (isNull mesh) (println "Failed to convert scene to mesh")
  // onReturn Mesh:delete(mesh)

  anim := nullptr NodeAnimation
  if (isNotNull scene.mAnimations && scene.mNumAnimations > 0)
    anim = aiNodeAnim:toNodeAnimation ((scene.mAnimations)*.mChannels)*
    anim.targetMesh = &meshes.data
    anim.duration = 9.0
    println "Loaded animations"
  else
    println "No animations present in scene"
  end

  // VertexStream:swapComponents mesh.positions 1 2

  // Mesh:print mesh

  aiReleaseImport scene
  scene = nullptr aiScene

  // objmat := objectMaterial()
  // objmat := loadGLSLShader "data/simple.vert" "data/simple.frag"
  // objmat := loadGLSLShader "data/incidence.vert" "data/incidence.frag"
  objmat := debugMaterial()
  onReturn glDeleteProgram(objmat)
  objmat_obj2cam := glGetUniformLocation objmat "_object_to_ndc"
  objmat_falloff_amount := glGetUniformLocation objmat "_msl_Component_falloff_1_amount"
  println "objmat_obj2cam = " objmat_obj2cam
  println "objmat_falloff_amount = " objmat_falloff_amount

  bar := TwNewBar "Settings"
  onReturn TwDeleteAllBars()
  TwDefine "Settings refresh=0.01 position='0 20' size='200 200'"
  TwAddSeparator bar (nullptr char) " "

  twgroup "group=options precision=2"
    rw TW_TYPE_FLOAT "rot. speed" rotationSpeed
    rw TW_TYPE_FLOAT "cam dx" cameraOffsetX
    rw TW_TYPE_FLOAT "cam dy" cameraOffsetY
    rw TW_TYPE_FLOAT "cam dz" cameraOffsetZ
  end

  var AABB meshBB
  // Mesh:calcAABB &meshBB mesh
  Mesh:calcAABB &meshBB &meshes.data.mesh
  meshSize := AABB:diagonalLength &meshBB

  println "Mesh BB = " meshBB

  meshCenter := AABB:center &meshBB

  angle := 0.0

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL
  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  mainloop
    angle = angle + rotationSpeed * frameDuration
    if (frameNum <= 0)
      println "mesh translate = " meshes.data.transform.origin
    end
    if isNotNull(anim)
      NodeAnimation:apply anim time
      if (frameNum <= 0)
        println "anim transform[0] = " getField(aget(anim.transformKeyFrames, 0),value)
        println "anim transform[1] = " getField(aget(anim.transformKeyFrames, 1),value)
      end
    end

    autoSetupViewport()

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := toDouble(windowWidth) / toDouble(windowHeight)
    camDistance := 0.8
    farPlaneDist := camDistance * meshSize + float:max(10.0, 0.5 * meshSize)
    nearPlaneDist := float:max(1.0, camDistance - meshSize)
    gluPerspective 90.0d aspect toDouble(nearPlaneDist) toDouble(farPlaneDist)

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    gluLookAtf cameraOffsetX cameraOffsetY cameraOffsetZ 0. 0. 0. 0. 1. 0.
    glRotatef angle 0. 1. 0.

    AABB:render &meshBB
    withShader objmat
      var float[16] viewMat
      var float[16] projMat
      var float[16] ndc
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &viewMat)
      readGLMatrix GL_PROJECTION_MATRIX (cast float* &projMat)
      glMatrixMode GL_MODELVIEW
      glPushMatrix()
      glMultMatrixf(cast float* &viewMat)
      glMultMatrixf(cast float* &projMat)
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &ndc)
      glPopMatrix()
      // for num 0 16
      //   zmp:array:set viewMat num 0.0
      // end
      // for num2 0 4
      //   zmp:array:set viewMat (num*4+num) 1.0
      // end
      // glUniformMatrix1fv objmat_obj2cam 1 false (cast float* &viewMat)
      glUniform4fv objmat_obj2cam 4 (cast float* &ndc)
      glUniform1f objmat_falloff_amount 0.5
      List:foreach_ptr meshes _ignore0 pMesh
        glPushMatrix()
        applyTransform &pMesh.transform
        Mesh:render &pMesh.mesh GL_TRIANGLES 0
        glPopMatrix()
      end
      // Mesh:render mesh GL_TRIANGLES 0
    end

    drawOrientationGrid2 0.2 1.0

    printGLError()

    TwDraw()
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  return 0
end

