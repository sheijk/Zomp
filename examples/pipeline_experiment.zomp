/**
 * Experiments with pipeline export from XSI
 */

linkclib "libglfw.dylib" "libGLEW.dylib"

static:setRequireLibDebug true

requireLibs opengl20 glfw glutils mathvis assimp libcee anttweakbar array unittest quicktext

///-----------------------------------------------------------------------------
/// Section: list
///-----------------------------------------------------------------------------

func cstring List:listTypeName(cstring memberType)
  ret (memberType ++ "_List")
end

macro defineListType memberT
  listT := ast:fromString List:listTypeName(memberT.id)
  code := ${
    struct #listT
      #memberT data
      #listT* next
    end
    func void INITFUNCNAME(#listT* this, #memberT data, #listT* next)
      this.data = data
      this.next = next
    end
  end}
  ast:replace code "INITFUNCNAME" ast:fromString(listT.id ++ ":init")
  ret code
end

defineListType int
defineListType float

macro makeList type nums...
  listT := ast:fromString(type.id ++ "_List")
  list := ${nullptr #listT}
  i := nums.childCount - 1
  while (i >= 0)
    num := ast:child(nums, i)
    list = ${new #listT #num #list}
    --i
  end

  ret list
end

macro List:foreach_ptr list indexVar dataVar code
  uniqueId current "Current_list_item"

  ret ${
    #current := #list
    #indexVar := 0
    while isNotNull(#current)
      #dataVar := fieldptr #current data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

macro List:foreach list indexVar dataVar code
  uniqueId current "Current_list_item"

  ret ${
    #current := #list
    #indexVar := 0
    while isNotNull(#current)
      #dataVar := #current.data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

///-----------------------------------------------------------------------------
/// Section: events
///-----------------------------------------------------------------------------

defineListType astp

func cstring eventVarName(cstring id)
  ret ("event_" ++ id)
end

macro defineEvent id
  varname := eventVarName id.id
  ret ${
    var astp_List* #varname null
  end}
end

macro onEvent id code
  varname := eventVarName id.id
  ret ${
    macro mtmp
      newList := malloc astp_List
      newList.next = #varname
      newList.data = ${#code}
      #varname = newList
      ret ${}
    end
    mtmp
  end}
end

macro triggerEvent id
  varname := eventVarName id.id
  ret ${
    macro mtmp
      code := ${}
      List:foreach #varname i icode
        ast:addChild code icode
      end
      ret code
    end
    mtmp
  end}
end

///-----------------------------------------------------------------------------
/// Section: initialization
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if bool:not(initCalled)
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    if (TwInit(TW_OPENGL, nullptr void) == 0)
      println "AntTweakBar initialization failed, exiting"
      glfwTerminate()
      exit 2
    end

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

/// when the main app starts
defineEvent startup

///-----------------------------------------------------------------------------
/// Section: event handling
///-----------------------------------------------------------------------------

func void onTweakbarError(char* msg)
  println "AntTweakBar error: " msg
end

func void onWindowResize(int newWidth, int newHeight)
  // desiredAspect := toFloat windowWidth / toFloat windowHeight
  // correctHeight := toFloat newWidth / desiredAspect
  // glfwSetWindowSize newWidth toInt(correctHeight)
  // windowWidth = newWidth
  // windowHeight = toInt correctHeight
  // TwWindowSize windowWidth windowHeight
  windowWidth = newWidth
  windowHeight = newHeight
  glfwSetWindowSize windowWidth windowHeight
  TwWindowSize windowWidth windowHeight
  ret void
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  TwEventMousePosGLFW x y

  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos)
  TwEventMouseWheelGLFW pos

  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

func int onKey(int key, int action)
  // if (action == GLFW_PRESS)
  // end

  TwEventKeyGLFW key action

  ret 0
end

onEvent startup
  glfwSetWindowSizeCallback (cast void* &onWindowResize)
  TwHandleErrors &onTweakbarError
  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)
  glfwSetKeyCallback (cast void* &onKey)
  glfwSetMouseButtonCallback (cast void* &TwEventMouseButtonGLFW)
  glfwSetCharCallback (cast void* &TwEventCharGLFW)
end

///-----------------------------------------------------------------------------
/// Section: code
///-----------------------------------------------------------------------------


func void renderGrid3d(v3f min, v3f max, float step)
  rendergl GL_POINTS
    ffor x min.x max.x step
      ffor y min.y max.y step
        ffor z min.x max.z step
          glVertex3f x y z
        end
      end
    end
  end
end

macro twgroup optionString settings
  code := ${}
  forEachAstChild s settings
    if ast:matchesShape(s, ${rw _ _ __})
      typeId := ast:child s 1
      name := ast:child s 2
      var := ast:child s 3
      ast:addChild code ${TwAddVarRW bar #name #typeId (cast void* &#var) #optionString}
    else
      ret ${error "Expected rw TYPE NAME VAR" #s}
    end
  end

  ret code
end

func GLint objectMaterial()
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // gl_FragColor = vec4(normalize(normal) * 0.5 + 0.5, 1.0);
    float br = dot(normalize(normal), vec3(0,0,1));
    br += 0.5;
    gl_FragColor = vec4(br, br, br, 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

var float rotationSpeed 64.0
var float cameraOffsetX 0.
var float cameraOffsetY 2.
var float cameraOffsetZ 10.

template abortIf cond onFail
  if #cond
    #onFail
    ret 0
  end
end

func GLint loadGLSLShader(cstring vsFileName, cstring fsFileName)
  vsSource := nullptr char
  onReturn (dealloc vsSource)
  if (zompLoadFileToMemory(vsFileName, &vsSource) == -1)
    println "Error: could not load " vsFileName
    return 0
  end
  fsSource := nullptr char
  onReturn (dealloc fsSource)
  if (zompLoadFileToMemory fsFileName &fsSource == -1)
    println "Error: could not load " fsFileName
    dealloc vsSource
    return 0
  end

  shader := createShader "" vsSource fsSource

  return shader
end

//------------------------------------------------------------------------------

func void printGLMatrixStacks()
  modelview_stack_depth := 0
  glGetIntegerv GL_MODELVIEW_STACK_DEPTH &modelview_stack_depth
  println "GL_MODELVIEW_STACK_DEPTH = " modelview_stack_depth
  projection_stack_depth := 0
  glGetIntegerv GL_PROJECTION_STACK_DEPTH &projection_stack_depth
  println "GL_PROJECTION_STACK_DEPTH = " projection_stack_depth
end

func void readGLMatrix(GLenum matrix, float* f16)
  glGetFloatv matrix f16
end

func GLint debugMaterial()
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_NormalMatrix * gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    gl_FragColor = vec4(normalize(normal)*0.5+vec3(0.5),1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func void gluLookAtf(float eyex, float eyey, float eyez, float cx, float cy, float cz, float ux, float uy, float uz)
  gluLookAt (toDouble eyex) (toDouble eyey) (toDouble eyez) (toDouble cx) (toDouble cy) (toDouble cz) (toDouble ux) (toDouble uy) (toDouble uz)
end

struct MeshInfo
  Mesh mesh
  cstring id
  RBTransform transform
end

defineListType Mesh
defineListType MeshInfo
defineArrayType MeshInfo

// func MeshInfo_List* addMesh(Mesh* newMesh, MeshInfo_List* tail)
//   list := malloc MeshInfo_List
//   list.data.mesh = *newMesh
//   list.data.id = ""
//   makeOrigin &list.data.transform
//   list.next = tail
//   return list
// end

// func MeshInfo_List* collectMeshes(aiScene* scene)
//   list := nullptr MeshInfo_List
//   for meshnum 0 scene.mNumMeshes
//     aimesh := *(scene.mMeshes+meshnum)
//     mesh := aiMesh:toMesh aimesh
//     list = addMesh mesh list
//   end
//   ret list
// end

func MeshInfo_Array collectMeshes(aiScene* scene)
  var MeshInfo_Array meshes
  MeshInfo_Array:init &meshes scene.mNumMeshes

  for meshnum 0 scene.mNumMeshes
    aimesh := *(scene.mMeshes+meshnum)
    info := meshes.elements + meshnum
    newMesh := aiMesh:toMesh aimesh
    info.mesh = newMesh*
    info.id = ""
    makeOrigin &info.transform
  end

  ret meshes
end

func MeshInfo* lookupMesh(MeshInfo_Array meshes, cstring id)
  Array:foreach meshes num
    mesh := meshes.elements + num
    if (mesh.id ==_str id)
      ret mesh
    end
  end
  ret nullptr(MeshInfo)
end

func void applyTransform(RBTransform* this)
  glTranslatef this.origin.x this.origin.y this.origin.z
end

func float lerp(float t, float a, float b)
  return ((1. - t) * a + t * b)
end

unittest:testCase float_lerp
  unittest:assertAll
    lerp 0.0 10. 20. == 10.
    lerp 0.5 10. 20. == 15.
    lerp 1.0 10. 20. == 20.
  end
end

// proof of 'unlerp(lerp(t,a,b), a, b) = t', no unit tests needed for this
//   unlerp(lerp(t,a,b), a, b)
// = unlerp(((1-t)*a + t*b), a, b)
// = ((((1-t)*a + t*b) - a) / (b - a))
// = ((a - t*a + t*b - a) / (b - a))
// = ((-t*a + t*b) / (b - a)
// = t * (b-a) / (b-a)
// = t
func float unlerp(float t, float a, float b)
  return ((t - a) / (b - a))
end

func float remapRange(float t, float oldMin, float oldMax, float newMin, float newMax)
  return lerp(unlerp t oldMin oldMax, newMin, newMax)
end

func bool op==_eps(float l, float r)
  // stupid value..
  eps := 0.0001
  return (fabsf (l-r) < eps)
end

unittest:testCase remapRange
  unittest:assertAll
    remapRange 10.0 10. 20. 50. 100. ==_eps 50.
    remapRange 20.0 10. 20. 50. 100. ==_eps 100.
    remapRange 15.0 10. 20. 50. 100. ==_eps 75.
  end
end

func float smoothstep(float t)
  return ((3. - 2. * t)*(t*t))
end

func float cubicBezier1d(float t, float p0, float p1, float p2, float p3)
  i := 1. - t
  return (i*i*i*p0 + 3.*i*i*t*p1 + 3.*i*t*t*p2 + t*t*t*p3)
end

struct quatf
  float x y z w
end

func quatf aiQuaternion:quatf(aiQuaternion q)
  ret (structlit quatf x q.x y q.y z q.z w q.w)
end

struct KeyFrameVector
  double time
  v3f value
end

ofunc void print(KeyFrameVector kfv)
  print "KeyFrameVector(time=" kfv.time ", value=" kfv.value ")"
end

struct KeyFrameQuat
  double time
  quatf value
end

ofunc void print(quatf q)
  print "quatf(x=" q.x ", y=" q.y ", z=" q.z ", w=" q.w ")"
end

ofunc void print(KeyFrameQuat kfq)
  print "KeyFrameQuat(time=" kfq.time ", value=" kfq.value ")"
end

func v3f aiVector3D:vec3f(aiVector3D v)
  var v3f r
  r.x = v.x
  r.y = v.y
  r.z = v.z
  ret r
end

ofunc void print(aiVector3D v)
  aiVector3D:print &v
end

ofunc void print(aiVectorKey vk)
  aiVectorKey:print &vk
end

func KeyFrameVector aiVectorKey:toKeyFrameVector(aiVectorKey* this)
  var KeyFrameVector v
  v.time = this.mTime
  v.value = aiVector3D:vec3f this.mValue
  println "input = " *this
  println "outpt = " v
  ret v
end

defineArrayType KeyFrameVector
defineArrayType KeyFrameQuat

struct NodeAnimation
  float duration //TODO remove
  MeshInfo* targetMesh
  // float ticksPerSecond
  KeyFrameVector_Array transformKeyFrames
  KeyFrameVector_Array scaleKeyFrames
  KeyFrameQuat_Array rotationKeyFrames
end

defineArrayType NodeAnimation

struct Animation
  NodeAnimation_Array channels
  float duration
  cstring name
  // float ticksPerSecond
end

defineArrayType Animation

macro hasType var type
  uniqueId tmp "hasType"
  ret ${
    #tmp := nullptr #type
    #tmp = &#var
  end}
end

func KeyFrameVector NodeAnimation:keyframeAt(NodeAnimation* this, float time)
  rem := time
  if (this.duration > 0.0)
    rem = fmodf time this.duration
  end
  keyNum := -1
  keyframes := this.transformKeyFrames
  found := false

  if (keyframes.length == 1)
    ret aget(keyframes,0)
  elseif (keyframes.length == 0)
    ret (structlit KeyFrameVector time 0.0d value mv3f(0.,0.,0.))
  end

  var KeyFrameVector result

  firstFrameTime := toFloat getField(aget(keyframes,0), time)
  if (firstFrameTime > rem)
    result = aget keyframes 0
  else
    while bool:not(found)
      ++keyNum
      if (keyNum >= keyframes.length)
        found = true
      else
        key := aget(keyframes, keyNum)
        if (toFloat key.time > rem)
          found = true
        end
      end
    end

    if (keyNum < keyframes.length)
      kfpre := aget keyframes (keyNum-1)
      kfpost := aget keyframes keyNum
      t := (rem - toFloat kfpre.time) / toFloat(kfpost.time - kfpre.time)
      result.time = toDouble rem
      result.value = v3f:lerp t kfpre.value kfpost.value
    else
      result = aget(keyframes, keyframes.length - 1)
    end
  end

  ret result
end

func void NodeAnimation:apply(NodeAnimation* this, float time)
  keyframes := this.transformKeyFrames
  key := NodeAnimation:keyframeAt(this, time)

  targetMesh := this.targetMesh
  if isNotNull(targetMesh)
    targetMesh.transform.origin = key.value
  end
end

func void NodeAnimation:init(NodeAnimation* this, aiNodeAnim* source)
  this.targetMesh = nullptr MeshInfo
  // this.transformKeyFrames = *newArray(KeyFrameVector, this.mNumPositionKeys)
  transformKeyFrames := *newArray(KeyFrameVector, source.mNumPositionKeys)
  scaleKeyFrames := *newArray(KeyFrameVector, 0)
  rotationKeyFrames := *newArray(KeyFrameQuat, 0)

  for transnum 0 source.mNumPositionKeys
    // aset transformKeyFrames transnum aiVectorKey:toKeyFrameVector(source.mPositionKeys + transnum)
    aikey := *(source.mPositionKeys +_ptr transnum)
    print "xxx "
    aiVectorKey:print &aikey
    println()
    var KeyFrameVector key
    // key.time = 0.0d
    // key.value = mv3f(0.,5.,0.)
    key.time = aikey.mTime
    key.value = aiVector3D:vec3f aikey.mValue
    // key = aiVectorKey:toKeyFrameVector(source.mPositionKeys + transnum)
    aset transformKeyFrames transnum key
  end

  this.transformKeyFrames = transformKeyFrames
  this.scaleKeyFrames = scaleKeyFrames
  this.rotationKeyFrames = rotationKeyFrames
end

func NodeAnimation* aiNodeAnim:toNodeAnimation(aiNodeAnim* this)
  ret new(NodeAnimation, this)
end

func void Animation:init(Animation* this, aiAnimation* source, MeshInfo_Array meshes)
  this.duration = toFloat source.mDuration
  this.name = "-not initialized-"
  NodeAnimation_Array:init &this.channels source.mNumChannels
  Array:foreach this.channels channelNum
    channel := this.channels.elements + channelNum
    aianim := *(source.mChannels+channelNum)
    NodeAnimation:init channel aianim
    name := aiString:cstring &aianim.mNodeName
    // mesh := lookupMesh meshes name
    // if isNull(mesh)
      // println "warning, could not look up mesh " name
    // end
  end
end

func void Animation:apply(Animation* this, float time)
  for channelNum 0 this.channels.length
    NodeAnimation:apply (this.channels.elements+channelNum) time
  end
end

func Animation_Array collectAnimations(aiScene* scene, MeshInfo_Array meshes)
  var Animation_Array anims
  Animation_Array:init &anims scene.mNumAnimations
  for animNum 0 scene.mNumAnimations
    Animation:init (anims.elements+animNum) *(scene.mAnimations+animNum) meshes
  end
  ret anims
end

struct Color
  float red green blue
end

func Color color(float red, float green, float blue)
  ret (structlit Color red red green green blue blue)
end

func void renderTimeline(float startTime, float endTime, int markerCount, float* markerPos, Color* markerColors)
  if (startTime >= endTime)
    return void
  end

  rendergl GL_LINES
    glColor3f 1. 1. 1.
    glVertex3f 0. 0. 0.
    glVertex3f 1. 0. 0.

    glVertex3f 0. 0. 0.
    glVertex3f 0. 1. 0.

    glVertex3f 1. 0. 0.
    glVertex3f 1. 1. 0.

    fullSecond := startTime - fmodf startTime 1.0
    while (fullSecond < endTime)
      x2 := remapRange(fullSecond, startTime, endTime, 0., 1.)
      glVertex3f x2 0. 0.
      glVertex3f x2 0.1 0.
      fullSecond = fullSecond + 1.0
    end

    pos := markerPos
    color := markerColors
    for markerNum 0 markerCount
      x := remapRange pos* startTime endTime 0. 1.
      glColor3fv (cast float* color)
      glVertex3f x 0. 0.
      glVertex3f x 1. 0.
    end
  end
end

func void scaleTo2dArea(float left, float bottom, float right, float top)
  makeGLIdentityTransforms
  glMatrixMode GL_MODELVIEW
  glTranslatef -1. -1. 0.
  glScalef 2. 2. 1.
  glTranslatef left bottom 0.
  glScalef (right-left) (top-bottom) 1.
end

func int main()
  init()

  println "triggering event startup..."
  triggerEvent startup

  println "loading scene..."
  // sceneFilename := "data/pixeljourney/shared/obj/Reagenztest_tri.obj"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test5.dae"
  // sceneFilename := "data/pixeljourney/move_cube2.dae"
  sceneFilename := "data/pixeljourney/pipetest/translate.dae"
  // sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/091129_Colldada_Test7_rolling_cube.dae"
  // sceneFilename := "data/collada_test2.dae"
  // sceneFilename := "data/pjm2.obj"
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  loadOptions := aiProcess_Triangulate | aiProcess_SortByPType | aiProcess_GenNormals
  // loadOptions := 0

  scene := aiImportFile sceneFilename loadOptions
  abortIf isNull(scene)
    println "assimp error when loading scene: " aiGetErrorString()
  end

  aiScene:print scene
  // cam := malloc aiCamera
  // cam* = **scene.mCameras
  // aiCamera:print cam

  // return 1

  meshes := collectMeshes scene
  // abortIf (isNull meshes) (println "Failed to convert scene to meshes")
  onReturn
    Array:foreach meshes meshNum
      pMesh2 := meshes.elements + meshNum
      Mesh:delete &pMesh2.mesh
    end
    // List:foreach_ptr meshes _ignore1 pMesh2
      // Mesh:delete(&pMesh2.mesh)
    // end
  end

  // mesh := aiScene:toMesh scene
  // abortIf (isNull mesh) (println "Failed to convert scene to mesh")
  // onReturn Mesh:delete(mesh)

  animDuration := 2.0

  anims := collectAnimations scene meshes
  println "Loaded " anims.length " animations"

  // anim := nullptr NodeAnimation
  // if (isNotNull scene.mAnimations && scene.mNumAnimations > 0)
  //   anim = aiNodeAnim:toNodeAnimation ((scene.mAnimations)*.mChannels)*
  //   anim.targetMesh = &meshes.data
  //   anim.duration = animDuration
  //   println "Loaded animations"
  // else
  //   println "No animations present in scene"
  // end

  // VertexStream:swapComponents mesh.positions 1 2

  // Mesh:print mesh

  aiReleaseImport scene
  scene = nullptr aiScene

  // objmat := objectMaterial()
  // objmat := loadGLSLShader "data/simple.vert" "data/simple.frag"
  // objmat := loadGLSLShader "data/incidence.vert" "data/incidence.frag"
  objmat := debugMaterial()
  onReturn glDeleteProgram(objmat)
  objmat_obj2cam := glGetUniformLocation objmat "_object_to_ndc"
  objmat_falloff_amount := glGetUniformLocation objmat "_msl_Component_falloff_1_amount"
  println "objmat_obj2cam = " objmat_obj2cam
  println "objmat_falloff_amount = " objmat_falloff_amount

  bar := TwNewBar "Settings"
  onReturn TwDeleteAllBars()
  TwDefine "Settings refresh=0.01 position='0 20' size='200 200'"
  TwAddSeparator bar (nullptr char) " "

  twgroup "group=options precision=2"
    rw TW_TYPE_FLOAT "rot. speed" rotationSpeed
    rw TW_TYPE_FLOAT "cam dx" cameraOffsetX
    rw TW_TYPE_FLOAT "cam dy" cameraOffsetY
    rw TW_TYPE_FLOAT "cam dz" cameraOffsetZ
  end

  var AABB meshBB
  // Mesh:calcAABB &meshBB mesh
  Mesh:calcAABB &meshBB &(meshes.elements)*.mesh
  // Mesh:calcAABB &meshBB &meshes.data.mesh
  meshSize := AABB:diagonalLength &meshBB

  println "Mesh BB = " meshBB

  meshCenter := AABB:center &meshBB

  angle := 0.0

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL
  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  mainloop
    angle = angle + rotationSpeed * frameDuration
    // if (frameNum <= 0)
    //   println "mesh translate = " meshes.data.transform.origin
    // end
    // if isNotNull(anim)
    //   NodeAnimation:apply anim time
    //   if (frameNum <= 0)
    //     println "anim transform[0] = " getField(aget(anim.transformKeyFrames, 0),value)
    //     println "anim transform[1] = " getField(aget(anim.transformKeyFrames, 1),value)
    //   end
    // end
    Array:foreach anims animNum
      Animation:apply (anims.elements+animNum) time
    end

    autoSetupViewport()

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := toDouble(windowWidth) / toDouble(windowHeight)
    camDistance := 0.8
    farPlaneDist := camDistance * meshSize + float:max(10.0, 0.5 * meshSize)
    nearPlaneDist := float:max(1.0, camDistance - meshSize)
    gluPerspective 90.0d aspect toDouble(nearPlaneDist) toDouble(farPlaneDist)

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    gluLookAtf cameraOffsetX cameraOffsetY cameraOffsetZ 0. 0. 0. 0. 1. 0.
    glRotatef angle 0. 1. 0.

    AABB:render &meshBB
    withShader objmat
      var float[16] viewMat
      var float[16] projMat
      var float[16] ndc
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &viewMat)
      readGLMatrix GL_PROJECTION_MATRIX (cast float* &projMat)
      glMatrixMode GL_MODELVIEW
      glPushMatrix()
      glMultMatrixf(cast float* &viewMat)
      glMultMatrixf(cast float* &projMat)
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &ndc)
      glPopMatrix()
      // for num 0 16
      //   zmp:array:set viewMat num 0.0
      // end
      // for num2 0 4
      //   zmp:array:set viewMat (num*4+num) 1.0
      // end
      // glUniformMatrix1fv objmat_obj2cam 1 false (cast float* &viewMat)
      glUniform4fv objmat_obj2cam 4 (cast float* &ndc)
      glUniform1f objmat_falloff_amount 0.5
      Array:foreach meshes meshNum2
        pMeshInfo := (meshes.elements + meshNum2)
        glPushMatrix()
        applyTransform &pMeshInfo.transform
        Mesh:render &pMeshInfo.mesh GL_TRIANGLES 0
        glPopMatrix()
      end
    end

    drawOrientationGrid2 0.2 1.0

    animTime := fmodf time animDuration
    nowColor := color 0.3 0.8 0.2
    scaleTo2dArea 0.03 0.03 0.47 0.13
    renderTimeline 0. animDuration 1 &animTime &nowColor

    printGLError()

    TwDraw()
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  return 0
end


