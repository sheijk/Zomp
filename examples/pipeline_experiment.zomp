/**
 * Experiments with pipeline export from XSI
 */

linkclib "libglfw.dylib" "libGLEW.dylib"

static:setRequireLibDebug true

requireLibs opengl20 glfw glutils mathvis assimp libcee anttweakbar

///-----------------------------------------------------------------------------
/// Section: list
///-----------------------------------------------------------------------------

func cstring List:listTypeName(cstring memberType)
  ret (memberType ++ "_List")
end

macro defineListType memberT
  listT := ast:fromString List:listTypeName(memberT.id)
  code := ${
    struct #listT
      #memberT data
      #listT* next
    end
    func void INITFUNCNAME(#listT* this, #memberT data, #listT* next)
      this.data = data
      this.next = next
    end
  end}
  ast:replace code "INITFUNCNAME" ast:fromString(listT.id ++ ":init")
  ret code
end

defineListType int
defineListType float

macro makeList type nums...
  listT := ast:fromString(type.id ++ "_List")
  list := ${nullptr #listT}
  i := nums.childCount - 1
  while (i >= 0)
    num := ast:child(nums, i)
    list = ${new #listT #num #list}
    --i
  end

  ret list
end

macro List:foreach_ptr list indexVar dataVar code
  uniqueId current "Current_list_item"

  ret ${
    #current := #list
    #indexVar := 0
    while isNotNull(#current)
      #dataVar := fieldptr #current data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

macro List:foreach list indexVar dataVar code
  uniqueId current "Current_list_item"

  ret ${
    #current := #list
    #indexVar := 0
    while isNotNull(#current)
      #dataVar := #current.data
      #code
      ++(#indexVar)
      #current = #current.next
    end
  end}
end

///-----------------------------------------------------------------------------
/// Section: events
///-----------------------------------------------------------------------------

defineListType astp

func cstring eventVarName(cstring id)
  ret ("event_" ++ id)
end

macro defineEvent id
  varname := eventVarName id.id
  ret ${
    var astp_List* #varname null
  end}
end

macro onEvent id code
  varname := eventVarName id.id
  ret ${
    macro mtmp
      newList := malloc astp_List
      newList.next = #varname
      newList.data = ${#code}
      #varname = newList
      ret ${}
    end
    mtmp
  end}
end

macro triggerEvent id
  varname := eventVarName id.id
  ret ${
    macro mtmp
      code := ${}
      List:foreach #varname i icode
        ast:addChild code icode
      end
      ret code
    end
    mtmp
  end}
end

///-----------------------------------------------------------------------------
/// Section: initialization
///-----------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if bool:not(initCalled)
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    if (TwInit(TW_OPENGL, nullptr void) == 0)
      println "AntTweakBar initialization failed, exiting"
      glfwTerminate()
      exit 2
    end

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

/// when the main app starts
defineEvent startup

///-----------------------------------------------------------------------------
/// Section: event handling
///-----------------------------------------------------------------------------

func void onTweakbarError(char* msg)
  println "AntTweakBar error: " msg
end

func void onWindowResize(int newWidth, int newHeight)
  // desiredAspect := toFloat windowWidth / toFloat windowHeight
  // correctHeight := toFloat newWidth / desiredAspect
  // glfwSetWindowSize newWidth toInt(correctHeight)
  // windowWidth = newWidth
  // windowHeight = toInt correctHeight
  // TwWindowSize windowWidth windowHeight
  ret void
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  TwEventMousePosGLFW x y

  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos)
  TwEventMouseWheelGLFW pos

  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

func int onKey(int key, int action)
  // if (action == GLFW_PRESS)
  // end

  TwEventKeyGLFW key action

  ret 0
end

onEvent startup
  glfwSetWindowSizeCallback (cast void* &onWindowResize)
  TwHandleErrors &onTweakbarError
  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)
  glfwSetKeyCallback (cast void* &onKey)
  glfwSetMouseButtonCallback (cast void* &TwEventMouseButtonGLFW)
  glfwSetCharCallback (cast void* &TwEventCharGLFW)
end

///-----------------------------------------------------------------------------
/// Section: code
///-----------------------------------------------------------------------------


func void renderGrid3d(v3f min, v3f max, float step)
  rendergl GL_POINTS
    ffor x min.x max.x step
      ffor y min.y max.y step
        ffor z min.x max.z step
          glVertex3f x y z
        end
      end
    end
  end
end

macro twgroup optionString settings
  code := ${}
  forEachAstChild s settings
    if ast:matchesShape(s, ${rw _ _ __})
      typeId := ast:child s 1
      name := ast:child s 2
      var := ast:child s 3
      ast:addChild code ${TwAddVarRW bar #name #typeId (cast void* &#var) #optionString}
    else
      ret ${error "Expected rw TYPE NAME VAR" #s}
    end
  end

  ret code
end

func GLint objectMaterial()
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // gl_FragColor = vec4(normalize(normal) * 0.5 + 0.5, 1.0);
    float br = dot(normalize(normal), vec3(0,0,1));
    br += 0.5;
    gl_FragColor = vec4(br, br, br, 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

var float rotationSpeed 64.0
var float cameraOffsetX 0.
var float cameraOffsetY 2.
var float cameraOffsetZ 10.

template abortIf cond onFail
  if #cond
    #onFail
    ret 0
  end
end

func GLint loadGLSLShader(cstring vsFileName, cstring fsFileName)
  vsSource := nullptr char
  onReturn (dealloc vsSource)
  if (zompLoadFileToMemory(vsFileName, &vsSource) == -1)
    println "Error: could not load " vsFileName
    return 0
  end
  fsSource := nullptr char
  onReturn (dealloc fsSource)
  if (zompLoadFileToMemory fsFileName &fsSource == -1)
    println "Error: could not load " fsFileName
    dealloc vsSource
    return 0
  end

  shader := createShader "" vsSource fsSource

  return shader
end

//------------------------------------------------------------------------------

func void printGLMatrixStacks()
  modelview_stack_depth := 0
  glGetIntegerv GL_MODELVIEW_STACK_DEPTH &modelview_stack_depth
  println "GL_MODELVIEW_STACK_DEPTH = " modelview_stack_depth
  projection_stack_depth := 0
  glGetIntegerv GL_PROJECTION_STACK_DEPTH &projection_stack_depth
  println "GL_PROJECTION_STACK_DEPTH = " projection_stack_depth
end

func void readGLMatrix(GLenum matrix, float* f16)
  glGetFloatv matrix f16
end

func GLint debugMaterial()
  varyingSource := "
  #version 120
  #extension GL_EXT_gpu_shader4 : enable
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    normal = gl_NormalMatrix * gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    gl_FragColor = vec4(normalize(normal)*0.5+vec3(0.5),1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func void gluLookAtf(float eyex, float eyey, float eyez, float cx, float cy, float cz, float ux, float uy, float uz)
  gluLookAt (toDouble eyex) (toDouble eyey) (toDouble eyez) (toDouble cx) (toDouble cy) (toDouble cz) (toDouble ux) (toDouble uy) (toDouble uz)
end

func int main()
  init()

  println "triggering event startup..."
  triggerEvent startup

  println "loading scene..."
  // sceneFilename := "data/pixeljourney/shared/obj/Reagenztest_tri.obj"
  sceneFilename := "data/pixeljourney/shared/obj/importing_experiments/.dae"
  // sceneFilename := "data/collada_test2.dae"
  // sceneFilename := "data/pjm2.obj"
  // loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices
  loadOptions := (aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals
  // loadOptions := 0

  scene := aiImportFile sceneFilename loadOptions
  abortIf (isNull scene)
    println "assimp error when loading scene: " aiGetErrorString()
  end

  aiScene:print scene
  // cam := malloc aiCamera
  // cam* = **scene.mCameras
  // aiCamera:print cam

  return 1

  mesh := aiScene:toMesh scene
  abortIf (isNull mesh) (println "Failed to convert scene to mesh")
  onReturn Mesh:delete(mesh)
  // VertexStream:swapComponents mesh.positions 1 2

  Mesh:print mesh

  // objmat := objectMaterial()
  // objmat := loadGLSLShader "data/simple.vert" "data/simple.frag"
  // objmat := loadGLSLShader "data/incidence.vert" "data/incidence.frag"
  objmat := debugMaterial()
  onReturn glDeleteProgram(objmat)
  objmat_obj2cam := glGetUniformLocation objmat "_object_to_ndc"
  objmat_falloff_amount := glGetUniformLocation objmat "_msl_Component_falloff_1_amount"
  println "objmat_obj2cam = " objmat_obj2cam
  println "objmat_falloff_amount = " objmat_falloff_amount

  aiReleaseImport scene
  scene = nullptr aiScene

  bar := TwNewBar "Settings"
  onReturn TwDeleteAllBars()
  TwDefine "Settings refresh=0.01 position='0 20' size='200 200'"
  TwAddSeparator bar (nullptr char) " "

  twgroup "group=options precision=2"
    rw TW_TYPE_FLOAT "rot. speed" rotationSpeed
    rw TW_TYPE_FLOAT "cam dx" cameraOffsetX
    rw TW_TYPE_FLOAT "cam dy" cameraOffsetY
    rw TW_TYPE_FLOAT "cam dz" cameraOffsetZ
  end

  var AABB meshBB
  Mesh:calcAABB &meshBB mesh
  meshSize := AABB:diagonalLength &meshBB

  println "Mesh BB = " meshBB

  meshCenter := AABB:center &meshBB

  angle := 0.0

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL
  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  mainloop
    angle = angle + rotationSpeed * frameDuration

    autoSetupViewport()

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := toDouble(windowWidth) / toDouble(windowHeight)
    camDistance := 0.8
    farPlaneDist := camDistance * meshSize + float:max(10.0, 0.5 * meshSize)
    nearPlaneDist := float:max(1.0, camDistance - meshSize)
    gluPerspective 90.0d aspect toDouble(nearPlaneDist) toDouble(farPlaneDist)

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    gluLookAtf cameraOffsetX cameraOffsetY cameraOffsetZ 0. 0. 0. 0. 1. 0.
    // glTranslatef (.0-meshCenter.x) (.0-meshCenter.y) (.0-meshCenter.z)
    // glTranslatef cameraOffsetX cameraOffsetY cameraOffsetZ
    // glTranslatef 0. -0.2 float:neg(camDistance * meshSize)
    // glRotatef angle 0. 1. 0.

    AABB:render &meshBB
    withShader objmat
      var float[16] viewMat
      var float[16] projMat
      var float[16] ndc
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &viewMat)
      readGLMatrix GL_PROJECTION_MATRIX (cast float* &projMat)
      glMatrixMode GL_MODELVIEW
      glPushMatrix()
      glMultMatrixf(cast float* &viewMat)
      glMultMatrixf(cast float* &projMat)
      readGLMatrix GL_MODELVIEW_MATRIX (cast float* &ndc)
      glPopMatrix()
      // for num 0 16
      //   zmp:array:set viewMat num 0.0
      // end
      // for num2 0 4
      //   zmp:array:set viewMat (num*4+num) 1.0
      // end
      // glUniformMatrix1fv objmat_obj2cam 1 false (cast float* &viewMat)
      glUniform4fv objmat_obj2cam 4 (cast float* &ndc)
      glUniform1f objmat_falloff_amount 0.5
      Mesh:render mesh GL_TRIANGLES 0
    end

    drawOrientationGrid2 0.2 1.0

    printGLError()

    TwDraw()
  end

  drawPausedOverlay()
  glfwSwapBuffers()

  return 0
end

