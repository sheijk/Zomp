/**
 * Some experiments with lighting algorithms
 */

require "libs/libcee.zomp"
require "libs/array.zomp"

func bool isQuoted(cstring text)
  len := strlen text
  if (len < 2)
    ret false
  end

  ret ((load text == '"') && (load (text+len-1) == '"'))
end

func cstring unquote(cstring quoted)
  if isQuoted(quoted)
    len := strlen quoted
    unquotedLen := len - 2 + 1
    unquoted := malloc char unquotedLen
    for pos 0 (unquotedLen-1)
      store (unquoted+pos) load(quoted+pos+1)
    end
    store (unquoted + unquotedLen - 1) '\0'

    ret unquoted
  end

  ret quoted
end

func cstring qualifyLibName(cstring name)
  ret cstring:quote("libs/" ++ unquote name ++ ".zomp")
end

macro require firstLibOrType libs...
  var ast* code ${}

  if isQuoted(firstLibOrType.id)
    ast:addChild code ${zmpx:lib:requireLib #firstLibOrType}

    forEachAstChild lib libs
      ast:addChild code ${zmpx:lib:requireLib #lib}
    end
  else
    if (firstLibOrType.id ==_str "lib")
      forEachAstChild libName libs
        qualifiedName := qualifyLibName libName.id
        ast:addChild code ${zmpx:lib:requireLib #qualifiedName}
      end
    else
      ret ${error firstLibOrType "Expected either quoted file name or 'lib'"}
    end
  end

  ret code
end

require "opengl20.zomp" "glfw.zomp" "libs/glutils.zomp" "glut.zomp"
require lib "assimp" "math" "mathvis" "spaceballcam" "anttweakbar"

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if bool:not(initCalled)
    if (glfwInit() != GL_TRUE)
      println "glfw initialization failed, exiting"
      exit 1
    end
    glfwOpenWindowHint GLFW_FSAA_SAMPLES 4
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glfwSetWindowTitle "super duper lighting"

    glewInit()
    times 2 glfwPollEvents()

    if (TwInit(TW_OPENGL, nullptr void) == 0)
      println "AntTweakBar initialization failed, exiting"
      glfwTerminate()
      exit 2
    end

    println "Initialized"

    initCalled = true
  else
    println "Already initialized"
  end
end

// avoid writing it over and over, part of utils lib
macro mainloop body...
  ret ${
    time := 0.0
    lastTime := 0.0
    frameDuration := 0.0
    frameNum := 0
    startTime := toFloat glfwGetTime()
    running := true

    while running
      lastTime = time
      time = toFloat glfwGetTime()
      frameDuration = time - lastTime

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = running && bool:not isPressed(GLFW_KEY_ESC)
      ++frameNum
    end

    endTime := toFloat glfwGetTime()
  end}
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  TwEventMousePosGLFW x y

  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos)
  TwEventMouseWheelGLFW pos

  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

func GLenum Material:showNormals()
  varyingSource := "
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    // normal = gl_NormalMatrix * gl_Normal;
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // float brightness = normal.z * 0.5 + 0.5;
    // gl_FragColor = vec4(0.0,1.0,0.0,1.0) * brightness;
    gl_FragColor = vec4(normalize(normal)*0.5 + vec3(0.5), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

defineArrayType v3f

var SpaceballCamera* cam null

func void renderPoints(v3f_Array* array)
  saveAttribs
    glPointSize 4.0
    rendergl GL_POINTS
      for i 0 array.length
        v := aget array i
        glVertex3f v.x v.y v.z
      end
    end
  end
end

template array:init array indexVar code
  for #indexVar 0 #array.length
    aset #array #indexVar #code
  end
end

macro array:setAll array valueExpr
  uniqueId value "array:setAll"
  uniqueId index "array:setAll"

  ret ${
    #value := #valueExpr
    array:init #array #index #value
  end}
end

func void placeOnCircle(v3f_Array* points, float radius)
  angleDelta := math:pi * 2.0 / toFloat points.length
  array:init points index
    angle := toFloat index * angleDelta
    structlit v3f x (radius * sinf(angle)) y 0. z (radius * cosf(angle))
  end
end

func bool keyDown(GLint key)
  ret(glfwGetKey key == GLFW_PRESS)
end

func bool mouseButtonDown(int button)
  glfwGetMouseButton button == GLFW_PRESS
end

func void glClearDepth(GLdouble depth)

macro showTextures textureList
  count := textureList.childCount
  code := ${}

  width := 1.0 / toFloat count
  height := width

  x := 0.
  y := 0.

  forEachAstChild tex textureList
    ast:addChild code ${showTextureAt #tex #x #y #width #height}
    x = x + width
  end

  ret code
end

func void onWindowResize(int newWidth, int newHeight)
  autoSetupViewport()
  glfwGetWindowSize &windowWidth &windowHeight

  TwWindowSize(newWidth, newHeight)
  ret void
end

func void onTweakbarError(char* msg)
  println "AntTweakBar error: " msg
end

func void drawPointGridXZ(int size)
  max := toFloat size
  min := float:neg max

  glVertex3f 1. 1. 1.
  rendergl GL_POINTS
    ffor x min max 1.0
      ffor z min max 1.0
        glVertex3f x 0.0 z
      end
    end
  end
end

var int lightCount 20
var bool showOrientationGrid true
var bool showNormals true
var bool showSceneBB true

func int main()
  init()

  // array:setAll lightPositions (structlit v3f x 0. y 12. z 0.)
  glfwSetWindowSizeCallback (cast void* &onWindowResize)
  glfwSetMouseButtonCallback (cast void* &TwEventMouseButtonGLFW)
  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)
  glfwSetKeyCallback (cast void* &TwEventKeyGLFW)
  glfwSetCharCallback (cast void* &TwEventCharGLFW)

  TwHandleErrors &onTweakbarError

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL

  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  template abortIf cond message onFail...
    if #cond
      print #message
      #onFail
      ret 0
    end
  end

  lightPositions := newArray v3f lightCount
  placeOnCircle lightPositions 20.0

  // sceneFilename := "data/ModernStructure.3ds"
  // sceneFilename := "data/MonroeBar_SketchUpScene.obj"
  // sceneFilename := "data/living1_max/modern_living_furn.3DS"
  sceneFilename := "data/house.obj"
  loadOptions := aiProcess_Triangulate | aiProcess_SortByPType | aiProcess_GenNormals | aiProcess_PreTransformVertices

  scene := aiImportFile sceneFilename loadOptions
  abortIf (scene == nullptr aiScene) "Error while loading file: "
    println aiGetErrorString()
  end

  mesh := aiScene:toMesh scene
  abortIf (isNull mesh) "Failed to convert scene to mesh"

  aiReleaseImport scene
  scene = nullptr aiScene

  normalStream := mesh.normals
  VertexStream:foreach normalStream float normal
    store (normal+0) (float:neg *(normal+0))
    store (normal+1) (float:neg *(normal+1))
    store (normal+2) (float:neg *(normal+2))
  end

  Mesh:print mesh

  var AABB meshBB
  Mesh:calcAABB &meshBB mesh
  meshSize := AABB:diagonalLength &meshBB
  viewDistance := float:max 2.0 (0.25 * meshSize)

  if isNull(cam)
    cam = new SpaceballCamera
    cam.distance = viewDistance
  end

  bar := TwNewBar "Settings"
  TwDefine "Settings refresh=0.01 position='0 20'"

  TwAddSeparator bar (nullptr char) " "
  twCameraVarOptions := "group=camera precision=2"
  TwAddVarRW bar "distance" TW_TYPE_FLOAT (cast void* &cam.distance) twCameraVarOptions
  TwAddVarRW bar "latitude" TW_TYPE_FLOAT (cast void* &cam.latitude) twCameraVarOptions
  TwAddVarRW bar "longitude" TW_TYPE_FLOAT (cast void* &cam.longitude) twCameraVarOptions

  TwAddVarRW bar "count" TW_TYPE_INT32 (cast void* &lightCount) "group=lights"

  TwAddVarRW bar "Grid" TW_TYPE_BOOL8 (cast void* &showOrientationGrid) "group=display"
  TwAddVarRW bar "Normals" TW_TYPE_BOOL8 (cast void* &showNormals)  "group=display"
  TwAddVarRW bar "Bounding box" TW_TYPE_BOOL8 (cast void* &showSceneBB)  "group=display"

  material := Material:showNormals()

  shadowFBO := new Framebuffer 1024 1024
  Framebuffer:attachColorTexture shadowFBO
  Framebuffer:attachDepthTexture shadowFBO
  Framebuffer:create shadowFBO
  println "Shadow FBO status: " Framebuffer:statusMessage(shadowFBO)

  printTexture2DInfo shadowFBO.colorTexture "shadowFBO.color"
  printTexture2DInfo shadowFBO.depthTexture "shadowFBO.depth"

  print shadowFBO

  angle := 0.0

  mainloop
    /// updating
    autoSetupViewport()
    glfwGetWindowSize &windowWidth &windowHeight
    angle = angle + 128.0 * frameDuration

    if (abs mouseXDelta > abs mouseYDelta)
      mouseYDelta = 0
    else
      mouseXDelta = 0
    end

    if keyDown(GLFW_KEY_LSHIFT)
      cam.longitude = cam.longitude + toFloat(mouseXDelta)
      cam.latitude = cam.latitude + toFloat(mouseYDelta)
    end
    cam.distance = cam.distance + toFloat(mouseWheelDelta)
    SpaceballCamera:restrictParams cam
    mouseXDelta = 0
    mouseYDelta = 0
    mouseWheelDelta = 0

    /// creation of shadow map

    renderToTarget shadowFBO
      glClearColor 0. 0.1 0. 0.
      glClearDepth 1.0d
      glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

      glMatrixMode GL_PROJECTION
      glLoadIdentity()
      farPlaneDist := cam.distance + meshSize
      gluPerspective 90.0d 1.0d 1.0d toDouble(farPlaneDist)

      glMatrixMode GL_MODELVIEW
      glLoadIdentity()
      SpaceballCamera:applyToGL cam
      // drawOrientationGrid()
      Mesh:render mesh GL_TRIANGLES 0

      Framebuffer:makeColorTexture shadowFBO
      Framebuffer:makeDepthTexture shadowFBO
    end

    /// rendering

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    if (bool:not keyDown(GLFW_KEY_LALT) || (frameNum == 0))
      glMatrixMode GL_PROJECTION
      glLoadIdentity()
      aspect := toDouble(windowWidth) / toDouble(windowHeight)
      gluPerspective( 90.0d, aspect, 1.0d, toDouble(farPlaneDist) )

      glMatrixMode GL_MODELVIEW
      glLoadIdentity()
      SpaceballCamera:applyToGL cam

      if showOrientationGrid
        drawOrientationGrid()
      end
      // drawPointGridXZ 100

      withShader material
        Mesh:render mesh GL_TRIANGLES 0
        glutSolidSphere 1.0d 40 40
      end

      if showSceneBB
        glColor3f 1. 1. 1.
        AABB:render &meshBB
      end

      if showNormals
        Mesh:showNormals mesh
      end

      glColor3f 1. 0.5 0.
      renderPoints lightPositions
    else
      makeGLIdentityTransforms()
      glScalef (2. / toFloat aspect) 2. 1.
      glTranslatef -0.5 -0.5 0.
      showTextures
        shadowFBO.colorTexture
        shadowFBO.depthTexture
      end
    end

    TwDraw()
  end

  drawPausedOverlay()
  glfwPollEvents()

  print (toDouble frameNum / (glfwGetTime() - toDouble startTime)) " fps"

  Mesh:delete mesh
  glDeleteProgram material

  v3f_Array:release lightPositions

  Framebuffer:delete shadowFBO

  TwDeleteAllBars()

  ret 0
end

