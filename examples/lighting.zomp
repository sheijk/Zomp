/**
 * Some experiments with lighting algorithms
 */

require "libs/libcee.zomp"
require "libs/array.zomp"

func bool isQuoted(cstring text)
  len := strlen text
  if (len < 2)
    ret false
  end

  ret ((load text == '"') && (load (text+len-1) == '"'))
end

func cstring unquote(cstring quoted)
  if isQuoted(quoted)
    len := strlen quoted
    unquotedLen := len - 2 + 1
    unquoted := malloc char unquotedLen
    for pos 0 (unquotedLen-1)
      store (unquoted+pos) load(quoted+pos+1)
    end
    store (unquoted + unquotedLen - 1) '\0'

    ret unquoted
  end

  ret quoted
end

func cstring qualifyLibName(cstring name)
  ret cstring:quote("libs/" ++ unquote name ++ ".zomp")
end

macro require firstLibOrType libs...
  var ast* code ${}

  if isQuoted(firstLibOrType.id)
    ast:addChild code ${zmpx:lib:requireLib #firstLibOrType}

    forEachAstChild lib libs
      ast:addChild code ${zmpx:lib:requireLib #lib}
    end
  else
    if (firstLibOrType.id ==_str "lib")
      forEachAstChild libName libs
        qualifiedName := qualifyLibName libName.id
        ast:addChild code ${zmpx:lib:requireLib #qualifiedName}
      end
    else
      ret ${error firstLibOrType "Expected either quoted file name or 'lib'"}
    end
  end

  ret code
end

require "opengl20.zomp" "glfw.zomp" "libs/glutils.zomp" "glut.zomp"
require lib "assimp" "math" "mathvis" "spaceballcam"

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if bool:not(initCalled)
    glfwInit()
    glfwOpenWindowHint GLFW_FSAA_SAMPLES 4
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

// avoid writing it over and over, part of utils lib
macro mainloop body...
  ret ${
    time := 0.0
    lastTime := 0.0
    frameDuration := 0.0
    frameNum := 0
    startTime := toFloat glfwGetTime()
    running := true

    while running
      lastTime = time
      time = toFloat glfwGetTime()
      frameDuration = time - lastTime

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = running && bool:not isPressed(GLFW_KEY_ESC)
      ++frameNum
    end

    endTime := toFloat glfwGetTime()
  end}
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos)
  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

func GLenum Material:showNormals()
  varyingSource := "
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    // normal = gl_NormalMatrix * gl_Normal;
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // float brightness = normal.z * 0.5 + 0.5;
    // gl_FragColor = vec4(0.0,1.0,0.0,1.0) * brightness;
    gl_FragColor = vec4(normalize(normal)*0.5 + vec3(0.5), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

defineArrayType v3f

var SpaceballCamera* cam null

func int main()
  init()

  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL

  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  template abortIf cond message onFail...
    if #cond
      print #message
      #onFail
      ret 0
    end
  end

  // sceneFilename := "data/ModernStructure.3ds"
  // sceneFilename := "data/MonroeBar_SketchUpScene.obj"
  // sceneFilename := "data/living1_max/modern_living_furn.3DS"
  sceneFilename := "data/house.obj"
  loadOptions := aiProcess_Triangulate | aiProcess_SortByPType | aiProcess_GenNormals | aiProcess_PreTransformVertices

  scene := aiImportFile sceneFilename loadOptions
  abortIf (scene == nullptr aiScene) "Error while loading file: "
    println aiGetErrorString()
  end

  mesh := aiScene:toMesh scene
  abortIf (isNull mesh) "Failed to convert scene to mesh"

  aiReleaseImport scene
  scene = nullptr aiScene

  normalStream := mesh.normals
  VertexStream:foreach normalStream float normal
    store (normal+0) (float:neg *(normal+0))
    store (normal+1) (float:neg *(normal+1))
    store (normal+2) (float:neg *(normal+2))
  end

  Mesh:print mesh
  
  var AABB meshBB
  Mesh:calcAABB &meshBB mesh
  meshSize := AABB:diagonalLength &meshBB
  viewDistance := float:max 2.0 (0.25 * meshSize)

  if isNull(cam)
    cam = new SpaceballCamera
    cam.distance = viewDistance
  end

  material := Material:showNormals()

  angle := 0.0

  mainloop
    /// updating
    autoSetupViewport()
    glfwGetWindowSize &windowWidth &windowHeight
    angle = angle + 128.0 * frameDuration

    if (abs mouseXDelta > abs mouseYDelta)
      mouseYDelta = 0
    else
      mouseXDelta = 0
    end
    cam.longitude = cam.longitude + toFloat(mouseXDelta)
    cam.latitude = cam.latitude + toFloat(mouseYDelta)
    cam.distance = cam.distance + toFloat(mouseWheelDelta)
    SpaceballCamera:restrictParams cam
    mouseXDelta = 0
    mouseYDelta = 0
    mouseWheelDelta = 0

    /// rendering
    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := toDouble(windowWidth) / toDouble(windowHeight)
    gluPerspective( 90.0d, aspect, 1.0d, toDouble(1.5 * meshSize) )

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    SpaceballCamera:applyToGL cam

    drawOrientationGrid()
    withShader material
      Mesh:render mesh GL_TRIANGLES 0
      glutSolidSphere 1.0d 40 40
    end
    AABB:render &meshBB
    glColor3f 1. 1. 1.
    Mesh:showNormals mesh
  end

  // glClear (GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT)
  drawPausedOverlay()
  // glfwSwapBuffers()
  glfwPollEvents()

  Mesh:delete mesh
  glDeleteProgram material

  ret 0
end

