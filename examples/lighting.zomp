/**
 * Some experiments with lighting algorithms
 */

linkclib "libglfw.dylib" "libGLEW.dylib"

require "opengl20.zomp" "glfw.zomp" "libs/glutils.zomp"
require "libs/assimp.zomp"
require "libs/libcee.zomp"
require "libs/math.zomp" "libs/mathvis.zomp"
require "libs/spaceballcam.zomp"

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if bool:not(initCalled)
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

// avoid writing it over and over, part of utils lib
macro mainloop body...
  ret ${
    time := 0.0
    lastTime := 0.0
    frameDuration := 0.0
    frameNum := 0
    startTime := toFloat glfwGetTime()
    running := true

    while running
      lastTime = time
      time = toFloat glfwGetTime()
      frameDuration = time - lastTime

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = bool:not isPressed(GLFW_KEY_ESC)
      ++frameNum
    end

    endTime := toFloat glfwGetTime()
  end}
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

var int lastMouseWheel 0
var int mouseWheelDelta 0

func void onMouseWheel(int pos)
  mouseWheelDelta = lastMouseWheel - pos
  lastMouseWheel = pos
end

func GLenum Material:showNormals()
  varyingSource := "
  varying vec3 normal;
  "
  vertexSource := "
  void main(void) {
    gl_Position = ftransform();
    // normal = gl_NormalMatrix * gl_Normal;
    normal = gl_Normal;
    }"
  fragmentSource := "
  void main(void) {
    // float brightness = normal.z * 0.5 + 0.5;
    // gl_FragColor = vec4(0.0,1.0,0.0,1.0) * brightness;
    gl_FragColor = vec4(normalize(normal)*0.5 + vec3(0.5), 1.0);
    }"
  shader := createShader varyingSource vertexSource fragmentSource
  assert (shader != 0)
  ret shader
end

func int main()
  init()

  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetMouseWheelCallback (cast void* &onMouseWheel)

  glEnable GL_DEPTH_TEST
  glDepthFunc GL_LEQUAL

  glEnable GL_BLEND
  glBlendFunc GL_ONE GL_ONE_MINUS_SRC_ALPHA

  template abortIf cond message
    if #cond
      print #message
      ret 0
    end
  end

  // sceneFilename := "data/ModernStructure.3ds"
  // sceneFilename := "data/MonroeBar_SketchUpScene.obj"
  sceneFilename := "data/house.obj"
  loadOptions := ((aiProcess_Triangulate | aiProcess_SortByPType) | aiProcess_GenNormals) | aiProcess_PreTransformVertices

  scene := aiImportFile sceneFilename loadOptions
  abortIf (isNull scene) "Error, scene could not be loaded"

  mesh := aiScene:toMesh scene
  abortIf (isNull mesh) "Failed to convert scene to mesh"

  aiReleaseImport scene
  scene = nullptr aiScene

  Mesh:print mesh
  
  var AABB meshBB
  Mesh:calcAABB &meshBB mesh
  meshSize := AABB:diagonalLength &meshBB
  viewDistance := float:max 2.0 (0.25 * meshSize)

  cam := new SpaceballCamera
  cam.distance = viewDistance

  material := Material:showNormals()

  angle := 0.0

  mainloop
    angle = angle + 128.0 * frameDuration

    if (abs mouseXDelta > abs mouseYDelta)
      mouseYDelta = 0
    else
      mouseXDelta = 0
    end
    cam.longitude = cam.longitude + toFloat(mouseXDelta)
    cam.latitude = cam.latitude + toFloat(mouseYDelta)
    cam.distance = cam.distance + toFloat(mouseWheelDelta)
    SpaceballCamera:restrictParams cam
    mouseXDelta = 0
    mouseYDelta = 0
    mouseWheelDelta = 0

    glClearColor 0. 0. 0. 0.
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

    glMatrixMode GL_PROJECTION
    glLoadIdentity()
    aspect := toDouble(windowWidth) / toDouble(windowHeight)
    gluPerspective( 90.0d, aspect, 1.0d, toDouble(1.5 * meshSize) )

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    SpaceballCamera:applyToGL cam
    // glTranslatef 0. -4. (-0.8 * meshSize)
    // glRotatef angle 0. 1. 0.

    drawOrientationGrid()
    glUseProgram material
    Mesh:render mesh GL_TRIANGLES 0
    glUseProgram 0
    AABB:render &meshBB
  end

  drawPausedOverlay()
  glfwSwapBuffers()
  glfwPollEvents()

  Mesh:delete mesh
  glDeleteProgram material

  ret 0
end

