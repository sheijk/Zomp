/**

!verify off

* A simple .obj loader

!load libglfw.dylib
!load libGLEW.dylib
!syntax indent
*/

include "opengl20.zomp"
include "glfw.zomp"
include "libs/glutils.zomp"

include "libs/libcee.zomp"

//------------------------------------------------------------------------------
// Improved unit tests

///
/// An assertion macro which detects certain kinds of expressions and inserts
/// code printing the arguments for better error messages
///
/// Example:
/// x := 20.0
/// unittest:assert (sin 10.0 ==_f 20.0)
///
/// Will result in:
///
/// Assertion failed
/// left = -0.544021
/// right = 20.000000
/// op==_f [2 childs]
///   opjux [2 childs]
///     sinf [0 childs]
///     10.0 [0 childs]
///   x [0 childs]
///
macro unittest:assert testCode
  isCompare := false
  printF := simpleAst "internalErrorIn unittest:assert"
  compareF := simpleAst "internalErrorIn unittest:assert"

  if2 ast:matchesShape(testCode, ${__ ==_f __}) then
    isCompare = true
    printF = simpleAst "printFloat"
    compareF = simpleAst "op==_f"
  elseif ast:matchesShape(testCode, ${__ == __})
    isCompare = true
    printF = simpleAst "printInt"
    compareF = simpleAst "op=="
  end

  if2 isCompare then
    uniqueId lvar "lvar"
    uniqueId rvar "rvar"
    l := ast:child(testCode, 0)
    r := ast:child(testCode, 1)
    ret ${
      #lvar := #l
      #rvar := #r
      unless (#compareF #lvar #rvar)
        printHLine '-' 40
        printlnString "Assertion failed"
        printString "left = "
        #printF #lvar
        println()
        printString "right = "
        #printF #rvar
        println()
        ast:print ${#testCode} 0
      end
    end}
  else
    ret ${
      unless #testCode
        printHLine '-' 40
        printlnString "Assertion failed"
        ast:print ${#testCode} 0
      end
    end}
  end
end

/// redefine to work with indent based syntax expressions
macro unittest:assertAll checks
  var ast* code ${}
  forEachAstChild check checks
    addChild code ${unittest:assert #check}
  end
  ret code
end

//------------------------------------------------------------------------------

macro assert code
  ret ${if2 (bool:not #code) then
    printlnString "error: Assertion failed"
    ast:print ${#code} 0
  end}
end

var float sideLengthf 20.0

// from libstdc
func int rand()

func int random (int max)
  ret int:srem(rand(), max)
end

func float float:random()
  randomInt := random(4097)
  return (int:toFloat(randomInt) /_f 4096.0)
end

func float float:srandom()
  return (float:random() *_f 2.0 -_f 1.0)
end

func float powf(float base, float exp)
func double pow(double base, double exp)

func int int:pow(int base, int exp)
  v := base

  remMults := exp

  while (remMults > 1)
    v = v * base
    remMults = remMults - 1
  end

  ret v
end

template op** base exp
  int:pow(#base, #exp)
end

func float float:mix(float x, float a, float b)
  ret ( (1.0 -_f x) *_f a +_f x *_f b )
end

unittest:testCasesFor float:mix
  float:mix 0.0 1.0 10.0 ==_f 1.0
  float:mix 1.0 0.0 4.0 ==_f 4.0
  float:mix 0.5 0.0 4.0 ==_f 2.0
  float:mix 0.25 0.0 8.0 ==_f 2.0
end

func void free(void* ptr)

template delete ptr
  free (cast void* #ptr)
end

//------------------------------------------------------------------------------
// some simple types

struct Color
  float r
  float g
  float b
  float a
end

func void Color:init(Color* this, float r, float g, float b, float a)
  this.r = r
  this.g = g
  this.b = b
  this.a = a
end

//------------------------------------------------------------------------------
// Quick and dirty arrays

macro defineArrayType type
  arrayTypeName := "Array_" ++ type.id
  initFuncName := "Array_" ++ type.id ++ ":init"

  // initDecl := ${func void NAME(#arrayTypeName* this, int size)}
  initDecl := simpleAst("opcall")
  addChild initDecl simpleAst(initFuncName)
  addChild initDecl ${#arrayTypeName* this}
  addChild initDecl ${int size}

  code := ${
    struct #arrayTypeName
      int length
      #type* elements
    end

    // func void #initFuncName(#arrayTypeName* this, int length)
    func void #initDecl
      this.length = size
      this.elements = malloc(#type, size)
    end
  end}

  ret code
end

template aget array index
  load (ptradd getField(#array, elements) #index)
end

template aset array index value
  store (ptradd getField(#array, elements) #index) #value
end

macro array:setAll array value
  uniqueId size "lala"
  uniqueId i "lala"

  ret ${
    size := getField(#array, length)
    for #i 0 size
      aset #array #i #value
    end
  end}
end

macro Array:foreach array indexVar code
  uniqueId count "array_size"

  ret ${for #indexVar 0 #array.length
    #code
  end}
end

//------------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if2 bool:not(initCalled) then
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

var float angle 0.0

// avoid writing it over and over, part of utils lib
macro mainloop body...
  ret ${
    time := 0.0
    lastTime := 0.0
    frameDuration := 0.0
    frameNum := 0
    startTime := double:toFloat glfwGetTime()
    running := true

    while running
      lastTime = time
      time = double:toFloat glfwGetTime()
      frameDuration = time -_f lastTime
      angle = time *_f 128.0

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = bool:not isPressed(GLFW_KEY_ESC)
      ++frameNum
    end

    endTime := double:toFloat glfwGetTime()
  end}
end

//------------------------------------------------------------------------------

type Field3D
  int sideLength
  float* array
end

template Field3D:checkRange component
  assert (#component >= 0)
  assert (#component < this.sideLength)
end

func int Field3D:index(Field3D* this, int x, int y, int z)
  Field3D:checkRange x
  Field3D:checkRange y
  Field3D:checkRange z

  return (x + z * this.sideLength + y * this.sideLength * this.sideLength)
end

func float Field3D:get(Field3D* this, int x, int y, int z)
  index := Field3D:index(this, x, y, z)

  array := this.array
  return load(ptradd(array, index))
end

func void Field3D:set(Field3D* this, int x, int y, int z, float value)
  index := Field3D:index(this, x, y, z)
  a := this.array
  store ptradd(a, index) value
end

template Field3D:foreach field x y z value code...
  for #x 0 #field.sideLength
    for #y 0 #field.sideLength
      for #z 0 #field.sideLength
        #value := Field3D:get(#field, #x, #y, #z)
        #code
      end
    end
  end
end

func void Field3D:clear(Field3D* this)
  array := this.array
  sideLength := this.sideLength

  for i 0 (sideLength ** 3)
    store ptradd(array, i) 0.0
  end
end

func void Field3D:init(Field3D* this, int sideLength)
  setField this sideLength sideLength
  setField this array malloc(float, sideLength * sideLength * sideLength)
  Field3D:clear this
end

func void Field3D:show(Field3D* this)
  o := -0.5 *_f int:toFloat this.sideLength

  saveTransforms
    glTranslatef o o o
    rendergl GL_POINTS
      Field3D:foreach this x y z v
        r := float:mix v 0.0 1.0
        g := float:mix v 0.0 0.25
        b := float:mix v 0.0 0.0

        glColor3f r g b
        glVertex3i x y z
      end
    end
  end
end

struct Metaballs
  int count
  float* xs
  float* ys
  float* zs
  float* xvels
  float* yvels
  float* zvels
  float* strengths
end

template Metaballs:foreach ballnum balls code...
  for #ballnum 0 #balls.count
    #code
  end
end

func void Metaballs:init(Metaballs* this, int count)
  template tempAndMemberArray name
    #name := malloc float count
    this.#name = #name
  end

  this.count = count

  tempAndMemberArray xs
  tempAndMemberArray ys
  tempAndMemberArray zs
  tempAndMemberArray xvels
  tempAndMemberArray yvels
  tempAndMemberArray zvels
  tempAndMemberArray strengths

  max := 20.0
  offet := -10.0

  Metaballs:foreach ballnum this
    xs[ballnum] = max *_f float:random() +_f offet
    ys[ballnum] = max *_f float:random() +_f offet
    zs[ballnum] = max *_f float:random() +_f offet
    xvels[ballnum] = float:neg xs[ballnum] /_f 4.0
    yvels[ballnum] = float:neg ys[ballnum] /_f 4.0
    zvels[ballnum] = float:neg zs[ballnum] /_f 4.0
    strengths[ballnum] = 1.0
  end
end

func void Metaballs:update(Metaballs* this, float time)
  xs := this.xs
  ys := this.ys
  zs := this.zs
  xvels := this.xvels
  yvels := this.yvels
  zvels := this.zvels

  t := time /_f 1.0

  minpos := -0.5 *_f sideLengthf
  maxpos := 0.5 *_f sideLengthf

  Metaballs:foreach ballnum this
    xs[ballnum] = xs[ballnum] +_f t *_f xvels[ballnum]
    ys[ballnum] = ys[ballnum] +_f t *_f yvels[ballnum]
    zs[ballnum] = zs[ballnum] +_f t *_f zvels[ballnum]

    acc := 1.0 /_f 10.0 *_f float:random()

    if2 (xs[ballnum] <_f minpos) then
      xvels[ballnum] = xvels[ballnum] +_f acc
    elseif (xs[ballnum] >_f maxpos)
      xvels[ballnum] = xvels[ballnum] -_f acc
    end
    if2 (ys[ballnum] <_f minpos) then
      yvels[ballnum] = yvels[ballnum] +_f acc
    elseif (ys[ballnum] >_f maxpos)
      yvels[ballnum] = yvels[ballnum] -_f acc
    end
    if2 (zs[ballnum] <_f minpos) then
      zvels[ballnum] = zvels[ballnum] +_f acc
    elseif (zs[ballnum] >_f maxpos)
      zvels[ballnum] = zvels[ballnum] -_f acc
    end

    maxVel := 10.0
    minVel := -10.0

    xvels[ballnum] = float:clamp(minVel, maxVel, xvels[ballnum])
    yvels[ballnum] = float:clamp(minVel, maxVel, yvels[ballnum])
    zvels[ballnum] = float:clamp(minVel, maxVel, zvels[ballnum])
  end
end

func void Metaballs:print(Metaballs* this)
  printInt this.count
  printlnString " metaballs"

  xs := this.xs
  ys := this.ys
  zs := this.zs
  strengths := this.strengths

  Metaballs:foreach ballnum this
    printString "  x = "
    printFloat xs[ballnum]
    printString ", y = "
    printFloat ys[ballnum]
    printString ", z = "
    printFloat zs[ballnum]
    printString ", strength = "
    printFloat strengths[ballnum]
    println()
  end
end

func void Metaballs:applyToField(Metaballs* this, Field3D* field)
  xs := this.xs
  ys := this.ys
  zs := this.zs

  Field3D:clear(field)

  mballSize := 4.0

  offset := -0.5 *_f sideLengthf

  Field3D:foreach field x y z value
    newValue := value
    Metaballs:foreach ballnum this
      xd := int:toFloat x -_f xs[ballnum] +_f offset
      yd := int:toFloat y -_f ys[ballnum] +_f offset
      zd := int:toFloat z -_f zs[ballnum] +_f offset
      d := sqrtf(xd *_f xd +_f yd *_f yd +_f zd *_f zd)

      newValue = newValue +_f float:max(0.0, 1.0 -_f d /_f mballSize)
    end
    Field3D:set(field, x, y, z, newValue)
  end
end

func void Metaballs:show(Metaballs* this)
  xs := this.xs
  ys := this.ys
  zs := this.zs
  strengths := this.strengths

  rendergl GL_POINTS
    glColor3f 1.0 0.0 0.0
    Metaballs:foreach ballnum this
      glVertex3f xs[ballnum] ys[ballnum] zs[ballnum]
    end
  end
end

// TODO: metaballs reintun
// http://en.wikipedia.org/wiki/Marching_cubes

defineArrayType int
defineArrayType float

struct Point
  float x
  float y
  float z
end

func void Point:init(Point* this, float x, float y, float z)
  this.x = x
  this.y = y
  this.z = z
end

func void Point:print(Point* this)
  printString "Point ("
  printFloat this.x
  printString ", "
  printFloat this.y
  printString ", "
  printFloat this.z
  printString ")"
end

func void printsi(cstring str, int i)
  printString str
  printChar ' '
  printInt i
end

func void printsf(cstring str, float f)
  printString str
  printChar ' '
  printFloat f
end

func void Point:print(Point* this)
  printString "(Point"
  printsf " x = " this.x
  printsf " y = " this.y
  printsf " z = " this.z
  printChar ')'
end

struct Metaball
  Point pos
  float strength
end

func void Metaball:print(Metaball* this)
  printString "(Metaball pos="
  Point:print fieldptr(this, pos)
  printsf " strength = " this.strength
  printChar ')'
end

// func Point Point:make(float x, float y, float z)
//   var Point p
//   p.x = x
//   p.y = y
//   p.z = z
//   ret p
// end

// defineArrayType Metaball
// 
// testf
//   balls := new Array_Metaball 10
// 
//   Array:foreach balls i
//     var Metaball b
//     b = aget balls i
//     Metaball:print &b
//     println()
//   end
// 
//   delete balls
// end

// testf
//   var Metaball mb
//   var Point p
//   p.x = 1.0
//   p.y = 1.0
//   p.z = 1.0
//   mb.pos = p
// 
//   printFloat mb.pos.x
// end

/**/

//------------------------------------------------------------------------------

func void resizeWindow(int width, int height)
  windowWidth = width
  windowHeight = height
  glfwSetWindowSize windowWidth windowHeight
end

// macro executeOnce
//   uniqueId alreadyRun "executeOnce"
//   ret ${
//   end}
// end

type degree float

///
/// A camera defined by longitude, latitude and distance
///
struct SpaceballCamera
  /// angle between z-axis and rotation around y-axis
  degree longitude

  /// angle between z-axis and rotation around x-axis
  degree latitude

  degree distance
end

func void SpaceballCamera:init(SpaceballCamera* this)
  this.latitude = 0.f
  this.longitude = 0.f
  this.distance = 1.f
end

func void SpaceballCamera:rotate(SpaceballCamera* this)
  glTranslatef 0. 0. float:neg(this.distance)
  glRotatef this.latitude 1. 0. 0.
  glRotatef this.longitude 0. 1. 0.
end

// memberFunc void SpaceballCamera.rotate()
// ...
// end

func void SpaceballCamera:applyToGL(SpaceballCamera* this)
  glMatrixMode GL_MODELVIEW
  glLoadIdentity()
  SpaceballCamera:rotate(this)
end

func float posmod(float x, float divisor)
  mod := fmodf(x, divisor)

  if2 (mod <_f 0.0) then
    mod = divisor -_f float:neg(mod)
  end

  ret mod
end

unittest:testCasesFor posmod
  posmod(0.0,2.0) ==_f 0.0
  posmod(1.0,2.0) ==_f 1.0
  posmod(2.0,2.0) ==_f 0.0

  posmod(-1.0,3.0) ==_f 2.0
  posmod(-2.0,3.0) ==_f 1.0

  posmod(23.0, 4.0) ==_f 3.0
  posmod(-61.0, 3.0) ==_f 2.0
end

func void SpaceballCamera:restrictParams(SpaceballCamera* this)
  this.longitude = posmod this.longitude 360.0f
  this.latitude = float:clamp float:neg(90.0) 90.0 this.latitude
  this.distance = float:max 0.0 this.distance
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

func char* char:toCString(char c)
  str := "X"
  store (cast char* str) c
  ret str
end

var bool resizeDirty false

func void onWindowResize(int newWidth, int newHeight)
  printString "Window was resized to "
  printInt newWidth
  printString "x"
  printInt newHeight
  println()

  windowWidth = newWidth
  windowHeight = newHeight
  glViewport 0 0 windowWidth windowHeight

  resizeDirty = true
end

func void framebuffer:print(framebuffer* this)
  macro printMember name printF
    quoteStr := char:toCString '"' // '"' dumb emacs parser \o/
    text := quoteStr ++ " " ++ name.id ++ "=" ++ quoteStr
    ret ${
      printString #text
      #printF this.#name
    end}
  end

  template printIntMember name
    printMember #name printInt
  end

  printString "(framebuffer"
  printIntMember width
  printIntMember height
  printIntMember fbo
  printIntMember colorTexture
  printIntMember colorBuffer
  printIntMember depthTexture
  printIntMember depthBuffer
end

func int main()
  init()
  // resizeWindow 1440 900

  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetWindowSizeCallback (cast void* &onWindowResize)

  glMatrixMode( GL_PROJECTION )
  glLoadIdentity()
  aspect := int:toDouble(windowWidth) /_d int:toDouble(windowHeight)
  gluPerspective( 90.0d, aspect, 1.0d, 200.0d )

  cam := new SpaceballCamera
  cam.distance = 100.0f

  field := new Field3D (float:toInt sideLengthf)
  mballs := new Metaballs 50

  glowShader := createShader /*varying*/"
  #version 120
  varying vec2 texCoord;
  " /*vertex*/"
  void main(void) {
    gl_Position = ftransform();
    texCoord = gl_MultiTexCoord0.xy;
    }
  " /*fragment*/"
  uniform sampler2D tex;
  const int offsetCount = 21;
  uniform float offsetx[offsetCount];
  uniform float offsety[offsetCount];
  uniform float weights[offsetCount];

  void main(void) {
    float pixx = 1.0/800.0;
    float pixy = 1.0/600.0;

    vec4 color = vec4(0.0);
    for(int i = 0; i < offsetCount; ++i) {
        float d = float(1 + abs(i - (offsetCount/2)));
        float scale = 1.0 / d;
        color += scale * texture2D(tex, texCoord + vec2(offsetx[i], offsety[i]));
      }
    gl_FragColor = color;
    }"
  assert (glowShader != 0)

  template initRenderTarget target
    #target = framebuffer:new(windowWidth, windowHeight)
    assert (#target !=_ptr nullptr framebuffer)
    framebuffer:attachColorTexture #target
    framebuffer:create #target
  end

  target := nullptr framebuffer
  initRenderTarget target
  target2 := nullptr framebuffer
  initRenderTarget target2

  offsetCount := 21
  pixw := 1.0 /_f int:toFloat(windowWidth)
  pixh := 1.0 /_f int:toFloat(windowHeight)

  offsetx1 := malloc float offsetCount
  offsetx2 := malloc float offsetCount
  offsety1 := malloc float offsetCount
  offsety2 := malloc float offsetCount
  weights := malloc float offsetCount

  for i 1 ((offsetCount+1)/2)
    s := int:toFloat i
    h := offsetCount/2 + i
    l := offsetCount/2 - i

    offsetx1[l] = float:neg(pixw *_f s)
    offsetx1[h] = pixw *_f s
    offsety1[l] = 0.0
    offsety1[h] = 0.0

    offsetx2[l] = 0.0
    offsetx2[h] = 0.0
    offsety2[l] = float:neg(pixh *_f s)
    offsety2[h] = pixh *_f s

    // weights[l] = 1.0 /_f int:toFloat i
    // weights[h] = 1.0 /_f int:toFloat i
  end
  offsetCountH := offsetCount/2
  offsetx1[offsetCountH] = 0.0
  offsety1[offsetCountH] = 0.0
  offsetx2[offsetCountH] = 0.0
  offsety2[offsetCountH] = 0.0
  // weights[offsetCountH] = 1.0
  for wi 0 offsetCount
    weights[offsetCount] = 1.0
  end

  mainloop
    if2 resizeDirty then
      initRenderTarget target
      initRenderTarget target2

      resizeDirty = false
    end

    glClearColor(0.0, 0.0, 0.0, 1.0)
    glClear int:or(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT)

    if2 (abs mouseXDelta > abs mouseYDelta) then
      mouseYDelta = 0
    else
      mouseXDelta = 0
    end
    cam.longitude = cam.longitude +_f int:toFloat(mouseXDelta)
    cam.latitude = cam.latitude +_f int:toFloat(mouseYDelta)
    SpaceballCamera:restrictParams cam
    mouseXDelta = 0
    mouseYDelta = 0

    if2 (time -_f startTime >_f 1.0) then
      Metaballs:update mballs frameDuration
      Metaballs:applyToField mballs field
    end

    renderToTarget target
      glClear int:or(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT)

      glMatrixMode GL_MODELVIEW
      glLoadIdentity()
      SpaceballCamera:applyToGL cam

      drawCoordSys 8.0

      saveTransforms
        sideLength := field.sideLength
        scale := 100.0 /_f int:toFloat(sideLength)
        glScalef scale scale scale

        Field3D:show field
        Metaballs:show mballs
      end
    end
    framebuffer:makeColorTexture target

    glUseProgram glowShader
    renderToTarget target2
      glBindTexture2D getField(target, colorTexture)
      gl:uniform1fv glowShader "offsetx" offsetCount offsetx1
      gl:uniform1fv glowShader "offsety" offsetCount offsety1
      gl:uniform1fv glowShader "weights" offsetCount weights
      drawFullscreenQuad()
    end

    glBindTexture2D getField(target2, colorTexture)
    gl:uniform1fv glowShader "offsetx" offsetCount offsetx2
    gl:uniform1fv glowShader "offsety" offsetCount offsety2
    gl:uniform1fv glowShader "weights" offsetCount weights
    drawFullscreenQuad()
    glBindTexture2D 0

    glUseProgram 0
  end

  drawPausedOverlay()
  glfwSwapBuffers()
  glfwPollEvents()

  println()
  printFloat (endTime -_f startTime)
  printString "s, "
  printInt frameNum
  printString " frames, "
  printFloat (int:toFloat frameNum /_f (endTime -_f startTime))
  printlnString " fps"

  glDeleteShader glowShader
  delete field
  delete mballs

  delete offsetx1
  delete offsety1
  delete offsetx2
  delete offsety2

  //TODO: release target, target2

  ret 0
end

func void test()
  runMain()
end

