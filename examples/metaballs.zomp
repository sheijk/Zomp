/**

!verify off

* A simple .obj loader

!load libglfw.dylib
!load libGLEW.dylib
!syntax indent
*/

include "opengl20.zomp"
include "glfw.zomp"
include "libs/glutils.zomp"

include "libs/libcee.zomp"

//------------------------------------------------------------------------------
// Improved unit tests

///
/// An assertion macro which detects certain kinds of expressions and inserts
/// code printing the arguments for better error messages
///
/// Example:
/// x := 20.0
/// unittest:assert (sin 10.0 ==_f 20.0)
///
/// Will result in:
///
/// Assertion failed
/// left = -0.544021
/// right = 20.000000
/// op==_f [2 childs]
///   opjux [2 childs]
///     sinf [0 childs]
///     10.0 [0 childs]
///   x [0 childs]
///
macro unittest:assert testCode
  isCompare := false
  printF := simpleAst "internalErrorIn unittest:assert"
  compareF := simpleAst "internalErrorIn unittest:assert"

  if2 ast:matchesShape(testCode, ${_ ==_f _}) then
    isCompare = true
    printF = simpleAst "printFloat"
    compareF = simpleAst "op==_f"
  elseif ast:matchesShape(testCode, ${_ == _})
    isCompare = true
    printF = simpleAst "printInt"
    compareF = simpleAst "op=="
  end

  if2 isCompare then
    uniqueId lvar "lvar"
    uniqueId rvar "rvar"
    l := ast:child(testCode, 0)
    r := ast:child(testCode, 1)
    ret ${
      #lvar := #l
      #rvar := #r
      unless (#compareF #lvar #rvar)
        printHLine '-' 40
        printlnString "Assertion failed"
        printString "left = "
        #printF #lvar
        println()
        printString "right = "
        #printF #rvar
        println()
        ast:print ${#testCode} 0
      end
    end}
  else
    ret ${
      unless #testCode
        printHLine '-' 40
        printlnString "Assertion failed"
        ast:print ${#testCode} 0
      end
    end}
  end
end

/// pointless(?) redefinition using indent syntax
macro unittest:assertAll checks
  var ast* code ${}
  forEachAstChild check checks
    addChild code ${unittest:assert #check}
  end
  ret code
end

//------------------------------------------------------------------------------

var float sideLengthf 20.0

// from libstdc
func int rand()

func int random (int max)
  ret int:srem(rand(), max)
end

func float float:random()
  randomInt := random(4097)
  return (int:toFloat(randomInt) /_f 4096.0)
end

func float float:srandom()
  return (float:random() *_f 2.0 -_f 1.0)
end

func float powf(float base, float exp)
func double pow(double base, double exp)

func int int:pow(int base, int exp)
  v := base

  remMults := exp

  while (remMults > 1)
    v = v * base
    remMults = remMults - 1
  end

  ret v
end

template op** base exp
  int:pow(#base, #exp)
end

func float float:mix(float x, float a, float b)
  ret ( (1.0 -_f x) *_f a +_f x *_f b )
end

unittest:testCasesFor float:mix
  float:mix 0.0 1.0 10.0 ==_f 1.0
  float:mix 1.0 0.0 4.0 ==_f 4.0
  float:mix 0.5 0.0 4.0 ==_f 2.0
  float:mix 0.25 0.0 8.0 ==_f 2.0
end


//------------------------------------------------------------------------------
// some simple types

struct Color
  float r
  float g
  float b
  float a
end

func void Color:init(Color* this, float r, float g, float b, float a)
  this.r = r
  this.g = g
  this.b = b
  this.a = a
end

//------------------------------------------------------------------------------
// Quick and dirty arrays

macro defineArrayType type
  arrayTypeName := "Array_" ++ type.id
  initFuncName := "Array_" ++ type.id ++ ":init"

  // initDecl := ${func void NAME(#arrayTypeName* this, int size)}
  initDecl := simpleAst("opcall")
  addChild initDecl simpleAst(initFuncName)
  addChild initDecl ${#arrayTypeName* this}
  addChild initDecl ${int size}

  code := ${
    struct #arrayTypeName
      int length
      #type* elements
    end

    // func void #initFuncName(#arrayTypeName* this, int length)
    func void #initDecl
      this.length = size
      this.elements = malloc(#type, size)
    end
  end}

  ret code
  // println()
  // printHLine '-' 80
  // ast:print code 0
  // printHLine '-' 80
  //
  // ret ${}
end

template aget array index
  load (ptradd getField(#array, elements) #index)
end

template aset array index value
  store (ptradd getField(#array, elements) #index) #value
end

macro array:setAll array value
  uniqueId size "lala"
  uniqueId i "lala"

  ret ${
    size := getField(#array, length)
    for #i 0 size
      aset #array #i #value
    end
  end}
end

//------------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if2 bool:not(initCalled) then
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

var float angle 0.0

// avoid writing it over and over, part of utils lib
macro mainloop body...
  ret ${
    time := 0.0
    lastTime := 0.0
    frameDuration := 0.0
    frameNum := 0
    startTime := double:toFloat glfwGetTime()
    running := true

    while running
      lastTime = time
      time = double:toFloat glfwGetTime()
      frameDuration = time -_f lastTime
      angle = time *_f 128.0

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = bool:not isPressed(GLFW_KEY_ESC)
      ++frameNum
    end

    endTime := double:toFloat glfwGetTime()
  end}
end

//------------------------------------------------------------------------------

type Field3D
  int sideLength
  float* array
end

template Field3D:checkRange component
  assert (#component >= 0)
  assert (#component < this.sideLength)
end

func int Field3D:index(Field3D* this, int x, int y, int z)
  Field3D:checkRange x
  Field3D:checkRange y
  Field3D:checkRange z

  return (x + z * this.sideLength + y * this.sideLength * this.sideLength)
end

func float Field3D:get(Field3D* this, int x, int y, int z)
  index := Field3D:index(this, x, y, z)

  array := this.array
  return load(ptradd(array, index))
end

func void Field3D:set(Field3D* this, int x, int y, int z, float value)
  index := Field3D:index(this, x, y, z)
  a := this.array
  store ptradd(a, index) value
end

template Field3D:foreach field x y z value code...
  for #x 0 #field.sideLength
    for #y 0 #field.sideLength
      for #z 0 #field.sideLength
        #value := Field3D:get(#field, #x, #y, #z)
        #code
      end
    end
  end
end

func void Field3D:clear(Field3D* this)
  array := this.array
  sideLength := this.sideLength

  for i 0 (sideLength ** 3)
    store ptradd(array, i) 0.0
  end
end

func void Field3D:init(Field3D* this, int sideLength)
  setField this sideLength sideLength
  setField this array malloc(float, sideLength * sideLength * sideLength)
  Field3D:clear this
end

func void Field3D:show(Field3D* this)
  o := -0.5 *_f int:toFloat this.sideLength

  saveTransforms
    glTranslatef o o o
    rendergl GL_POINTS
      Field3D:foreach this x y z v
        r := float:mix v 0.0 1.0
        g := float:mix v 0.0 0.25
        b := float:mix v 0.0 0.0

        glColor3f r g b
        glVertex3i x y z
      end
    end
  end
end

struct Metaballs
  int count
  float* xs
  float* ys
  float* zs
  float* xvels
  float* yvels
  float* zvels
  float* strengths
end

template Metaballs:foreach ballnum balls code...
  for #ballnum 0 #balls.count
    #code
  end
end

func void Metaballs:init(Metaballs* this, int count)
  template tempAndMemberArray name
    #name := malloc float count
    this.#name = #name
  end

  this.count = count

  tempAndMemberArray xs
  tempAndMemberArray ys
  tempAndMemberArray zs
  tempAndMemberArray xvels
  tempAndMemberArray yvels
  tempAndMemberArray zvels
  tempAndMemberArray strengths

  max := 20.0
  offet := -10.0

  Metaballs:foreach ballnum this
    xs[ballnum] = max *_f float:random() +_f offet
    ys[ballnum] = max *_f float:random() +_f offet
    zs[ballnum] = max *_f float:random() +_f offet
    xvels[ballnum] = float:neg xs[ballnum] /_f 4.0
    yvels[ballnum] = float:neg ys[ballnum] /_f 4.0
    zvels[ballnum] = float:neg zs[ballnum] /_f 4.0
    strengths[ballnum] = 1.0
  end
end

func void Metaballs:update(Metaballs* this, float time)
  xs := this.xs
  ys := this.ys
  zs := this.zs
  xvels := this.xvels
  yvels := this.yvels
  zvels := this.zvels

  t := time /_f 1.0

  minpos := -0.5 *_f sideLengthf
  maxpos := 0.5 *_f sideLengthf

  Metaballs:foreach ballnum this
    xs[ballnum] = xs[ballnum] +_f t *_f xvels[ballnum]
    ys[ballnum] = ys[ballnum] +_f t *_f yvels[ballnum]
    zs[ballnum] = zs[ballnum] +_f t *_f zvels[ballnum]

    acc := 1.0 /_f 10.0 *_f float:random()

    if2 (xs[ballnum] <_f minpos) then
      xvels[ballnum] = xvels[ballnum] +_f acc
    elseif (xs[ballnum] >_f maxpos)
      xvels[ballnum] = xvels[ballnum] -_f acc
    end
    if2 (ys[ballnum] <_f minpos) then
      yvels[ballnum] = yvels[ballnum] +_f acc
    elseif (ys[ballnum] >_f maxpos)
      yvels[ballnum] = yvels[ballnum] -_f acc
    end
    if2 (zs[ballnum] <_f minpos) then
      zvels[ballnum] = zvels[ballnum] +_f acc
    elseif (zs[ballnum] >_f maxpos)
      zvels[ballnum] = zvels[ballnum] -_f acc
    end

    maxVel := 10.0
    minVel := -10.0

    xvels[ballnum] = float:clamp(minVel, maxVel, xvels[ballnum])
    yvels[ballnum] = float:clamp(minVel, maxVel, yvels[ballnum])
    zvels[ballnum] = float:clamp(minVel, maxVel, zvels[ballnum])
  end
end

func void Metaballs:print(Metaballs* this)
  printInt this.count
  printlnString " metaballs"

  xs := this.xs
  ys := this.ys
  zs := this.zs
  strengths := this.strengths

  Metaballs:foreach ballnum this
    printString "  x = "
    printFloat xs[ballnum]
    printString ", y = "
    printFloat ys[ballnum]
    printString ", z = "
    printFloat zs[ballnum]
    printString ", strength = "
    printFloat strengths[ballnum]
    println()
  end
end

func void Metaballs:applyToField(Metaballs* this, Field3D* field)
  xs := this.xs
  ys := this.ys
  zs := this.zs

  Field3D:clear(field)

  mballSize := 4.0

  offset := -0.5 *_f sideLengthf

  Field3D:foreach field x y z value
    newValue := value
    Metaballs:foreach ballnum this
      xd := int:toFloat x -_f xs[ballnum] +_f offset
      yd := int:toFloat y -_f ys[ballnum] +_f offset
      zd := int:toFloat z -_f zs[ballnum] +_f offset
      d := sqrtf(xd *_f xd +_f yd *_f yd +_f zd *_f zd)

      newValue = newValue +_f float:max(0.0, 1.0 -_f d /_f mballSize)
    end
    Field3D:set(field, x, y, z, newValue)
  end
end

func void Metaballs:show(Metaballs* this)
  xs := this.xs
  ys := this.ys
  zs := this.zs
  strengths := this.strengths

  rendergl GL_POINTS
    glColor3f 1.0 0.0 0.0
    Metaballs:foreach ballnum this
      glVertex3f xs[ballnum] ys[ballnum] zs[ballnum]
    end
  end
end

// TODO: metaballs reintun
// http://en.wikipedia.org/wiki/Marching_cubes

defineArrayType int
defineArrayType float

struct Point
  float x
  float y
  float z
end

func void Point:init(Point* this, float x, float y, float z)
  this.x = x
  this.y = y
  this.z = z
end

func void Point:print(Point* this)
  printString "Point ("
  printFloat this.x
  printString ", "
  printFloat this.y
  printString ", "
  printFloat this.z
  printString ")"
end

// struct Metaball
//   Point pos
//   float strength
// end

//------------------------------------------------------------------------------

func void resizeWindow(int width, int height)
  windowWidth = width
  windowHeight = height
  glfwSetWindowSize windowWidth windowHeight
end

// macro executeOnce
//   uniqueId alreadyRun "executeOnce"
//   ret ${
//   end}
// end

type degree float

///
/// A camera defined by longitude, latitude and distance
///
struct SpaceballCamera
  /// angle between z-axis and rotation around y-axis
  degree longitude

  /// angle between z-axis and rotation around x-axis
  degree latitude

  degree distance
end

func void SpaceballCamera:init(SpaceballCamera* this)
  this.latitude = 0.f
  this.longitude = 0.f
  this.distance = 1.f
end

func void SpaceballCamera:rotate(SpaceballCamera* this)
  glTranslatef 0. 0. float:neg(this.distance)
  glRotatef this.latitude 1. 0. 0.
  glRotatef this.longitude 0. 1. 0.
end

// memberFunc void SpaceballCamera.rotate()
// ...
// end

func void SpaceballCamera:applyToGL(SpaceballCamera* this)
  glMatrixMode GL_MODELVIEW
  glLoadIdentity()
  SpaceballCamera:rotate(this)
end

func float posmod(float x, float divisor)
  mod := fmodf(x, divisor)

  if2 (mod <_f 0.0) then
    mod = divisor -_f float:neg(mod)
  end

  ret mod
end

unittest:testCasesFor posmod
  posmod(0.0,2.0) ==_f 0.0
  posmod(1.0,2.0) ==_f 1.0
  posmod(2.0,2.0) ==_f 0.0

  posmod(-1.0,3.0) ==_f 2.0
  posmod(-2.0,3.0) ==_f 1.0

  posmod(23.0, 4.0) ==_f 3.0
  posmod(-61.0, 3.0) ==_f 2.0
end

func void SpaceballCamera:restrictParams(SpaceballCamera* this)
  this.longitude = posmod this.longitude 360.0f
  this.latitude = float:clamp float:neg(90.0) 90.0 this.latitude
  this.distance = float:max 0.0 this.distance
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y

  lastMouseX = x
  lastMouseY = y
end

func void onWindowResize(int newWidth, int newHeight)
  printString "Window was resized to "
  printInt newWidth
  printString "x"
  printInt newHeight
  println()

  windowWidth = newWidth
  windowHeight = newHeight
  glViewport 0 0 windowWidth windowHeight
end

func void free(void* ptr)

template delete ptr
  free (cast void* #ptr)
end

func int main()
  init()
  // resizeWindow 1440 900

  glfwSetMousePosCallback (cast void* &onMouseMove)
  glfwSetWindowSizeCallback (cast void* &onWindowResize)

  glMatrixMode( GL_PROJECTION )
  glLoadIdentity()
  aspect := int:toDouble(windowWidth) /_d int:toDouble(windowHeight)
  gluPerspective( 90.0d, aspect, 1.0d, 200.0d )

  cam := new SpaceballCamera
  cam.distance = 100.0f

  field := new Field3D (float:toInt sideLengthf)
  mballs := new Metaballs 50

  // Metaballs:print mballs

  mainloop
    glClearColor(0.0, 0.0, 0.0, 1.0)
    glClear int:or(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT)

    if2 (abs(mouseXDelta) > abs(mouseYDelta)) then
      mouseYDelta = 0
    else
      mouseXDelta = 0
    end
    cam.longitude = cam.longitude +_f int:toFloat(mouseXDelta)
    cam.latitude = cam.latitude +_f int:toFloat(mouseYDelta)
    SpaceballCamera:restrictParams cam
    mouseXDelta = 0
    mouseYDelta = 0

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    SpaceballCamera:applyToGL cam

    if2 (time -_f startTime >_f 1.0) then
      Metaballs:update mballs frameDuration
      Metaballs:applyToField mballs field
    end

    drawCoordSys 8.0

    saveTransforms
      sideLength := field.sideLength
      scale := 100.0 /_f int:toFloat(sideLength)
      glScalef scale scale scale

      // offset := int:toFloat(sideLength) /_f -2.0
      // glTranslatef offset offset offset

      Field3D:show field
      Metaballs:show mballs
    end
  end

  drawPausedOverlay()
  glfwSwapBuffers()
  glfwPollEvents()

  println()
  printFloat (endTime -_f startTime)
  printString "s, "
  printInt frameNum
  printString " frames, "
  printFloat (int:toFloat frameNum /_f (endTime -_f startTime))
  printlnString " fps"

  delete field
  delete mballs

  ret 0
end

testf
  runMain()
end

