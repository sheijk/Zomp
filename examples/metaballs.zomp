/**

!verify off

* A simple .obj loader

!load libglfw.dylib
!load libGLEW.dylib
!syntax indent
*/

include "opengl20.zomp"
include "glfw.zomp"
include "libs/glutils.zomp"

include "libs/libcee.zomp"

//------------------------------------------------------------------------------

// from libstdc
func int rand()

func int random (int max)
  ret int:srem(rand(), max)
end

func float float:random()
  randomInt := random(4097)
  return (int:toFloat(randomInt) /_f 4096.0)
end

func float float:srandom()
  return (float:random() *_f 2.0 -_f 1.0)
end


func float powf(float base, float exp)
func double pow(double base, double exp)

func int int:pow(int base, int exp)
  v := base

  remMults := exp

  while (remMults > 1)
    v = v * base
    remMults = remMults - 1
  end

  ret v
end

template op** base exp
  int:pow(#base, #exp)
end

//------------------------------------------------------------------------------

var int windowWidth 400
var int windowHeight 300
var bool initCalled false

func void init()
  if2 bool:not(initCalled) then
    glfwInit()
    glfwOpenWindow windowWidth windowHeight 8 8 8 8 16 0 GLFW_WINDOW
    glewInit()
    times 2 glfwPollEvents()

    printString "Initialized"
    println()

    initCalled = true
  else
    printString "Already initialized"
    println()
  end
end

var float angle 0.0

// avoid writing it over and over, part of utils lib
macro mainloop body...
  ret ${
    time := 0.0
    running := true
    while running
      time = double:toFloat glfwGetTime()
      angle = time *_f 128.0

      #body

      glfwSwapBuffers()
      glfwPollEvents()
      running = bool:not isPressed(GLFW_KEY_ESC)
    end
  end}
end

//------------------------------------------------------------------------------

type Field3D
  int sideLength
  float* array
end

template Field3D:checkRange component
  assert (#component >= 0)
  assert (#component < this.sideLength)
end

func int Field3D:index(Field3D* this, int x, int y, int z)
  Field3D:checkRange x
  Field3D:checkRange y
  Field3D:checkRange z

  return (x + z * this.sideLength + y * this.sideLength * this.sideLength)
end

func float Field3D:get(Field3D* this, int x, int y, int z)
  index := Field3D:index(this, x, y, z)

  array := this.array
  return load(ptradd(array, index))
end

func void Field3D:set(Field3D* this, int x, int y, int z, float value)
  index := Field3D:index(this, x, y, z)
  a := this.array
  store ptradd(a, index) value
end

func void Field3D:clear(Field3D* this)
  array := this.array
  sideLength := this.sideLength

  for i 0 (sideLength ** 3)
    store ptradd(array, i) 0.0
  end

  // for x 0 this.sideLength
  //   for y 0 this.sideLength
  //     for z 0 this.sideLength
  //       Field3D:set(this, x, y, z, int:toFloat(z) /_f int:toFloat(sideLength))
  //     end
  //   end
  // end
end

func void Field3D:init(Field3D* this, int sideLength)
  setField this sideLength sideLength
  setField this array malloc(float, sideLength * sideLength * sideLength)
  Field3D:clear this
end

func void Field3D:show(Field3D* this)
  sideLength := this.sideLength

  saveTransforms
    scale := 2.0 /_f int:toFloat(sideLength)
    glScalef scale scale scale

    offset := int:toFloat(sideLength) /_f -2.0
    glTranslatef offset offset offset

    rendergl GL_POINTS
      for x 0 sideLength
        for y 0 sideLength
          for z 0 sideLength
            v := Field3D:get(this, x,y,z)
            glColor3f v v 1.0
            glVertex3i x y z
          end
        end
      end
    end
  end
end

type Metaball
  float x
  float y
  float z

  float size
end

// TODO: metaballs reintun
// http://en.wikipedia.org/wiki/Marching_cubes

// macro struct name members...
//   code := simpleAst("type")
//   addChild code name
// 
//   forEachAstChild member members
//     addChild code member
//   end
// 
//   ret code
// end

//------------------------------------------------------------------------------
// Quick and dirty arrays

macro defineArrayType type
  arrayTypeName := "Array_" ++ type.id
  initFuncName := "Array_" ++ type.id ++ ":init"

  // initDecl := ${func void NAME(#arrayTypeName* this, int size)}
  initDecl := simpleAst("opcall")
  addChild initDecl simpleAst(initFuncName)
  addChild initDecl ${#arrayTypeName* this}
  addChild initDecl ${int size}

  code := ${
    struct #arrayTypeName
      int length
      #type* elements
    end

    // func void #initFuncName(#arrayTypeName* this, int length)
    func void #initDecl
      this.length = size
      this.elements = malloc(#type, size)
    end
  end}

  ret code
  // println()
  // printHLine '-' 80
  // ast:print code 0
  // printHLine '-' 80
  //
  // ret ${}
end

defineArrayType int
defineArrayType float

template aget array index
  load (ptradd getField(#array, elements) #index)
end

template aset array index value
  store (ptradd getField(#array, elements) #index) #value
end

macro array:setAll array value
  uniqueId size "lala"
  uniqueId i "lala"

  ret ${
    size := getField(#array, length)
    for #i 0 size
      aset #array #i #value
    end
  end}
end

struct Point
  float x
  float y
  float z
end

func void Point:init(Point* this, float x, float y, float z)
  this.x = x
  this.y = y
  this.z = z
end

func void Point:print(Point* this)
  printString "Point ("
  printFloat this.x
  printString ", "
  printFloat this.y
  printString ", "
  printFloat this.z
  printString ")"
end

// defineArrayType Point

// testf
//   points := new Array_Point 10
//   var Point p
//   array:setAll points p
// end

// func void test()
//   points := malloc Point 10
//   var Point p
//   store points p
// end

// func void test()
//   var Point p
//   setField p x 1.0
//   // p.x = 1.0
//   // p.y = 2.0
// 
//   // q := p
//   // p.x = 8.0
// 
//   // Point:print p
//   // println()
//   // Point:print q
//   // println()
// end

// func void test()
//   arr := new(Array_int, 10)
// 
//   array:setAll arr 17
// 
//   for i 0 10
//     printlnInt aget(arr, i)
//   end
// end

//------------------------------------------------------------------------------

func void resizeWindow(int width, int height)
  windowWidth = width
  windowHeight = height
  glfwSetWindowSize windowWidth windowHeight
  glViewport 0 0 windowWidth windowHeight
end

// macro executeOnce
//   uniqueId alreadyRun "executeOnce"
//   ret ${
//   end}
// end

type degree float

///
/// A camera defined by longitude, latitude and distance
///
struct SpaceballCamera
  /// angle between z-axis and rotation around y-axis
  degree longitude

  /// angle between z-axis and rotation around x-axis
  degree latitude

  degree distance
end

func void SpaceballCamera:init(SpaceballCamera* this)
  this.latitude = 0.f
  this.longitude = 0.f
  this.distance = 1.f
end

func void SpaceballCamera:rotate(SpaceballCamera* this)
  glTranslatef 0. 0. float:neg(this.distance)
  glRotatef this.latitude 1. 0. 0.
  glRotatef this.longitude 0. 1. 0.
end

// memberFunc void SpaceballCamera.rotate()
// ...
// end

func void SpaceballCamera:applyToGL(SpaceballCamera* this)
  glMatrixMode GL_MODELVIEW
  glLoadIdentity()
  SpaceballCamera:rotate(this)
end

func float posmod(float x, float divisor)
  mod := fmodf(x, divisor)

  if2 (mod <_f 0.0) then
    mod = divisor -_f float:neg(mod)
  end

  ret mod
end

macro unittest:assertAll checks
  var ast* code ${}
  forEachAstChild check checks
    addChild code ${unittest:assert #check}
  end
  ret code
end

unittest:testCasesFor posmod
  posmod(0.0,2.0) ==_f 0.0
  posmod(1.0,2.0) ==_f 1.0
  posmod(2.0,2.0) ==_f 0.0

  posmod(-1.0,3.0) ==_f 2.0
  posmod(-2.0,3.0) ==_f 1.0

  posmod(23.0, 4.0) ==_f 3.0
  posmod(-61.0, 3.0) ==_f 2.0
end

func void SpaceballCamera:restrictParams(SpaceballCamera* this)
  this.longitude = posmod this.longitude 360.0f
  this.latitude = float:clamp float:neg(90.0) 90.0 this.latitude
  this.distance = float:max 0.0 this.distance
end

var int lastMouseX 0
var int lastMouseY 0
var int mouseXDelta 0
var int mouseYDelta 0

func void onMouseMove(int x, int y)
  mouseXDelta = lastMouseX - x
  mouseYDelta = lastMouseY - y
  
  lastMouseX = x
  lastMouseY = y
end

func int main()
  init()
  resizeWindow 1440 900

  glfwSetMousePosCallback (cast void* &onMouseMove)

  glMatrixMode( GL_PROJECTION )
  glLoadIdentity()
  aspect := int:toDouble(windowWidth) /_d int:toDouble(windowHeight)
  gluPerspective( 90.0d, aspect, 1.0d, 100.0d )

  cam := new SpaceballCamera
  cam.distance = 4.0f

  field := new Field3D 10

  mainloop
    glClearColor(0.0, 0.0, 0.0, 1.0)
    glClear int:or(GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT)

    if2 (abs(mouseXDelta) > abs(mouseYDelta)) then
      mouseYDelta = 0
    else
      mouseXDelta = 0
    end
    cam.longitude = cam.longitude +_f int:toFloat(mouseXDelta)
    cam.latitude = cam.latitude +_f int:toFloat(mouseYDelta)
    SpaceballCamera:restrictParams cam
    mouseXDelta = 0
    mouseYDelta = 0

    glMatrixMode GL_MODELVIEW
    glLoadIdentity()
    SpaceballCamera:applyToGL cam
    // glTranslatef( 0., 2., float:neg(4.) )
    // glRotatef( angle, 0., 1., 0. )

    drawCoordSys 8.0

    Field3D:show field
  end

  drawPausedOverlay()
  glfwSwapBuffers()
  glfwPollEvents()

  printlnString "cu"

  ret 0
end


