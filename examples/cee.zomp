/**
 * Experimental test bed of the cee language profile
 *
!verify off
 */
!syntax indent

//------------------------------------------------------------------------------
/// base lib

template macro:failUnless cond
  unless #{cond}
    ret ${error expression is false #{cond}}
  end
end

macro uniqueIds purpose ids...
  var ast* code ${seq}

  forEachAstChild child ids
    addChild code ${uniqueIds #child #purpose}
  end

  ret code
end

/// if statement
///
/// Usage example:
/// 
/// if a > 10 then
///   print "It's bigger!"
/// else if a < 5 then
///   print "It's smaller!"
/// else
///   print "Neither to big nor to small. Purrfect"
/// end
macro if2 cond then onTrue remArgs...
  println()

  macro:failUnless cstring:equal(getField(then, id), "then")

  uniqueId endLabel "if_end"

  var astp code ${seq}

  addChild code ${when #cond
    #onTrue
    branch #endLabel
  end}

  var int currentArg 0
  const int argCount getField(remArgs, childCount)

  while currentArg+3 <= argCount
    var astp econd ast:child(remArgs, currentArg+1)
    var astp eexpr ast:child(remArgs, currentArg+2)

    addChild code ${seq
      when #econd
        #eexpr
        branch #endLabel
      end
    end}

    currentArg = currentArg + 3
  end

  when currentArg+1 < argCount
    var astp elseCode ast:child(remArgs, currentArg+1)

    addChild code elseCode
  end

  addChild code ${label #endLabel}

  ret code
end

func bool isBound(char* name)

type symbolKind int
const symbolKind ZOMP_SYMBOL_UNDEFINED 0
const symbolKind ZOMP_SYMBOL_VAR 1
const symbolKind ZOMP_SYMBOL_FUNC 2
const symbolKind ZOMP_SYMBOL_MACRO 3
const symbolKind ZOMP_SYMBOL_TYPEDEF 4
const symbolKind ZOMP_SYMBOL_LABEL 5

func char* symbolKind:toString(symbolKind kind)
  if2 kind == ZOMP_SYMBOL_UNDEFINED then
    ret "Undefined"
  elseif kind == ZOMP_SYMBOL_VAR
    ret "Variable"
  elseif kind == ZOMP_SYMBOL_FUNC
    ret "Function"
  elseif kind == ZOMP_SYMBOL_MACRO
    ret "Macro"      
  elseif kind == ZOMP_SYMBOL_TYPEDEF
    ret "Type"
  elseif kind == ZOMP_SYMBOL_LABEL
    ret "Label"
  end
              
  ret "internal error"
end
            
func symbolKind zompLookup(char* name)

// template op== l r
//   cstring:equal #l #r
// end

func bool dummy(bool x)
  printString "Returning "
  printBool x
  println()

  ret x
end

macro op|| l r
  uniqueId result "||"
  
  ret ${
    #result := false
    if2 #l then
      #result = true
    elseif #r
      #result = true
    end
    #result
  end}
end

macro op&& l r
  uniqueId result "&&"

  ret ${
    #result := false
    if2 #l then
      #result = #r
    #result
  end}
end

// func void test()
//   printlnString "(&&) Expect: f"
//   dummy(false) && dummy(true)
// 
//   printlnString "(&&) Expect: t,f"
//   dummy(true) && dummy(false)
// 
//   printlnString "(||) Expect f,t"
//   dummy(false) || dummy(true)
// 
//   printlnString "(||) Expect t"
//   dummy(true) || dummy(false)
// 
//   ret void
// end

///TODO: add support to call methods
macro op. record component
  if2 getField(component, childCount) == 0 then
    ret ${getField(#record, #component)}
  end
  // else
  ret ${error "function calls with dot syntax not supported yet" in #component}
end

macro op= l r
  if2 ast:matchesShape(l, ${_._}) then
    var ast* component ast:child(l, 0)
    var ast* field ast:child(l, 1)
    ret ${setField #component #field #r}
  else
    ret ${assign #l #r}
  end

  ret ${internal error}
end

template op:= name value
  var2 #name #value
end

/// Allocate storage and initialize variable
/// `new Foo a b c' does the same as `var Foo* this (malloc Foo); Foo:init(this,a,b,c); this'
macro new type args...
  uniqueId name "new"

  var ast* initCall astFromString(cstring:concat(getField(type, id), ":init"))
  addChild initCall astFromString(name)
  forEachAstChild arg args
    addChild initCall arg
  end

  var ast* code ${seq}
  addChild code ${var (ptr #type) #name (malloc #type)}
  addChild code initCall
  addChild code astFromString(name)

  ret code
end

template return v
  ret #v
end

template op; expr1 expr2
  #expr1
  #expr2
end

//------------------------------------------------------------------------------
/// Standard library

template op++ lstring rstring 
  cstrings:append #lstring #rstring
end


type Complex
  float real
  float img
end

func void Complex:print(Complex* c)
  printString "("
  printFloat c.real
  printString ", "
  printFloat c.img
  printString "i)"
end

func void Complex:init(Complex* c, float real, float img)
  c.real = real
  c.img = img
end

// macro v2 args...
//   printlnString "Given AST:"
//   ast:print args 2
// 
//   ret ${}
// end

include "libs/stdio.zomp"

// macro defineArrayType type
//   arrayTypeName := "Array_" ++ type.id
// 
//   code := ${
//     type #arrayTypeName
//       int length
//       #type* elements
//     end
//   end}
// 
//   ast:print code 0
// 
//   ret ${}
// end
// 
// defineArrayType int

// func char* readFile(char* fileName)
//   file := fopen(fileName, "r")
// 
//   if2 file ==_ptr nullptr(int) then
//     return nullptr(char)
//   end
// 
//   buffer := ""
//   
// end


// macro alias newName toName
//   if2 isBound(getField(newName, id)) then
//     printString "Redefining "
//     printString newName.id
//     printString " => "
//     printString toName.id
//     println()
//     
//     ret ${}
//   else
//     ret ${error #toName is not defined}
//   end
// end
  
func void test()
  var int x 10

  template printDefinitionInfo name
    printString #name
    printString " defined: "
    printBool isBound(#name)
  end

  printDefinitionInfo "gipsdochganich"
  printDefinitionInfo "x"

  printInt zompLookup("x")
end



// func void test()
//   std:base:localVar x 20
//   printInt x
// end
// 
// func void test()
//   foo := nullptr(int)
// end

//------------------------------------------------------------------------------
/// program

/// operator ; will need to get a different priority
// macro cee:for loopExpr code
//   ast:print loopExpr 0
//   ${printlnString "no loops for you, bitch"}
// end

// /**
//  * foo bar
//  */
// func void test()
//   // cee:for(int i = 0; i < 10; ++i)
//   //   printString "i = "
//   //   printlnInt i
//   // end
// 
//   c := new(Complex, 1.0, 10.0)
//   Complex:print c
//   println()
//   
//   
// end

func int main()
  
  ret 0
end


