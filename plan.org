#+SEQ_TODO: TODO DONE

* To be sorted

** TODO [#A] motivation: mixins
** TODO [#A] motivation: automatische printer
   type Point:
     float x, y

   => print Methode mitgenerieren
   (analog fuer andere methoden)
    
** TODO [#A] extended var
   - should be able to create multiple variables like 'var int x, y = 10, z'
   - should return the variable's value so it can be better used inside control structures
     while (var int x = foo())
       println(x)

** TODO [#A] motivation: powerful asserts
   assert x < 10
   => Fehlermeldung mit Wert von x

** TODO allow variable definitions within expressions?
   while (var int x = foo()) > 10
     print(x)

** TODO [#A] array/list comprehensions
** TODO [#A] (siehe cyclone, ada)
** TODO [#A] pointer + vars mit scope level parametrisieren, dann bei ptr = &foo nur erlauben wenn scopelevel von ptr <= scopelevel(foo)
** TODO [#A] finally
   begin
     code
   finally
     code
   end

** TODO [#A] tuples: var (int, float) x => x.0 : int, x.1 : float
** TODO [#A] clisp artiges destructuring
** TODO [#A] error when redefining symbol with different number of arguments
** TODO konfigurierbare base language

macroExpand :: [AST], Bindings -> [Instruction]

enum Symbol:
  Instruction :AstPattern
  Variable :Type
  Function :Args * Type
  Macro :MacroFunc

type Bindings:
  Id => Symbol

Gibt am Ende AST zurueck der nur noch aus Instructions besteht
Kann dann auch zum kompilieren von Shadern benutzt werden

** TODO ruby syntax, fortress syntax fuer nested function calls
** TODO gencode in zomp umstellen
   (zeiger durch abstrakten typ darstellen)
   http://www.linux-nantes.org/~fmonnier/OCaml/ocaml-wrapping-c.php#ref_ptr

** TODO [#A] `undefineAll()' => alle namen in den bindings werden undefined. nuetzlich um config dateien als zomp source zu parsen und mit makros zu interpretieren
** TODO [#A] `undefine name' => name kann nicht mehr verwendet werden
** TODO [#A] runtime checks generieren
** TODO [#A] if (*addF)(3, 4) > 10
   => jux (preop* addF) (op> (op, 3 4) 10)
   Sollte aber jux if (op> (opcall (preop* addF) 3 4) 10) sein

   Regeln fuer jux/call aendern? Doch jux hoechste Prioritaet geben und Klammern verwenden?
   Oder {} fuer Prioritaet?

   Oder einfach addF(3,4) in einen function call umwandeln wenn addF ein function pointer ist

*** Zu Bedenken:
   
   let x + y = ...
   if cond(arg) then ...

   sin x + cos y
   
*** Evtl
    if: expr* then: expr*

    visitTree: tree onLeaf: leafF onNode: nodeF

    for: i in: 10 .. 20 do: print i; println()
    
** TODO [#A] foo(bar baz) auch als call parsen? foo {bar baz} dann um jux zu bekommen
** TODO [#A] rename modules of indent based parser and seperate them from the unit tests
** TODO [#A] printString "foo\n" ignored newline on both sexpr and indent syntax
** TODO [#A] stack basiertes system fuer settings/bindings im macro expander
** TODO [#A] haskell's Data.Map.lookup function: nice way to adapt the failure-handling behaviour to the calling code's policy
** TODO [#A] speichermanagement fixen!!! (ast.id wird manchmal geloescht.. im ocaml ffi?)
** TODO [#A] keine fehler ausgabe im prelude?
** TODO [#A] define operator funcs in indent syntax (func l == r ...)
** TODO [#A] unit tests still use identifiers with dots (line 'int.add') - change this to colon (int:add)
** TODO [#A] toplevel: run expr through macro expansion. if it consists only of toplevel exprs evaluate, otherwise run immediate
** TODO [#A] char handling in macro expansion fucked up?
macro Cstring:forEachChar string char onChar
  uniqueId ptr "forEachChar"

  mret ${
    var char* ptr line
    while bool:not( char:equal(load(ptr), '\0') )
      var char chr load(ptr)
      printChar chr
      ptr = ptradd(ptr, 1)
    end
  end}
end macro

In macro expansion the \0 will be replaced by an !
   
** TODO [#A] sometimes macros can't be parsed at the toplevel (might be related to the macro expansion string fuckup)
** TODO [#A] todos nach features ordnen + mit tags versehen
** TODO [#A] unique/linear types
   - nach erzeugung linear, bis das erste mal eine zuweisung passiert
   - mit pattern matching bzw. on-the-fly typanpassung?
   - funktionen beeinflussen linear eigenschaft?
     
** TODO [#A] prio fuer call(a,b,c) analog zu operator precedence loesen? (ala multExpr, addExpr)
** TODO [#A] reduce to llvm bindings and macros (mixed ocaml/zomp macro system for now)
** TODO [#A] subseq "foo" -2 => "oo", subseq "foo" 2 => "fo" etc.
** TODO [#A] proper support for compile time variables
** TODO [#A] simplify all base language forms so only one syntax is allowed and support variants using macros
** TODO [#A] move all builtin forms into zomp namespace (e.g. zmp:base:var etc.)
** TODO [#A] disallow identifiers which only differ in capitalization (unless for type/function, e.g. if they denote different kinds of elements?)
** TODO [#A] bugs wenn innerhalb eines makros andere makros getriggert werden?
** TODO [#A] macro expansion failures in compiler but not toplevel (comments.zomp), getting weird characters
   scheint in der stdlib zu sein
   koennte daran liegen dass redefinitionen im compiler anders behandelt werden
** TODO [#A] int to char conversion
** TODO [#A]     store ptradd(buffer, 99) '\0' => llvm failure
** TODO [#A] ast:print( ${foo bar}, 0 ) => fails
** TODO [#A]     store ptradd(indices, 4 * #num + 0) #a => fails to parse
** TODO [#A]   store ptradd(vertArray, 3*num + 0) x => error (see below)
** TODO [#A] give additional info if a name resolves to something of the wrong type (expected type but found function etc.)
** TODO [#A] evaluating multipe expressions will ignore all but the last (iexpr) (sometimes)
** TODO [#A] (include ..) should support iexpr syntax
** TODO [#A] better error message on invalid typedef
** TODO [#A] empty lines containing spaces let the parser fail

* Use Cases

** Indent based syntax [1/3]
   - [ ] support for comments
   - [ ] code cleanup
         correctly named modules, remove junk etc.,
         seperate unit tests
   - [X] support in toplevel and compiler

** .obj Loader [0/2]
   
   - [ ] parsing strings (regexp?)
   - [ ] reading from a file

** shader system [1/2]
   
   Turn a shader description into a class:
   
   shader Phong
     uniform float exponent

     output
       vec4 gl_FragColor
       float gl_Depth

     vertex(vec3 pos, vec3 normal)
       out.pos = ftransform()

     fragment(vec3 normal) => gl_FragColor, gl_Depth
       gl_FragColor = ...
   end shader Phong

class Phong extends Shader
{
	float exponent

	void vertex(Vertex v, out bla)

	void Pass0()
	{
		state.blendenble = true
		state.vs = vertex;
		if ()
	}

float bla[32];
Texture t;
Sampler1D blaSampler = {mode = Sampler.Mode.WRAP, filter = POINT, texure = t}

void Simulate
void Render(float t)

   - [X] opengl bindings
   - [ ] function pointers
   - [ ] classes

** persistent camera in toplevel [0/2]

   It should be possible to store the camera pos after main() returned
   
   - [ ] global pointers
   - [ ] module level init code (run on load)
         
** overloaded functions
   It should be possible to supply support for overloaded functions as macros

   - [ ] get the type of variables
         (possibly trigger macro expansion of an ast from within macros)
   - [ ] compile time global variables

* Tasks											:zomp:

** BUGS

*** TODO [#B] check where `DefineVariable for void vars comes from
*** DONE [#A] "" is not parsed as a string
    CLOSED: [2008-01-11 Fri 01:28]

*** DONE [#A] Simple loops results in crash in REPL
    CLOSED: [2008-01-11 Fri 01:40]
    Cannot be reproduced anymore

(func int main () (
  (label start)
  (branch start)
  (ret 0)
  ))

*** DONE [#B] Using OpenGL results in crashes
    CLOSED: [2007-12-31 Mon 03:25]

*** DONE [#A] gltest.cbe.c unter windows/linux testen
    CLOSED: [2007-12-31 Mon 03:26]

*** TODO [#B] locate cause of excessivly slow LLVM IR verification

*** TODO [#C] default value of global double vars is parsed incorrecly (1.0 is accepted but 1.0d not) :bug:

*** DONE [#A] emit warning on missing ret		:bug:
    CLOSED: [2007-12-04 Tue 02:35] 

*** DONE [#A] BUG: (ret (load (ptradd (getField parent childs) index))) :bug:
in function returning (ptr ast) is not accepted 
   CLOSED: [2007-12-05 Wed 20:35]

*** TODO [#C] BUG: sometimes llvm source is printed on compiler errors unnecessarily :bug:

*** DONE fix toplevel "!" / abort expr			:bug:
    CLOSED: [2007-11-04 Sun 19:51]

** Design issues
*** DONE [#A] change ast representation? need a way to distinguish func and (func) :zomp:
    CLOSED: [2008-02-16 Sat 18:36]
    (foo bar) => (jux foo bar)
    Will be part of new parser

*** TODO [#B] support for const, const T* etc.?

*** TODO [#B] Turn more things into expressions
**** TODO if is not an expression
**** DONE Allow labels to be local to a scope? Turn if/for/.. into expressions this way?
     CLOSED: [2008-02-23 Sat 03:48]      
     
     Local labels are not needed to turn if/for/.. into expressions
     
*** TODO [#C] place all external c functions in 'c' namespace?
   Export only functions defined in c namespace?
   Rename all other functions(?) like zomp_${name}

** Fix language quirks

*** TODO [#B] ast von cstring auf string umstellen

*** DONE [#A] linking multiple generated .ll files does not work :bug:
    CLOSED: [2007-12-20 Thu 02:53]
(wrong linking attributes for function declarations?)
more likely: stdlib.zomp are linked into stdlib.bc _and_ main.bc

*** DONE check return type in functions!		:improve:
    CLOSED: [2007-12-06 Thu 02:01]
    
*** DONE [#A] macros need a way to signal errors
    CLOSED: [2008-03-15 Sat 14:45]
    Repeat (compiler:error ...)?

*** TODO [#B] can't send antiquote to macro
  (xmacro twice arg (ret `((var int i 0) #arg (assign i 1) #arg)))
  (twice (printInt #i))

*** TODO [#B] int representations: 0xff 0b1001 etc.	:features:
    
*** TODO [#B] nested quotes and antiquotes don't work :bug:
    
*** DONE Allow getting pointer to variables
    
*** DONE Fix record support: allow writing to record fields
    CLOSED: [2007-10-06 Sat 21:36]
    
*** DONE Correctly parse ((ptr int) foo) in arguments/types
    CLOSED: [2007-10-08 Mon 01:45]
    
*** DONE Add support for characters
    CLOSED: [2007-10-09 Tue 23:51]
    
*** DONE Add support for arrays
    CLOSED: [2007-10-11 Thu 00:29]
    
*** DONE Disallow strings as constants in simpleform
    CLOSED: [2007-10-16 Tue 19:04]
    Let the expander turn them into global strings
    
*** DONE Use bindings / semantics checking in expander.ml
    CLOSED: [2007-10-16 Tue 19:04]

*** TODO [#B] Support more data types

**** DONE double
     CLOSED: [2007-11-26 Mon 01:26] 

**** TODO unsigned ints

**** TODO int8/16/32

**** TODO c.int, c.short etc.

*** TODO [#B] Add instruction to free memory

*** TODO [#B] Support global pointers

*** TODO [#C] Methods are added to bindings twice
    func returns bindings where the functions is added twice

*** DONE [#A] Variadic macros
    CLOSED: [2007-11-04 Sun 19:52]
     (macro template name (rest args)
      (var (ptr ast) tree `(macro #name))
      (foreach arg in args
        (addChild tree arg) )
      (ret tree) )
    
    (template uniqueLabel name purpose (
      (var cstring #name (newUniqueNameFor #purpose)) ))

** Refactorings
   
*** TODO [#A] change all types to Capitalized case in stdlib
*** TODO [#B] Allow nested expressions in branch instruction
    
*** TODO [#C] Turn value type into polymorphic variant type
    
*** TODO [#B] zompc and sexprtoplevel should share evaluation code

*** TODO [#A] Change expander.ml: dispatching only done by the expression's id
    Then make all operations available as fake-macros (zmp:compiler:macroExpand etc.)
    
** Testing

*** TODO [#C] generate more realistic compiler performance tests
    (use macros and functions which are not defined just two lines ago)

*** TODO [#B] check return values of tests/*.zomp
    Rename files to foo.ret100.zomp, then check whether running foo returns 100

** Parser

*** TODO [#A] indent parser: support escaped linebreaks (\ at beginning/end of line)
*** TODO [#A] indent parser: skip comments
*** TODO [#A] indent parser: strings
*** TODO [#B] only allow one dot in ids (and none at a later point)
*** TODO [#B] iexprtest.ml: does worker in token use stringAcc at all?
*** TODO [#C] parse (a b c) into (op() a b c), {a b c} into (op{} a b c), (a) into (op() a), b into b?
*** TODO [#B] support "\"" in strings
*** TODO [#A] add += -= *= /= etc. operators
*** DONE [#A] parse logical ops &, |, &&, ||
    CLOSED: [2008-04-14 Mon 01:17]
*** TODO [#A] / should be left associative: a / b / c => (a / b) / c	   :bug:
*** TODO [#B] parser: keep track of line and char number and add this to error messages

** Compiler

*** TODO [#A] error on redefining vars
*** TODO [#A] error when local var is redefined
*** TODO [#A] no segfaults when redefining local variables
*** TODO [#A] allow uninitialized vars
*** TODO [#A] allow (var foo x) where the type of var is propagated
*** TODO [#B] warnings on unused variables
*** TODO [#B] compileperf.zomp  mit 16k funktionen profilen
*** TODO [#A] support abstract types (which may be only used through pointers)
*** TODO [#A] rename local macros
*** TODO [#A] constants for float nan, pos & neg infinity
*** TODO [#A] stringlit / op""

    macro stringlit string
      static var (ptr char) stringStorage string
      stringStorage

*** TODO [#B] llvm assertion error on record argument
*** TODO [#A] support toplevel/static expressions which will be moved from inside a function to the top level
*** TODO [#B] allow record with only 1 field
*** TODO [#A] convert char to int / float
*** TODO [#A] (var (ptr float) foo) => better error message instead of expr: /0/ :bug:
*** TODO [#A] support records as first class var types
    (allow them to be params, retvals, local vars, global vars)
*** TODO [#A] fix initialization of global vars
*** TODO [#A] support global pointers									   :bug:
*** TODO [#A] typechecking fails on (func nonvoid ... (if cond (ret a) (ret b)) ) :bug:
*** TODO [#A] support paths for include / import / etc.                 
*** TODO [#B] refactor: make all compiler functionality available from zomp expressions
*** TODO Indent-sensitive syntax

**** DONE [#B] iexpr does not ignore empty lines preceeding unindents
     CLOSED: [2008-01-14 Mon 17:24]

**** TODO [#B] iexpr does not fail correctly on "class Foo ... end blah" etc.

**** TODO [#B] iexpr ignores last line of not followed by a newline char

**** TODO [#B] Comments need to be handled / skipped

*** DONE [#A] arguments in function don't match: tell which argument(s) failed
    CLOSED: [2007-12-27 Thu 01:45]

*** TODO Codegen in zomp

**** TODO Bindings for LLVM IR
**** TODO Define base language (from current definition)
**** TODO Base lang -> LLVM IR translation
**** TODO ast type system?

*** DONE [#A] type errors: show expected and found type
    CLOSED: [2008-01-11 Fri 19:18]

*** TODO [#B] use llvm ocaml bindings for code generation
check whether this makes IR-verification faster / prevent bugs / ...

*** DONE compilation needs O(n^2) time
    CLOSED: [2007-12-20 Thu 02:54]

*** DONE [#A] performance probleme fixen
   CLOSED: [2007-12-20 Thu 02:54]

*** TODO [#B] compiling is extremely slow

*** TODO [#C] Generate nice and readable LLVM code

**** TODO [#C] Let functions in genllvm.ml return a string list instead of strings with newlines
     
**** TODO [#C] Add empty line(s) between functions
     
**** TODO [#C] Fix useless newlines which appear on some operations
     
**** DONE Fix missing line breaks
    CLOSED: [2007-09-28 Fri 23:17]

*** TODO [#C] Add a c backend which generates nice and readable code

*** TODO [#C] Bug: (func int main () 20) does not compile :bug:
    But (func int main () ((ret 20))) does as well as (func int main () ((printInt 10) 20))

*** TODO [#C] Bug: some generic intrinsics might return invalid bindings :bug:
*** DONE [#A] parse 1.0f as float
    CLOSED: [2008-01-16 Wed 01:20]

** Interactive toplevel
   
*** TODO [#A] better error reporting on immediate code execution in toplevel
*** TODO [#A] macro/function to check whether running in toplevel
*** TODO [#A] add (ret void) to end of immediate functions in toplevel
*** TODO [#B] print nice struct names on !bindings (same as on !writeSymbols) in toplevel
*** TODO [#A] using invalid floating point constant will screw up LLVM for whole session :bug:
*** DONE [#A] allow immediate execution of code
    CLOSED: [2008-02-12 Tue 02:52]

*** TODO [#B] proper error reporting when function/macro is redefined with different parameter count/types
*** TODO [#B] let toplevel send feedback to emacs + handle errors (abort eval etc.)

*** TODO [#B] fast navigation
    
*** TODO [#B] zomp toplevel in emacs: don't switch to buffer on C-c,C-s
    
*** DONE print var/func/macro declaration in toplevel
    CLOSED: [2007-12-03 Mon 01:25]
    
*** DONE make printing parsed s-expr optional
    CLOSED: [2007-12-03 Mon 01:25]
    
*** DONE Create C interface
    CLOSED: [2007-09-30 Sun 01:53]
    Reuse native function generator from opengl bindings(?)
    
*** DONE Create inferiour llvm machine
    CLOSED: [2007-09-30 Sun 01:53]
    Startup llvm jit machine, allow vars + functions to be (re)defined, allow functions to be called
    
*** DONE Read-Eval-Print loop
    CLOSED: [2007-09-30 Sun 01:53]
    
*** DONE Make it run stable and be usable
    CLOSED: [2007-10-03 Wed 03:33]
    
*** [#B] Support loading DLLs and calling their functions
    
**** DONE Load DLLs
     CLOSED: [2007-11-04 Sun 03:35]
     
**** DONE Call functions in them
     CLOSED: [2007-11-04 Sun 03:35]
     
**** TODO [#C] Add search paths
     
*** TODO [#B] Fork to avoid crashes
    
**** TODO [#B] Find a way to keep connection to stdin on crash in other process
     
*** DONE Change/reevaluate functions
    CLOSED: [2007-10-09 Tue 16:20]
    
*** TODO [#C] Redefine/change variables
    
** Emacs support

*** TODO [#B] zomp-newline: problem with indent (resetting pos)
*** TODO [#B] emacs/toplevel: C-c C-s abfangen wenn toplevel schon laeuft
*** TODO [#C] examples which can be browsed directly in emacs
*** TODO [#B] correctly indent }
*** TODO [#C] zomp: fast doc lookup
*** TODO [#B] emacs: backspace should delete autoinserted text in one step
*** TODO [#B] highlight '"' correctly in emacs (don't interpret this as the beginning of a string)
*** TODO [#B] also auto-insert // on newline
*** TODO [#B] /// <enter> <backspace> -> remove inserted ///
*** DONE [#A] don't move cursor on indent. then integrate zomp-tab into zomp mode
    CLOSED: [2008-02-21 Thu 14:24] 
*** TODO [#C] alt-k => mark current word first, then sexpr
*** TODO [#C] emacs: navigate to error caused by evaluating code in toplevel
*** TODO [#C] fix wrong promts in emacs inferior zomp mode
*** TODO [#C] emacs indenting: ignore parens in comments
*** TODO [#B] (op+_d | => zomp eldoc does not work

*** DONE [#A] eldoc: struct* als name* und nicht als ((type1 field1) (type2 field2)..)* anzeigen
    CLOSED: [2008-01-11 Fri 17:17]
*** TODO [#B] a line cannot be uncommented using ctrl-\ if the // does not start at pos 0
    temporary fix: zomp-mode will now use /* ... */ instead of //

*** TODO [#C] fix indent of }

*** TODO [#C] fix cursor positioning on indent

*** TODO [#B] indent: special treatment for lines containing only closing parentheses?

*** TODO [#B] add hook to zomp-mode

*** TODO [#B] Flymake support

*** DONE Start zomp toplevel in emacs
     CLOSED: [2007-10-16 Tue 22:11]

*** DONE Send current region/buffer to toplevel
     CLOSED: [2007-10-16 Tue 22:11]

*** DONE Send current function toplevel
     CLOSED: [2007-10-16 Tue 22:11]

*** DONE [#B] zomp.el eval current: go one char forward to capture *cursor.pos*(func foo...)
     CLOSED: [2007-11-16 Fri 02:33] 

** Macros
   
*** TODO [#B] implicit arguments for macros (source location from where it was invoked etc.)
*** TODO [#C] hygienic macros: ast* qualify(ast*, bindings) will fully qualify all identifiers in the given ast
*** TODO [#A] better error message on `(ret `(...)) in macro
*** TODO [#A] protect against recursive macro invocations
*** TODO [#A] `(#foo a b c) should turn into (fooValue a b c) instead of (seq fooValue a b c)
    Reevaluate!
    (at least if foo does not have any arguments)
    
*** TODO [#B] macro/template: warnung wenn `(a b c) a/b/c gleichzeitig parameter/lokale vars sind und ohne antiquote verwendet werden

*** TODO [#A] name collisions of macros and functions (?) causes problems
Put macro functions into seperate module

*** TODO [#B] Hygienic macro support?
*** Archive                                                            :ARCHIVE:
**** DONE Allow definition of simple "template" macros
     :PROPERTIES:
     :ARCHIVE_TIME: 2008-04-14 Mon 01:34
     :END:
     
**** DONE Allow running code inside macros
      CLOSED: [2007-10-29 Mon 15:48]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:
     
**** DONE Query existing functions and variables
      CLOSED: [2007-11-16 Fri 02:33]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:
     
**** DONE Write "for i min max" macro
      CLOSED: [2007-11-02 Fri 02:50]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:
     
**** DONE Write "if then else" macro
      CLOSED: [2007-12-04 Tue 00:23]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:
     
**** DONE Allow macros to call any ordinary function
      CLOSED: [2007-11-02 Fri 02:50]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:
     
**** DONE Insert astFromInt or astFromString if a var/func returns int/string
      CLOSED: [2007-11-02 Fri 02:46]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:
** Language / APIs

*** TODO [#B] framebuffer cleanup/releasing code
*** TODO [#C] check for off-by-one error in shbase function calculation
*** TODO [#A] rename "template" to "rewrite"
*** TODO [#C] glfw bindings auf 2.6 updaten
*** TODO [#A] support for GL_RGBA32F_ARB etc.
*** TODO [#A] remove new macro in glutils, replace by new macro from shprog (move it to stdlib)
*** TODO [#A] complete enum.zomp
*** TODO [#B] macros to get current file/line/column
*** TODO [#A] API for code analysis
    Get information about an expression: types etc.
    (can be used for type propagation)

**** std:kernel
        Builtin primitives in a seperate module
        label, branch
        type
        var, const
        func
        macro

**** std:ast
        ast representation

        type Type
          String name

          isIntegerType() -> bool
          isFloatType() -> bool
          +-isString() -> bool-+
          isRecordType() -> bool
          isRecordType() -> bool

          isSubType(Type*) -> bool

**** std:ast:reflection
        type, typeOf(ast)
        
**** std:ast:detect
        isLabel, isBranch, ...

**** std:ast:annotations
        // Query annotations
        ast.hasAnnotation name

**** std:bindings
     // Query for bound names

     type Var
       String name
       Type type
       
     type Macro
       String name
       Array<String> args
       Bool isVariadic

     type Func
       String name
       Type resultType
       Pair<String, Type> args

     lookupVar(string) -> Option<Var>
     lookupMacro(string) -> Option<Macro>
     lookupFunc(string) -> Option<Func>
     lookupType(string) -> Option<Type>
     lookup(string) -> Variant<Var(Var), Func(Func), Type(Type), Macro(Macro), Undefined>

*** TODO [#A] Explicit polymorphism

    Overloading functions should be possible

    Requires the API for code analysis (see above)

**** API

    overloadable name

    overload name(param*) targetName

    param ::= type typeName
    param ::= ast

**** Example

    overloadable print
    overload print(type int) printInt
    overload print(type string) printString

**** Utils

    overloadable plus

    ofunc int plus(int l, int r) impl
    =>
    func int plus_int_int(int l, int r) impl
    overload plus(type int, type int) plus_int_int

*** TODO [#A] Some simple generic/C++-style-template support

**** std:generic
  
  type (param+) name decl
  => macro name, expanding into expandType

  expandType name (param+)
  => std:toplevelExpr
       std:kernel:type name decl'
  where decl' is decl with substituted type params
  (only generate type once)

  func (typeParam+) name (param*) impl
  => macro name (param*), translating into expandFunc

  expandFunc (typeParam+) name
  => func name (param*) impl
  with substituted types (and functions?)

**** std:typeclass
??

*** TODO [#A] Pattern matching

**** On sexpr/ast

ast:match ast matchExpr

matchExpr ::= case matchCase => code

matchCase ::= pattern
matchCase ::= var = pattern
matchCase ::= var varName : type

pattern ::= "expectId"
pattern ::= (matchCase+)

**** Overloaded match macro

match foo matchExprs+
=> typeOf(foo):match foo matchExprs+
     
*** TODO [#B] Regular expressions
**** TODO [#A] Bindings for PCRE
**** TODO [#B] Special match syntax

*** TODO [#B] File I/O
**** TODO [#A] Bindings for C stdlib
**** TODO [#C] Systems of streams similar to Java/.Net/...

*** TODO [#B] Namespaces / Modules

*** TODO [#B] Allow testing macros
(running them on code and printing the resulting AST)
    
*** TODO [#B] Object system
    
**** vtable calls

class Foo
  Foo(int arg) / constructor(int arg)
  var int x
  method float bar (int y) barImpl

=>

type Foo:vtable
  (Foo* -> void)* destructor
  (int -> float)* bar

type Foo
  Foo:vtable* vtable
  int x
  (int -> float)* bar

func float Foo:bar(Foo* this, int y)
  barImpl

macro bar (var Foo f) y
  f.vtable.bar( f, y )

func Foo:constructor(Foo* this, int arg)
  this.vtable = & Foo:vtable


new Foo(args*) => (Foo* f = malloc Foo; Foo:constructor(f, args); f)

**** Interfaces

**** Inheritance

**** Syntax support

Is anything special needed?
     
**** Represent them in zomp ast type <- what does this mean? :)

**** Message passing (on top of this)

**** Type classes / concepts based on classes? Reusing infrastructure?

*** TODO [#C] Compile multi file projects
    
**** Realize definition of project files
     A central project file which will list all linked in modules,
     settings etc.

     "zompc project.zomp release" should be enough to build the whole project

**** Define .zobj format
    
*** TODO [#C] support break in loops

*** TODO [#C] Specify exceptions using attributes?

    file = @(cfa:disable fileIsOpen) openFile "foo"

*** TODO [#A] allow replacing parts of libraries
*** TODO [#A] versioned packages

*** DONE [#A] template
    CLOSED: [2007-11-24 Sat 20:12]     
    Implemented as macro
      
*** DONE [#A] OpenGL support
    CLOSED: [2007-11-25 Sun 00:35] 

** Public

*** TODO [#C] provide a (semi) public git repo

*** TODO Find collaborators

** Syntax

*** Issues
**** TODO [#A] how to parse "var x = 10"? (op= (var x) 10), (var (op= x 10))? parse (var: x = 10) as (var (op= x 10)) but (var x = 10) as (op= (var x) 10)?


**** TODO [#A] (count-1) is being parsed incorrectly

* Notes											:zomp:

** Alternative names

There exist several brands and companies of the name "zomp". Thus alternatives should be considered.

zump - only name which sounds more stupid than zump :)
zompl - zero overhead meta programming language
baremp - bare metal meta programming / bare metal programming
bmmp
llmp - low level meta programming
lowmp
zoml - zero overhead meta language
0mp
roomp

** Type annotations
Annotate types using meta data?

let @type(int) x = 10

Use : as infix operator (: symbol type) as a macro name:

macro : symbol thetype = {
  @type(thetype) symbol
}

then:

let x :int = 10

** ; / expression separation
Let ; be an operator/macro?

print "1+1="; print 2;

=>

(op; (print "1+1=") (print 2))

;-macro evaluates each expression + returns value of the last one
(problem: requires macro expansion at run time. maybe instead create a sequence expression (evalseq (print "1+1=") (print 2)) and return that?)

Then monads are probably possible without expanding the syntax (and possibly even without any/too much runtime overhead because no closures need to be passed around)

** Annotations

See the declare statement in lisp

Use @attrib( valueExpr ) syntax?

** python's doctest clone
automatically check embedded examples in documentation for correctness

** Type System

*** Composable type system?
    
**** multiple lanes/rails/...

     - independent from each other
     - type checking done on each of them

     - default property: shape (binary representation)
       
*** Arithmetic types (sum, product types)
*** Generic types
*** How much in kernel language, how much as macros?
     
*** refinement types?
*** research: macros and formal verification

*** Security level
A variable a has an associated security level l(a). Writing a := b requires l(b) >= l(a).
Similarily, the relation of security levels between function's arguments and parameters can be declared.
Might allow to do flow analysis.
See http://cristal.inria.fr/~simonet/soft/flowcaml/manual/fcs003.html#toc5

*** linear types?

*** control flow analysis

cfa:invariant bool fileIsOpen
  require false on: ret message: "File should be closed"
  set true on io:openFile
  set false on io:closeFile
end

func foo()
  file = openFile "blah" (1)
  if( cond )
    closeFile
  else
    do stuff // (2)
  end
end func

=>

Error:dummy.zomp:(2): File should be closed
  cfa:invariant fileIsOpen set to true on line (1), expected to be false on ret
       
** Packages / Projects
*** compilation model
**** Use an VM-only approach?
     Only operation mode is having a VM which can load and execute code
     Compiling static executables works by "dumping" code
**** Distinguish imports for runtime functions from those for macros?
     "import FunctionProvider" will import functions from FunctionProvider
     "usesyntax MacroProvider" will import macros and functions for compile time, only?

     - Does this work? Is it neccessary at all?
     - Is it possible simply to strip unneeded functions on link-time?

*** packages
*** project layout
one toplevel file, drawing in all libs, settings etc.

project.zomp

  application RadiositySolver

  libpath ./extlib
  require ./extlib/*
  replaceLib std.strings with extlib.unicodeStrings

  sourcepath ./src
  sources
    src/utils/*.zomp

* Footer

** Keep flyspell happy
 LocalWords:  AST IR VM Zomp zomp simpleform expr var boundsCheck alloca SSA
 LocalWords:  bytecode  Ast ast

