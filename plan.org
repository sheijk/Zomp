#+SEQ_TODO: TODO DONE
#+STARTUP: fold
#+COLUMNS: %TODO %PRIORITY %TAGS

* To be sorted
** TODO eval current defun fails on last func in file
** TODO snobol string matching ankucken
** TODO type degree := int in :=_type degree int umwandeln
   defkind name := definition+
   => :=_defkind name definition

   varname := value
   => var varname value

   Will provide overloadable definitions / simulate keywords
** TODO optional + named parameters: c# modell taugt
** TODO [#A] Causes invalid llvm code when omitting "ret"

   (macro opseq args ... (
     (ret args)
     ))

** TODO [#A] add toggle to make control display of tempvar_* :toplevel:
** TODO [#A] zeroinitializer -> llvm variable mit nullen initialisieren
** TODO [#A] GHCs newtype genauer ankucken
** TODO [#A] also haskell "views" http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3532
** TODO [#A] scala "extractors", F# "active patterns"
** TODO [#A] indenting fuegt spaces in leere zeilen ein :emacs:bug:
** TODO [#A] can't get address of record
** TODO [#A] #foo.bar does not work :bug:parser:
** TODO [#A] #func(a,b,c) does not work (antiquotation should be allowed for funcalls) :bug:
** TODO [#A] http://citeseer.ist.psu.edu/cache/papers/cs/25243/http:zSzzSzseclab.cs.ucdavis.eduzSz~devanbuzSzteachingzSz260zSzmacros.pdf/weise93programmable.pdf macro system for C
** TODO [#A] macro checking / typing http://www.ccs.neu.edu/scheme/pubs/gpce2004-cf.pdf
** TODO [#A] for i 0 (ret int:pow(2,3)) => llvm parser-fehler
** TODO [#A] schreibzugriff auf args/register vars verbieten
** TODO [#A] zomp.el: double als typ highlighten
** TODO [#A] `printBool true && (false || true)' geht nicht
** TODO [#A] a-10 will be parsed as `(jux a -10)` :bug:
** TODO [#A] support fuer var int* addr = &i
** TODO [#A] pointer alignment ins typsystem aufnehmen
** TODO [#A] chooseRandomly(Sequence T s) -> T
** TODO [#A] support fuer clutter gui (OpenGL basiert, mit C api, LGPL)
** TODO [#A] which-func mode zeigt fuer operatoren nur "op" an
** TODO [#A] indent syntax: redefine _foo operators like ==_str not supported, yet
** TODO [#A] fehlende returns am ende von makros werden nicht immer uebersetzt
** TODO [#A] op. geht nicht innerhalb von argumentliste
** TODO [#A] reorganize zompvm.cpp
** TODO [#A] mehr auf einfachheit / schnelle umsetzbarkeit optimieren
** TODO [#A] more friendly name for sexpr? (itree? codetree?)
** TODO [#A] doch benutzerdefinierbare syntax?

   anfang + ende definiert durch ein token
   ende definiert durch indent level?
   tokens koennen in namespaces leben

   matches = zomp.db.sql
     SELECT foo, bar FROM WHERE foo > bar

   zomp.db.sql <<  SELECT foo, bar FROM WHERE foo > bar >>

** TODO [#A] alle tests auf neue syntax umstellen, tests organisieren, moeglichkeit zum fehler pruefen einbauen
** TODO referenzen fuer hot-swapping

   A. Baumann, J. Kerr, J. Appavoo, D. Da Silva, O. Krieger, and R. W. Wisniewski.
   Module hot-swapping for dynamic update and reconfiguration in K42.
   In Proceedings of the 6th Linux.Conf.Au, Canberra, Australia, Apr. 2005.
   To appear.

   C. A. N. Soules, J. Appavoo, K. Hui, R. W. Wisniewski, D. D. Silva,
   G. R. Ganger, O. Krieger, M. Stumm, M. Auslander, M. Ostrowski,
   B. Rosenburg, and J. Xenidis.
   System support for online reconfigura- tion.
   In Proc. of the Usenix Technical Conference, 2003.

   M. Hicks.
   Dynamic Software Updating.
   PhD thesis, Department of Computer and Information Science, University of Pennsylvania, August 2001.

** TODO [#A] object system with composition as a primitive? (mixins / entity part scene graph like?)
** TODO [#A] ownership types
** TODO [#A] automatically derive data parallel code?
** TODO [#A] cee: 'a, b = 1, 2' should be possible

** TODO [#A] deref operator precedence

   c - c precedence rules, *foo, lowest precedence
   postfix - foo^, highest precedence
   prefix - *foo, highest precedence

   | c                  | postfix            |              | prefix             | comments |
   |--------------------+--------------------+--------------+--------------------+----------|
   | *ptr               | ptr^               |              | *ptr               |          |
   | *obj.ptr           | obj.ptr^           |              | obj.*ptr           |          |
   | (*ptr).field       | ptr^.field         |              | *ptr.field         |          |
   | *(*ptr1).ptr2      | ptr1^.ptr2^        |              | *ptr1.*ptr2        |          |
   | (*ptr2array)[n]    | ptr2array^[n]      |              | *ptr2array[n]      |          |
   | *arrayOfPtrs[n]    | arrayOfPtrs[n]^    |              | *(arrayOfPtrs[n])  |          |
   | ptr[n]             | ptr[n]             |              | ptr[n]             |          |
   | *array[n].fieldPtr | array[n].fieldPtr^ |              | array[n].*fieldPtr |          |
   |--------------------+--------------------+--------------+--------------------+----------|
   | &addr              | addr&              | ^addr        | &addr              |          |
   | &addr[2]           | addr[2]&           | ^addr[2]     | &(addr[2])         |          |
   | (&addr[2])         | addr&[2]           |              | &addr[2]           | ???      |
   | &struct.addr       | struct.addr&       | ^struct.addr | &(struct.addr)     |          |
   | (&addr).field      | addr&.field        |              | &addr.field        | ???      |
   |--------------------+--------------------+--------------+--------------------+----------|
   | int (*)()          | int()^             |              | *int()             |          |
   | int* (*)()         | int^()^            |              | *(*int)()          |          |
   | todo               |                    |              |                    |          |

   [Anderson 80]. Sethi [Sethi 81] http://www.cs.bell-labs.com/who/dmr/chist.html

** TODO [#A] get "inspiration" from tango: http://www.dsource.org/projects/tango/wiki/Manual
** TODO [#A] how to integrate OOP and concepts nicely?

   interface ICollection<T>
     void append(T)
     int size()

   concept Collection<T>
     type Self
     void append(Self, T)
     int size(Self)

   // generator from each other like
   concept Collection<T> = ICollection<T>
   interface ICollection<T> = Collection<T>

*** TODO some things cannot be expressed properly using OOP

    concept Clonable<T>
      T clone(T)

*** TODO concepts allow adding implementations to closed classed
    will not help for non-polymorphic methods

** TODO [#A] foreach mit support fuer index                                                        :unsorted:
** TODO generics: share inlined implementation
   possible if binary data layout is the same
   => dummy parameters should not matter
** TODO [#A] op; needs lower priority than juxtapositions
** TODO [#A] name z*mp?
** TODO [#A] indent parser als default fuer toplevel
** TODO [#A] fieldptr hat keine doku im toplevel
** TODO [#A] eldoc geht nicht in quotations: ${setField <cursor>}
** TODO [#A] zomp-newline does not delete selection
** TODO [#A] references (int& lvalue) ueber makros oder aehnliches machen
** TODO [#A] nur identifier in namespaces erlauben, keine im TOPLEVEL?
** TODO [#A] ueberall nounwind an die methoden haengen (evt. performance-relevant, benchmarken)
** TODO [#A] swap quote and antiquote characters to get more "natural" syntax?
** TODO [#A] alias macro
** TODO [#A] base language verkleinern + vereinheitlichen: nur eine form pro konstrukt mit nur einer variation. declareFunc und defineFunc usw.
** TODO [#A] overload sets? http://www.digitalmars.com/d/2.0/hijack.html
** TODO [#A] system fuer fehlercodes + ausfuehrlicher doku
** TODO [#A] teilprojekte / ziele definieren um das projekt ueberschaubar zu machen?
** TODO [#A] referenzen unterstuetzen? (fuer "foo[10] = 0" usw.)
** TODO [#A] overloading functions + macros immer auf AST-struktur basierend?

   mit praedikaten oder pattern matching?

   pattern: define matches, on match return some(..) else none

   pattern id =
     case: {id = name; args=[]} => name

   pattern boundType =
     case: { id = name; args = [] } => bindings.lookupType name

   pattern seq =
     case: {id = seq} =>


   var int x
   var float y 10.0

   // no default
   macro var name: id type: boundType name: id
     ...

   // with default
   macro var name: id type: boundType name: id default: anyExpr


   func void print(int x)
   func void print(float y)

   =>

   macro print x: exprWithType(int)
   macro print y: exprWithType(float)
** TODO [#A] llvm-gcc -> virtuelle methoden, (mehrfach)vererbung ansehen
** TODO [#A] collection initialization

   l = new List<int>() { 1, 2, 3, 4, 5 }
   =>
   l = new List<int>();
   l.add(1) ...

   - When will this work?
   - Whenever an add method exists?
     - will cause problems with Complex.add(Complex) etc.
   - add method will some attribute?
   - include "extension" methods? (void add(List, int))
   - require implementation of Collector / Collection interface?
   - realization of type class?
** TODO [#A] arbitrary attributes used by the type system?
   allow user defined attributes to be sticked to vars, funcs and types which will then be used during type checking
   support const using this system

*** Example

    attribute threadSafe

    func void remove(List l, Iter i) ...
    func void insert(List l, int element) ...

    @threadSafe
    func void sort(List l)
      ...
      remove(l, first) <- error, remove is not @threadSafe
      ...

*** Use cases
    - const member methods
    - const vars
    - thread safety
    - exception safety
    - pure functions
    - functions which perform io?
** TODO [#A] implicit (dummy) parameters?
   parameters which will be added implicitly
   use for: type classes, capabilities
   maybe restricted/defined by calling function?
** TODO [#A] optimierungs-settings pro funktion
   zusaetzlich auf project file ebene ueberschreibbar (~ "optimizations sheijk.raytracer.math.* speed 3")

   @optimize(speed 3)
   func void foo()
     ...
** TODO [#A] reconsider the syntax
   explicitly state goals! :)

   idee:
   - jux has highest prio
   - comma operator
   - jux a b
     - function call if a is a function name or function ptr name
     - expand macro if a is a macro name
     - else expand macro + see if expanded a resolves to a function

   sin x + 3 cos y * 2
   =>
   (inf+
     (jux sin x)
     (inf*
       (jux 3 cos y)
       2))

   if: condition() then: ...
   if condition() then ...
   if (condition()) then ...

   for i in min() to max() do ...
   for i in (min()) to (max()) do ...
   for: i in: min() to: max() do: ...

   while x + foo() > 10 do ...
   while (x + foo() > 10) do ...
   while: x + foo() > 10 do: ...

   make even layout optional?

** TODO add parse and expand
   parse :: string -> Ast
   expand :: Ast, Bindings -> Ast
** TODO [#A] im parser ausprobieren

   printInt (ifExpr a > b
     1
   else
     2
   end)
** TODO [#A] delegating methods

   class Adapter
     Thing* target
     method print => target.print
** TODO [#A] zömp / zomp als name?
** TODO data flow programming
   get inspiration from SISAL
   http://www2.cmp.uea.ac.uk/~jrwg/Sisal/08.Loops.par.html
** TODO combinators for parallel code
   similar to this
   http://www.cilk.com/multicore-blog/bid/5672/Global-Variable-Reconsidered
** TODO [#A] exception handling
   structured exception handling (win32) ankucken
   http://www.ddj.com/cpp/184403758
   lisp style condition system (exception handler vor stack-unwind aufrufen)
** TODO [#A] typ von member methoden
   nicht abhaengig von typ in dem sie deklariert wird
   sondern jeweils vom leaf-typ

   class Clonable
     virtual type(this)* clone()

   class DerivedClonable
     override type(this)* clone()

   void test(Cloneable* c, DerivedClonable* d)
     c*.clone() :: Cloneable*
     d*.clone() :: DerivedClonable*


   method signature will be evaluated in the context of the class overriding the method
   result type in derived class must be subtype of result type in base class
** TODO [#A] indent syntax

   Other rules for multi line expressions:
   - only use indented block as parameter by default
   - : at the end of the line will start multi-line expression
   - last one has no ending :
   - make end optional?

   for i in 10 .. 20
     print i

   print "done"


   if a > b then:
     print a
   else if b > a then:
     print b
   else
     fail()


   class Blah:
   public:
     void foo()
     void bar()
   private:
     int x
     int y
   end class Blah
** TODO [#A] type classes / overloaded functions

   -- not legal
   class Foo x where
       xxx :: x -> x
   class Bar x where
       xxx :: x -> x


   type TypeClassFunction =
     String name
     Type type
     TypeClass* class

   type TypeClass =
     String name
     [TypeClassFunction*] functions

** TODO linked text modus
   [*CURSOR*foobar]
   '|' eingeben
   => [|*CURSOR*foobar|]

   aehnlich:

   while| true
     random(code)
   end while

   M-backspace, "loop"

   =>

   loop| true
     random(code)
   end loop
** TODO [#A] schnelle interpreter bauen
   Don't have time to dig up links, but here's my list that google will help you with:

Context Threading: A flexible and efficient dispatch technique for virtual machine interpreters

Optimizing Indirect Branch Prediction Accuracy in Virtual Machine Interpreters

Context Threading, by Florien Fest

The Case for Virtual Register Machines

YETI: A GRADUALLY EXTENSIBLE TRACE INTERPRETER

Effective Inline-Threaded Interpretation of Java Bytecode Using Preparation Sequences

A PORTABLE RESEARCH FRAMEWORK FOR THE EXECUTION OF JAVA BYTECODE

A No-Frills Introduction to Lua 5.1 VM Instructions

von http://lambda-the-ultimate.org/node/2884

** TODO next steps                                                        :next:
   - provide support for function pointers
   - provide simple dynamic oop system
   - use it to implement compiler services

   - rename all build-ins to std:base:...
   - simplify them to only one valid form
   - provide var,.. wrappers which redirect to the std:base forms
     and add zomp-side meta information
** TODO [#A] &, == operator precedence
   & sollte hoehere prioritaet haben, damit "a & 0x00001001 == 0x00001001" geht
** TODO [#A] consider latex style operators
   \x, \o, ...
** TODO [#A] it/the foo um auf vorherige ergebnisse zuzugreifen
   http://code.google.com/p/muvee-symbolic-expressions/wiki/TheAndIt

   sum [1, 2, 3, 4, 5]
   print it
   => 15


   sum(1..100)
   average(20..30)

   print (the sum)
   print (the average)
** TODO [#A] sml-like integer types
   InfInt - integer with arbitrary size
   FixedInt - signed int which raises exceptions on overflow
   Word - unsigned int with modulo arithmetic
** TODO [#A] generate uniqueIds automatically in macros

   template foo
     var int `x 10
     print `x
   end

   =>

   macro foo
     uniqueIds x "foo"
     ret ${
       var int #x 10
       print #x
     end}
   end
** TODO [#A] makro-system inspiration
   Common Lisp reader macros, the proposed QuasiQuoting extensions to Template
   Haskell, Forth parsing words, and/or Camlp4 are things to look at in this
   regard.
** TODO [#A] do not allow function and variable names and constants as id of expression
   Require them to be wrapped into apply/var/constant

   print(10 + x)
   =>
   (opcall print 10 x)
   =>
   (apply print 10 x)
   =>
   Error: unknown 10 and x
   =>
   (apply print (constant 10) (var x))

   How to convert into constant and var forms? Calling an error function which may return a transformed sexpr?
** TODO [#A] smooth integration of other languages
   extractDefs(LLVM::Module*)
   Will parse the module and add Zomp definitions for all found types and functions

   parseC(string) -> LLVM::Module*
   Invoke Clang to JIT C-code from a string or file
** TODO [#A] source code annotation language
   http://msdn.microsoft.com/en-us/library/ms235402(VS.80).aspx
** TODO [#A] SAL http://www.cs.uoregon.edu/research/summerschool/summer07/lectures/Lightweight_Specifications_for_Win32_APIs.pdf
** TODO [#A] vector operations
   http://dobbscodetalk.com/index.php?option=com_myblog&show=Vector-Operations.html&Itemid=29
   http://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html
   http://developer.apple.com/performance/accelerateframework.html
** TODO [#A] order independent toplevel statements
   Try to do macro expansion in the order they appear in the file
   If the expansion of one toplevel expressions fails because a method/function
   was not found, re-evaluate it once the symbol is defined

   Defining two symbols with the same name in the same scope is illegal, even for macros

   Keep a Map<Symbol, ToplevelExpr>. After the processing of each toplevel expression check
   whether any symbols in this map have been defined in the mean time. If true evaluate the
   corresponding toplevel expression
** TODO [#A] yield iterator/loops: sofort zum ersten ergebnis
   public static class StreamReaderExtensions
   {
       public static IEnumerable<string> Lines(this StreamReader reader)
       {
           if (reader== null)
               throw new ArgumentNullException("reader");
           reader.BaseStream.Seek(0, SeekOrigin.Begin);
           string line;
           while ((line = reader.ReadLine()) != null)
               yield return line;
       }
   }

   Problem: null check will be done when iterator is moved for the first time
   and not when the method is originally called:

   // will create an object representing the computation being paused before line 1
   Iterator<string> lines = fileStream.lines();

   // loads of code

   // will throw ArgumentNullException here
   string firstLine = lines.next();

   Instead of initially pausing the computation at line 0 let it run until the
   first occurence of yield
** TODO [#A] Codegen tries to get address of parameter                     :bug:
   Without the printFLocal this fails:

   struct concept_Printable
     (fptr void void* ) printF
   end

   func void concept_Printable:init(concept_Printable* this, (fptr void void* ) printF)
     printFLocal := printF
     this.printF = printFLocal
   end
** TODO [#A] !prompt is applied too late                                   :bug:

     # !prompt foo<enter>
   Set prompt to '  foo ' and cont. prompt to '..foo '
     # |<enter>
   ..foo |
** TODO [#A] dynamic calls with support for protocols
** TODO syntax for generic/polymorphic functions

   func void print<Printable P>(P p) vs. print(Printable[P] p)

   func P add<Number P>(P l, P r) vs. Number[P] add(P l, P r)

   add :: Number P => (P, P)->P
   add(l, r) = ..

   func N add(N l, N r) where Number N

   func<Number N> N add(N l, N r) // schick
** TODO assimp anbindung
** TODO pcre anbindung
** TODO [#A] casting syntax

   obj.to(Printer).println("10".to int)
** TODO [#A] c# style coalesce operator a ?? b
   x = a ?? b
   =>
   x = if a != 0 then a else b

   x = a ?? b ?? c
   =>
   x = if a != null then a elseif b != null then b else c

   Alternative:

   x = firstNonNull a b c

** TODO object initializers

   (from wikipedia)
   Customer c = new Customer(); c.Name = "James";
   can be written
   Customer c = new Customer { Name="James" };

   MyList list = new MyList();
   list.Add(1);
   list.Add(2);

   can be written as

   MyList list = new MyList { 1, 2 };
** TODO [#A] change character class for '&' in zomp.el (and possibly other characters)
** TODO [#A] varargs per concept param

   int sum(vararg list<int> args)
   int sum(vararg vector<int> args)

   template<T, Cont = vector>
   T sum(vararg Cont<T> vars)

   all legal to be called by
   total := sum(1, 2, 3, 4, 5)

   Everything which is a model of concept Iterable

   concept Iterable<T>
     Iterator<T> iterator()

   concept Iterator<T>
     bool atEnd()
     T get()
     void next()
** TODO [#A] parsing of foo(a)(b), foo<int>(3) etc.
** TODO [#A] a, *b, c = range(5)
   Extended Iterable Unpacking. You can now write things like a, b, *rest =
   some_sequence. And even *rest, a = stuff. The rest object is always a
   (possibly empty) list; the right-hand side may be any iterable
   (from python3 changelist)
** TODO [#A] quantities: number + unit
   also allow a unit-power in constructors
   1000m = 1km
   10kg .uncomparableTo 10min
** TODO [#A] ++i or +i
   Pre- and postfix operators consist of only one symbol. This conflicts with
   using ++ and -- for in/decrement.

   for +:
   - no inconsistencies (every pre/postfix op is always one char)
   - nesting like +++i to increment by three possible

     func copy(byte* dest, byte* source, int size)
       do size times
         +dest = +source

   for ++:
   - consistent with C
   - meets expectations of developers
   - might be confusing if i++ means (i+)+

     func copy(byte* dest, byte* source, int size)
       do size times
         ++dest = ++source
** TODO [#A] regexp syntax #/foo/bar/
   #c, means use c as seperator
   for c != char, num, paren

   allow prefix for strings like
   L"foobar"
   utf8"some string with umlauts"
   re"[a-z]+"
   textVar.replace re"func ([:type:]) ([a-z]+)" "\1 \2"
** TODO modulsysteme für lisp dialekte ankucken
** TODO [#A] allow 500_000 as numeric constants
** TODO [#A] type expression syntax

   int[]*                   - pointer to int array
   int*[]                   - array to int pointers
   int, float               - pair of int and float
   float -> int             - int f(float)
   int, float -> char       - char f(int, float)
   (int,int), float -> char - char f(pair(int,int), float)

   Optional:
   [int] - list of ints
   {int} - set of ints
** TODO [#A] llvm.globalctors for initialization
** TODO [#A] wadler-blott for ad-hoc polymorphism
** TODO [#A] if2: elseif should support 'then'
** TODO func void foo(float a, float a)                                    :bug:
   should be checked
** TODO [#A] unit test: writing function argument
** TODO [#A] llvm::ParseAssemblyString does not add code to target module
   parsedModule = ParseAssemblyString( code, targetModule, &errorInfo );
   2.1: targetModule contains definitions
   2.2/2.4: defs not added anymore

** TODO [#A] performance tests, ergebnisse loggen
** TODO [#A] letzte zeile vom toplevel aus in buffer/kill-ring befördern
** TODO design a library system for zomp                                   :pop:
   Needed features
   - simple packaging
   - dependencies
   - documentation
   - cookbook
   - faq
   - central repository
   - automatic installation

   Inspiration: maven, CPAN
** TODO [#A] add call to flush() after macro calls
** TODO [#A] ast:matchesShape should support vararg match
   _(_...) => matches (opcall _ args*)
** TODO [#A] var doesn't check whether types match
  var cstring foo 10
** TODO [#A] ${foo _...} is not parsed correctly                    :bug:parser:
** TODO [#A] (a == 2 && 3 == 4) is not parsed properly
** TODO [#A] zomp-newline
   indent current line first, then decide about auto insertions
** TODO [#A] zomp-newline
   also check for words in zomp-unindent-keywords (like for end)
** TODO [#A] branchless min/max operation
   int foo(int p0, int p1) {
     return p1 + ((p0 - p1) & ((p0 - p1) >> 31));
   }
** TODO [#A] zomp-newline fails when at last line of buffer          :bug:emacs:
** TODO [#A] update imenu on changes                                     :emacs:
** TODO decide between struct and record name and stick to one
** TODO [#A] wrap-lighting
   adjVal := pickAny [0.0..1.0]
   ldn := l.dot n
   ldn' := (ldn+adjVal)/(1.0+adjVal)
   diffuse := max(0, ldn')
** TODO [#A] fbo + multisampling
   GL_EXT_framebuffer_blit
   GL_EXT_framebuffer_multisample
** TODO [#A] support matrix literals
   { 1, 0, 0, 0;
     0, 1, 0, 0;
     0, 0, 1, 0;
     0, 0, 0, 1 }
** TODO [#A] support % operator
** TODO [#A] make prefix operators have lowest precedence
   &foo[7].bar[3].x should get address of x
** TODO [#A] imenu: auf face testen, funktionen in comments/strings ignorieren
** TODO [#A] lexer                                               :lexer:parsing:
   char class lookup table
   struct CharClass
     isLetter : 1
     isNumber : 1
     isOperator : 1
     isWhitespace : 1
   end

   map char -> CharClass
   Lexing nur basierend auf Charclass
** TODO [#A] ||=, &&=, %, %= operators
** TODO [#A] compiler error with unknown var type not fatal                :bug:
   'var int (array int 10) numbers' yields an error message but but does not
   result in a failed compilation
** TODO [#A] support numeric limits (min/max float/int, nan, +/-infinity)
** TODO [#A] begin/end for special indenting behaviour?

   switch i begin
   case 1
     foo
   case 2
   case 3
     bar
   end

   class Blah begin
   public void foo()
   private int bar
   end

   switch i {
   case 1
     foo
   case 2
   case 3
     bar
   }

   switch i:
   case 1
     foo
   case 2
   case 3
     bar
   end

   if cond
     onTrue()
   next(expression, here)
** TODO [#A] release LLVM objects                                          :bug:

* Use Cases                                                            :usecase:

** .obj Loader [0/2]

   - [ ] parsing strings (regexp?)
   - [ ] reading from a file

** shader system [2/4]

   Turn a shader description into a class:

   shader Phong
     uniform float exponent

     output
       vec4 gl_FragColor
       float gl_Depth

     vertex(vec3 pos, vec3 normal)
       out.pos = ftransform()

     fragment(vec3 normal) => gl_FragColor, gl_Depth
       gl_FragColor = ...
   end shader Phong

   class Phong extends Shader
   {
       float exponent

       void vertex(Vertex v, out bla)

       void Pass0()
       {
       	state.blendenble = true
       	state.vs = vertex;
       	if ()
       }

   float bla[32];
   Texture t;
   Sampler1D blaSampler = {mode = Sampler.Mode.WRAP, filter = POINT, texure = t}

   void Simulate
   void Render(float t)

      - [X] opengl bindings
      - [X] function pointers
      - [ ] classes
      - [ ] mapping shaders to classes

** persistent camera in toplevel [0/2]

   It should be possible to store the camera pos after main() returned

   - [ ] global pointers
   - [ ] module level init code (run on load)

** overloaded functions
   It should be possible to supply support for overloaded functions as macros

   - [ ] get the type of variables
         (possibly trigger macro expansion of an ast from within macros)
   - [ ] compile time global variables

** miniml als testprojekt
   Um zu kucken wie sich Restriktionen umsetzen lassen

** Archive                                                             :ARCHIVE:

*** Indent based syntax [3/3]
    :PROPERTIES:
    :ARCHIVE_TIME: 2008-06-28 Sat 22:41
    :END:
    - [X] support for comments
    - [X] code cleanup
          correctly named modules, remove junk etc.,
          seperate unit tests
    - [X] support in toplevel and compiler
* Language design                                                  :design:lang:

** zomp-cee                                                                :cee:
   Set of macros and functions providing a simple C like feeling

*** TODO variables [3/4]
    Define a variable

    - [X] var int x
    - [X] var x // not allowed
    - [ ] var int x, y, z
    - [X] x := defaultValue

**** abandoned
    - [ ] var x = 10, y = 20.0
    - [ ] var int x = 10, float y = 20.0
    - [ ] var x = 10, float y = 20.0
    - [ ] var int x = 10
    - [ ] var x = 10

**** Requirements [1/3]
     - [ ] optional default value
     - [ ] multiple vars in one line
     - [X] optionally propagate type from default value

**** Properties
    - Legal forms
      var $type $name:id
      var $type (op= $name:id $default)
      var (op= $name:id $default)
      var (op, ($type $name:id | $type (op= $name:id $default) | (op= $name:id $default))+)

    - Returns value of last var

*** TODO types [5/7]
**** TODO fixed size int (int8, int16, ..., int128)
**** TODO signed/unsigned
**** DONE int
**** DONE float
**** DONE double
**** DONE structs
**** DONE bool

*** TODO strings [2/3]

**** DONE concatentate
     CLOSED: [2008-07-01 Tue 02:12]
**** DONE literals
     CLOSED: [2009-03-12 Thu 22:43]
**** TODO string type != char*

*** TODO structs [2/2]

**** DONE Simple case
     type IntArray
       int size
       int* elements
     end

**** DONE multiple members per line
     CLOSED: [2009-03-12 Thu 22:43]
     type Vector
       float x, y, z
     end

*** TODO enums [0/4]
**** TODO define them
     enum Primitive
       Triangles
       Quads
       Points
       Lines

**** TODO assign default values
     enum Primitive
       Triangles = GL_LINES
       Quads = GL_QUADS

**** TODO auto generated attribs
     Primitive.count :: int
     Primitive.cases :: list<string*int>

*** TODO unions
*** TODO operators for all basic types [3/5]
**** DONE map 'a § b' to 'a §_t b' for operator § and type(a) == type(b) == t
     CLOSED: [2009-03-22 Sun 23:56]
**** DONE infix +, -, *, /, **
     CLOSED: [2009-03-23 Mon 00:01]
**** DONE prefix/postfix ++, --
     CLOSED: [2009-03-23 Mon 00:01]
**** TODO ** for floats
**** TODO ++, -- for floats
*** TODO control structures [2/8]
**** TODO c-style for
**** TODO do/while
**** TODO do/until
**** TODO switch / case [1/2]
***** DONE basic switch/case
      CLOSED: [2009-03-12 Thu 23:36]
***** TODO support explicit fall-through

      switch someVar:
      @fallthrough case 1
        print "I"
      @fallthrough case 2
        print "I"
      case 3
        print "I"
      @fallthrough case 4
        print "I"
      case 5
        print "V"
      end

      oder

      switch x:
      case 1
        print "falling!"
        fallthrough
      case 2
        print "not falling"
      case 3
        print "blah"
      end

**** TODO break, continue
**** DONE if then/else if/else
**** DONE while
*** TODO pointers [2/4]
    using postfix notation

**** DONE &var
     CLOSED: [2009-03-12 Thu 23:38]
**** DONE var*
     CLOSED: [2009-03-12 Thu 23:38]
**** TODO (var+10)*
**** TODO global pointers
*** DONE functions [4/4]
**** DONE define them
     func RetType name(args)
       code
     end

     args ::=
     args ::= comma-seperated-list(arg)
     arg ::= Type name

**** DONE declare them
     func RetType name(args)
     // no impl
**** DONE call them

**** DONE function pointers
     CLOSED: [2008-07-31 Thu 20:10]
*** TODO Types [2/3]
    How types can be specified

**** DONE simple type name (int, float, MyStruct, ...)
     CLOSED: [2009-03-12 Thu 23:37]
**** DONE pointer by appending a star (int*, float*, MyStruct**, ...)
     CLOSED: [2009-03-12 Thu 23:37]
**** TODO signed(int), sint, uint, slong, ulong, ...

** zomp-ceepp
   Extension of cee, featuring an object system, type classes etc.

   - [ ] object system
     - [ ] virtual methods
     - [ ] override specifier
     - [ ] dynamic messages
     - [ ] mixins
   - [ ] type classes
     - [ ] explicit inlining/flattening/specialisation
   - [ ] overloaded methods

** zomp-miniml
   A minimalistic ml-like language featuring variant types and tuples

   - [ ] tuples
   - [ ] variant data types
   - [ ] pattern matching
   - [ ] constant vars
   - [ ] garbage collection?
   - [ ] modules?
   - [ ] type classes

*** Ideas
    int? => Option<int>

* Tasks                                                                   :zomp:

** Performance

   | What                | 1000 lines |   Speedup | 2000 lines |   Speedup |
   |---------------------+------------+-----------+------------+-----------|
   | Original 2008-09-27 |      5.537 |        1. |      7.220 |        1. |
   | Cache simpleAst     |      4.824 | 1.1478027 |      6.372 | 1.1330822 |
   | Cache addChild      |      4.357 | 1.2708286 |      5.960 | 1.2114094 |
#+TBLFM: $3=@2$2/$2::$5=@2$4/$4

** BUGS

*** TODO [#C] keine fehler ausgabe im prelude?                             :bug:
*** TODO [#B] bugs wenn innerhalb eines makros andere makros getriggert werden? :bug:
*** TODO [#B] sometimes macros can't be parsed at the toplevel (might be related to the macro expansion string fuckup) :bug:
*** TODO [#B] macro expansion failures in compiler but not toplevel (comments.zomp), getting weird characters :bug:
    scheint in der stdlib zu sein
    koennte daran liegen dass redefinitionen im compiler anders behandelt werden
*** TODO [#A] evaluating multipe expressions will ignore all but the last (iexpr) (sometimes) :bug:
*** TODO [#B]     store ptradd(buffer, 99) '\0' => llvm failure            :bug:
*** TODO [#B] ast:print( ${foo bar}, 0 ) => fails                          :bug:
*** TODO [#B]     store ptradd(indices, 4 * #num + 0) #a => fails to parse :bug:
*** TODO [#B]   store ptradd(vertArray, 3*num + 0) x => error (see below)  :bug:
*** TODO [#A] printString "foo\n" ignored newline on both sexpr and indent syntax :bug:
*** TODO [#A] char handling in macro expansion fucked up?                  :bug:
macro Cstring:forEachChar string char onChar
  uniqueId ptr "forEachChar"

  mret ${
    var char* ptr line
    while bool:not( char:equal(load(ptr), '\0') )
      var char chr load(ptr)
      printChar chr
      ptr = ptradd(ptr, 1)
    end
  end}
end macro

In macro expansion the \0 will be replaced by an !
*** TODO [#A] speichermanagement fixen!!! (ast.id wird manchmal geloescht.. im ocaml ffi?) :bug:

*** TODO [#B] check where `DefineVariable for void vars comes from
*** DONE [#A] "" is not parsed as a string
    CLOSED: [2008-01-11 Fri 01:28]

*** DONE [#A] Simple loops results in crash in REPL
    CLOSED: [2008-01-11 Fri 01:40]
    Cannot be reproduced anymore

    (func int main () (
      (label start)
      (branch start)
      (ret 0)
      ))

*** DONE [#B] Using OpenGL results in crashes
    CLOSED: [2007-12-31 Mon 03:25]

*** DONE [#A] gltest.cbe.c unter windows/linux testen
    CLOSED: [2007-12-31 Mon 03:26]

*** TODO [#B] locate cause of excessivly slow LLVM IR verification

*** TODO [#C] default value of global double vars is parsed incorrecly (1.0 is accepted but 1.0d not) :bug:

*** DONE [#A] emit warning on missing ret		:bug:
    CLOSED: [2007-12-04 Tue 02:35]

*** DONE [#A] BUG: (ret (load (ptradd (getField parent childs) index))) :bug:
    in function returning (ptr ast) is not accepted
   CLOSED: [2007-12-05 Wed 20:35]

*** TODO [#C] BUG: sometimes llvm source is printed on compiler errors unnecessarily :bug:

*** DONE fix toplevel "!" / abort expr			:bug:
    CLOSED: [2007-11-04 Sun 19:51]

** Design issues
*** DONE [#A] change ast representation? need a way to distinguish func and (func) :zomp:
    CLOSED: [2008-02-16 Sat 18:36]
    (foo bar) => (jux foo bar)
    Will be part of new parser

*** TODO [#B] support for const, const T* etc.?

*** TODO [#B] Turn more things into expressions
**** TODO if is not an expression
**** DONE Allow labels to be local to a scope? Turn if/for/.. into expressions this way?
     CLOSED: [2008-02-23 Sat 03:48]

     Local labels are not needed to turn if/for/.. into expressions

*** TODO [#C] place all external c functions in 'c' namespace?
   Export only functions defined in c namespace?
   Rename all other functions(?) like zomp_${name}

** Fix language quirks

*** TODO [#B] ast von cstring auf string umstellen

*** DONE [#A] linking multiple generated .ll files does not work :bug:
    CLOSED: [2007-12-20 Thu 02:53]
    (wrong linking attributes for function declarations?)
    more likely: stdlib.zomp are linked into stdlib.bc _and_ main.bc

*** DONE check return type in functions!		:improve:
    CLOSED: [2007-12-06 Thu 02:01]

*** DONE [#A] macros need a way to signal errors
    CLOSED: [2008-03-15 Sat 14:45]
    Repeat (compiler:error ...)?

*** TODO [#B] can't send antiquote to macro
    (xmacro twice arg (ret `((var int i 0) #arg (assign i 1) #arg)))
    (twice (printInt #i))

*** TODO [#B] int representations: 0xff 0b1001 etc.	:features:

*** TODO [#B] nested quotes and antiquotes don't work :bug:

*** DONE Allow getting pointer to variables

*** DONE Fix record support: allow writing to record fields
    CLOSED: [2007-10-06 Sat 21:36]

*** DONE Correctly parse ((ptr int) foo) in arguments/types
    CLOSED: [2007-10-08 Mon 01:45]

*** DONE Add support for characters
    CLOSED: [2007-10-09 Tue 23:51]

*** DONE Add support for arrays
    CLOSED: [2007-10-11 Thu 00:29]

*** DONE Disallow strings as constants in simpleform
    CLOSED: [2007-10-16 Tue 19:04]
    Let the expander turn them into global strings

*** DONE Use bindings / semantics checking in expander.ml
    CLOSED: [2007-10-16 Tue 19:04]

*** TODO [#B] Support more data types

**** DONE double
     CLOSED: [2007-11-26 Mon 01:26]

**** TODO unsigned ints

**** TODO int8/16/32

**** TODO c.int, c.short etc.

*** TODO [#B] Add instruction to free memory

*** TODO [#B] Support global pointers

*** TODO [#C] Methods are added to bindings twice
    func returns bindings where the functions is added twice

*** DONE [#A] Variadic macros
    CLOSED: [2007-11-04 Sun 19:52]
     (macro template name (rest args)
      (var (ptr ast) tree `(macro #name))
      (foreach arg in args
        (addChild tree arg) )
      (ret tree) )

    (template uniqueLabel name purpose (
      (var cstring #name (newUniqueNameFor #purpose)) ))

** Refactorings                                                   :refactorings:

*** TODO [#A] unit tests still use identifiers with dots (line 'int.add') - change this to colon (int:add) :refactorings:quick:
*** TODO [#B] reduce to llvm bindings and macros (mixed ocaml/zomp macro system for now) :refactorings:
*** TODO [#A] simplify all base language forms so only one syntax is allowed and support variants using macros :refactorings:
*** TODO [#B] move all builtin forms into zomp namespace (e.g. zmp:base:var etc.) :refactorings:
*** DONE [#B] rename modules of indent based parser and seperate them from the unit tests
    CLOSED: [2008-06-08 Sun 23:40]
*** TODO [#A] change all types to Capitalized case in stdlib
*** TODO [#B] Allow nested expressions in branch instruction

*** TODO [#C] Turn value type into polymorphic variant type

*** TODO [#B] zompc and sexprtoplevel should share evaluation code

*** TODO [#A] Change expander.ml: dispatching only done by the expression's id
    Then make all operations available as fake-macros (zmp:compiler:macroExpand etc.)

** Testing

*** TODO [#C] generate more realistic compiler performance tests
    (use macros and functions which are not defined just two lines ago)

*** TODO [#B] check return values of tests/*.zomp
    Rename files to foo.ret100.zomp, then check whether running foo returns 100

** Parser / Syntax                                               :parser:syntax:
*** TODO smalltalk-style grouping mit keyword: arguments

    Keyword identifer a la 'foo:' brechen expression in teile

    print "oh noes" unless: everything.ok()
    =>
    (opkeyword leading (jux print "oh noes") unless (op. everything (opcall ok)))

    do: some stuff until: endCondition
    =>
    (opkeyword do (jux some stuff) until endCondition)

*** TODO [#A] if (*addF)(3, 4) > 10
    => jux (preop* addF) (op> (op, 3 4) 10)
    Sollte aber jux if (op> (opcall (preop* addF) 3 4) 10) sein

    Regeln fuer jux/call aendern? Doch jux hoechste Prioritaet geben und Klammern verwenden?
    Oder {} fuer Prioritaet?

    Oder einfach addF(3,4) in einen function call umwandeln wenn addF ein function pointer ist

**** Zu Bedenken:

    let x + y = ...
    if cond(arg) then ...

    sin x + cos y

**** Evtl
     if: expr* then: expr*

     visitTree: tree onLeaf: leafF onNode: nodeF

     for: i in: 10 .. 20 do: print i; println()

**** foo {bar baz} dann um jux zu bekommen?
**** Neues Token fuer calls einfuehren?
    foo bar (a b) => ID(foo) ID(BAR) OPEN_PAREN ID(a) ID(b) CLOSE_PAREN
    foo bar(a b) => ID(foo) ID(bar) ARGS_BEGIN ID(a) ID(b) CLOSE_PAREN

    foo bar (a b) => jux (id foo) (id bar) (jux a b)
    foo bar(a b) => jux (id foo) (call bar (jux a b))

*** TODO [#A] list<int> => template, xml <node> -> xml like trees

*** TODO [#B] infix/postfix/prefix operatoren: bezeichnen als _+_ _+ +_? :operators:
    oder auch \+\ \+ +\

*** TODO [#B] operatorsymbol am zeilenanfang/ende = pre/postfix operator fuer ganze zeile? :operators:

   > equals(int a, int b) =
   <=>
   (postfix= (funcall equals (int a) (int b)))

   > | [1,2,3] => foo

   (prefix| (infix=> (op[] 1 2 3) foo))

   loesung fuer pattern matching

   > match lst with
   >   | [1,2,3] => handle123()
   >   | [1,2,3,4] => handle1234()
   >   | _ => handleOther()

*** TODO [#B] indent parser: support escaped linebreaks (\ at beginning/end of line) :quick:

*** TODO [#B] only allow one dot in ids (and none at a later point)      :quick:
*** TODO [#B] support "\"" in strings
*** TODO [#A] add += -= *= /= etc. operators                         :operators:
*** TODO [#A] / should be left associative: a / b / c => (a / b) / c       :bug:
*** TODO [#B] parser: keep track of line and char number and add this to error messages

*** Archive                                                            :ARCHIVE:
**** DONE [#A] indent parser: skip comments
     CLOSED: [2008-06-04 Wed 02:52]
     :PROPERTIES:
     :ARCHIVE_TIME: 2008-07-09 Wed 14:49
     :END:
**** DONE [#A] indent parser: skip comments
     CLOSED: [2008-06-04 Wed 02:52]
     :PROPERTIES:
     :ARCHIVE_TIME: 2008-07-09 Wed 14:49
     :END:
**** DONE [#A] indent parser: strings
     CLOSED: [2008-06-04 Wed 02:52]
**** DONE [#A] parse logical ops &, |, &&, ||
     CLOSED: [2008-04-14 Mon 01:17]
     :PROPERTIES:
     :ARCHIVE_TIME: 2008-07-09 Wed 14:49
     :END:

**** DONE [#A] prio fuer call(a,b,c) analog zu operator precedence loesen? (ala multExpr, addExpr) :parser:
     :PROPERTIES:
     :ARCHIVE_TIME: 2008-08-17 Sun 19:23
     :END:

**** DONE [#A] foo(bar baz) auch als call parsen?
     :PROPERTIES:
     :ARCHIVE_TIME: 2008-08-17 Sun 19:23
     :END:
** Compiler

*** TODO [#B] proper support for compile time variables               :compiler:
    Use normal variables for now

*** TODO [#B] disallow identifiers which only differ in capitalization (unless for type/function, e.g. if they denote different kinds of elements?) :compiler:quick:
*** TODO [#A] give additional info if a name resolves to something of the wrong type (expected type but found function etc.) :compiler:quick:
*** TODO [#A] better error message on invalid typedef           :compiler:quick:

*** TODO [#B] stack basiertes system fuer settings/bindings im macro expander

*** TODO [#B] gencode in zomp umstellen
   (zeiger durch abstrakten typ darstellen)
   http://www.linux-nantes.org/~fmonnier/OCaml/ocaml-wrapping-c.php#ref_ptr
*** TODO [#A] error on redefining vars
*** TODO [#A] error when redefining symbol with different number of arguments
*** TODO [#A] error when local var is redefined
*** TODO [#A] no segfaults when redefining local variables
*** TODO [#A] allow uninitialized vars
*** TODO [#A] allow (var foo x) where the type of var is propagated
*** TODO [#B] warnings on unused variables
*** TODO [#B] compileperf.zomp  mit 16k funktionen profilen
*** TODO [#A] support abstract types (which may be only used through pointers)
*** TODO [#A] rename local macros
*** TODO [#A] constants for float nan, pos & neg infinity
*** TODO [#A] stringlit / op""

    macro stringlit string
      static var (ptr char) stringStorage string
      stringStorage

*** TODO [#B] llvm assertion error on record argument
*** TODO [#A] support toplevel/static expressions which will be moved from inside a function to the top level
*** TODO [#B] allow record with only 1 field
*** TODO [#A] convert char to int / float
*** TODO [#A] (var (ptr float) foo) => better error message instead of expr: /0/ :bug:
*** TODO [#A] support records as first class var types
    (allow them to be params, retvals, local vars, global vars)
*** TODO [#A] fix initialization of global vars
*** TODO [#A] support global pointers                                      :bug:
*** TODO [#A] typechecking fails on (func nonvoid ... (if cond (ret a) (ret b)) ) :bug:
*** TODO [#A] support paths for include / import / etc.
*** TODO [#B] refactor: make all compiler functionality available from zomp expressions
*** TODO Indent-sensitive syntax

**** DONE [#B] iexpr does not ignore empty lines preceeding unindents
     CLOSED: [2008-01-14 Mon 17:24]

**** TODO [#B] iexpr does not fail correctly on "class Foo ... end blah" etc.

**** TODO [#B] iexpr ignores last line of not followed by a newline char

**** TODO [#B] Comments need to be handled / skipped

*** DONE [#A] arguments in function don't match: tell which argument(s) failed
    CLOSED: [2007-12-27 Thu 01:45]

*** TODO Codegen in zomp

**** TODO Bindings for LLVM IR
**** TODO Define base language (from current definition)
**** TODO Base lang -> LLVM IR translation
**** TODO ast type system?

*** DONE [#A] type errors: show expected and found type
    CLOSED: [2008-01-11 Fri 19:18]

*** TODO [#B] use llvm ocaml bindings for code generation
    check whether this makes IR-verification faster / prevent bugs / ...

*** DONE compilation needs O(n^2) time
    CLOSED: [2007-12-20 Thu 02:54]

*** DONE [#A] performance probleme fixen
   CLOSED: [2007-12-20 Thu 02:54]

*** TODO [#B] compiling is extremely slow

*** TODO [#C] Generate nice and readable LLVM code

**** TODO [#C] Let functions in genllvm.ml return a string list instead of strings with newlines

**** TODO [#C] Add empty line(s) between functions

**** TODO [#C] Fix useless newlines which appear on some operations

**** DONE Fix missing line breaks
    CLOSED: [2007-09-28 Fri 23:17]

*** TODO [#C] Add a c backend which generates nice and readable code

*** TODO [#C] Bug: (func int main () 20) does not compile :bug:
    But (func int main () ((ret 20))) does as well as (func int main () ((printInt 10) 20))

*** TODO [#C] Bug: some generic intrinsics might return invalid bindings :bug:
*** DONE [#A] parse 1.0f as float
    CLOSED: [2008-01-16 Wed 01:20]

** Interactive toplevel

*** TODO [#B] support functions returning non-void on toplevel
*** TODO [#A] better error reporting on immediate code execution in toplevel
*** TODO [#B] macro/function to check whether running in toplevel        :quick:
*** TODO [#A] add (ret void) to end of immediate functions in toplevel   :quick:
*** TODO [#B] print nice struct names on !bindings (same as on !writeSymbols) in toplevel
*** TODO [#A] using invalid floating point constant will screw up LLVM for whole session :bug:
*** DONE [#A] allow immediate execution of code
    CLOSED: [2008-02-12 Tue 02:52]

*** TODO [#B] proper error reporting when function/macro is redefined with different parameter count/types
*** TODO [#B] let toplevel send feedback to emacs + handle errors (abort eval etc.)

*** TODO [#B] fast navigation

*** TODO [#B] zomp toplevel in emacs: don't switch to buffer on C-c,C-s

*** DONE print var/func/macro declaration in toplevel
    CLOSED: [2007-12-03 Mon 01:25]

*** DONE make printing parsed s-expr optional
    CLOSED: [2007-12-03 Mon 01:25]

*** DONE Create C interface
    CLOSED: [2007-09-30 Sun 01:53]
    Reuse native function generator from opengl bindings(?)

*** DONE Create inferiour llvm machine
    CLOSED: [2007-09-30 Sun 01:53]
    Startup llvm jit machine, allow vars + functions to be (re)defined, allow functions to be called

*** DONE Read-Eval-Print loop
    CLOSED: [2007-09-30 Sun 01:53]

*** DONE Make it run stable and be usable
    CLOSED: [2007-10-03 Wed 03:33]

*** [#B] Support loading DLLs and calling their functions

**** DONE Load DLLs
     CLOSED: [2007-11-04 Sun 03:35]

**** DONE Call functions in them
     CLOSED: [2007-11-04 Sun 03:35]

**** TODO [#C] Add search paths

*** TODO [#B] Fork to avoid crashes

**** TODO [#B] Find a way to keep connection to stdin on crash in other process

*** DONE Change/reevaluate functions
    CLOSED: [2007-10-09 Tue 16:20]

*** TODO [#C] Redefine/change variables

** Emacs support

*** TODO [#A] folding -> hs-special-modes-alist
*** TODO [#B] indent: ignore parens in strings
*** TODO [#B] zomp-newline: problem with indent (resetting pos)
*** TODO [#B] emacs/toplevel: C-c C-s abfangen wenn toplevel schon laeuft
*** TODO [#C] examples which can be browsed directly in emacs
*** TODO [#B] correctly indent }
*** TODO [#C] zomp: fast doc lookup
*** TODO [#B] emacs: backspace should delete autoinserted text in one step
*** TODO [#B] highlight '"' correctly in emacs (don't interpret this as the beginning of a string)
*** TODO [#B] also auto-insert // on newline
*** TODO [#B] /// <enter> <backspace> -> remove inserted ///
*** DONE [#A] don't move cursor on indent. then integrate zomp-tab into zomp mode
    CLOSED: [2008-02-21 Thu 14:24]
*** TODO [#C] alt-k => mark current word first, then sexpr
*** TODO [#C] emacs: navigate to error caused by evaluating code in toplevel
*** TODO [#C] fix wrong promts in emacs inferior zomp mode
*** TODO [#C] emacs indenting: ignore parens in comments
*** TODO [#B] (op+_d | => zomp eldoc does not work

*** DONE [#A] eldoc: struct* als name* und nicht als ((type1 field1) (type2 field2)..)* anzeigen
    CLOSED: [2008-01-11 Fri 17:17]
*** TODO [#B] a line cannot be uncommented using ctrl-\ if the // does not start at pos 0
    temporary fix: zomp-mode will now use /* ... */ instead of //

*** TODO [#C] fix indent of }

*** TODO [#C] fix cursor positioning on indent

*** TODO [#B] indent: special treatment for lines containing only closing parentheses?

*** TODO [#B] add hook to zomp-mode

*** TODO [#B] Flymake support

*** DONE Start zomp toplevel in emacs
     CLOSED: [2007-10-16 Tue 22:11]

*** DONE Send current region/buffer to toplevel
     CLOSED: [2007-10-16 Tue 22:11]

*** DONE Send current function toplevel
     CLOSED: [2007-10-16 Tue 22:11]

*** DONE [#B] zomp.el eval current: go one char forward to capture *cursor.pos*(func foo...)
     CLOSED: [2007-11-16 Fri 02:33]

** Macros

*** TODO [#B] konfigurierbare base language
    macroExpand :: [Ast] * Bindings -> [Instruction]
    translate :: [Ast] * Bindings -> Bindings

    enum Symbol:
      Instruction : Ast * Bindings -> Bindings
      Variable :Type
      Function :Args * Type
      Macro : Ast * Bindings -> [Ast]

    type Bindings:
      Id => Symbol

    Gibt am Ende AST zurueck der nur noch aus Instructions besteht
    Kann dann auch zum kompilieren von Shadern benutzt werden

*** TODO [#B] implicit arguments for macros (source location from where it was invoked etc.)
*** TODO [#C] hygienic macros: ast* qualify(ast*, bindings) will fully qualify all identifiers in the given ast
*** TODO [#A] better error message on `(ret `(...)) in macro
*** TODO [#A] protect against recursive macro invocations
*** TODO [#A] `(#foo a b c) should turn into (fooValue a b c) instead of (seq fooValue a b c)
    Reevaluate!
    (at least if foo does not have any arguments)

*** TODO [#B] macro/template: warnung wenn `(a b c) a/b/c gleichzeitig parameter/lokale vars sind und ohne antiquote verwendet werden

*** TODO [#A] name collisions of macros and functions (?) causes problems
Put macro functions into seperate module

*** TODO [#B] Hygienic macro support?
*** Archive                                                         :ARCHIVE:
**** DONE Allow definition of simple "template" macros
     :PROPERTIES:
     :ARCHIVE_TIME: 2008-04-14 Mon 01:34
     :END:

**** DONE Allow running code inside macros
      CLOSED: [2007-10-29 Mon 15:48]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:

**** DONE Query existing functions and variables
      CLOSED: [2007-11-16 Fri 02:33]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:

**** DONE Write "for i min max" macro
      CLOSED: [2007-11-02 Fri 02:50]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:

**** DONE Write "if then else" macro
      CLOSED: [2007-12-04 Tue 00:23]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:

**** DONE Allow macros to call any ordinary function
      CLOSED: [2007-11-02 Fri 02:50]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:

**** DONE Insert astFromInt or astFromString if a var/func returns int/string
      CLOSED: [2007-11-02 Fri 02:46]
     :PROPERTIES:
      :ARCHIVE_TIME: 2008-04-14 Mon 01:35
     :END:

** Language / APIs

*** TODO Misc

**** TODO [#C] subseq "foo" -2 => "oo", subseq "foo" 2 => "fo" etc.       :libs:
**** TODO [#A] int to char conversion                               :libs:quick:
**** TODO [#A] (include ..) should support iexpr syntax             :libs:quick:
**** TODO [#B] runtime checks generieren
**** TODO [#C] `undefineAll()' => alle namen in den bindings werden undefined. nuetzlich um config dateien als zomp source zu parsen und mit makros zu interpretieren
**** TODO [#C] `undefine name' => name kann nicht mehr verwendet werden

**** TODO [#B] tuples: var (int, float) x => x.0 : int, x.1 : float

**** TODO [#B] motivation: automatische printer

     type Point:
       float x, y

     Point.derive Printer, XMLSerializer

     => print, toXML, fromXML Methoden generieren

     codeDeriver = Type -> [toplevelExpr]

**** TODO [#B] extended var                                              :quick:
     - should be able to create multiple variables like 'var int x, y = 10, z'
     - should return the variable's value so it can be better used inside control structures
       while (var int x = foo())
         println(x)

**** TODO [#B] motivation: powerful asserts
   assert x < 10
   => Fehlermeldung mit Wert von x
   "Assertion 'x < 10' failed, x = 11 @file.zomp:101"

**** TODO [#C] array/list comprehensions

**** TODO [#A] yield

**** TODO [#B] GC using macros
    Support classes to be GC-collected

    gcclass Foo
      ...

    gcclass Bar
      int x
      Foo* target

    =>

    class PointerInfo:
      list<offset> pointers

    class GarbageCollected:
      PointerInfo* pointerInfo
      static list<GarbageCollected> roots

    class Bar extends GarbageCollected:
      int x
      Foo* target
      Bar* other

      static PointerInfo classPointerInfo
        pointers = [offset(target), offset(other)]

      constructor():
        pointerInfo = &classPointerInfo

    void garbageCollection()
      // mark+sweep all roots and their target pointers

**** Archive                                                           :ARCHIVE:
***** DONE [#B] define operator funcs in indent syntax (func l == r ...)
      CLOSED: [2008-07-09 Wed 14:50]
      :PROPERTIES:
      :ARCHIVE_TIME: 2008-07-09 Wed 14:50
      :END:
*** TODO [#A] API for code analysis
    Get information about an expression: types etc.
    (can be used for type propagation)

**** std:kernel
        Builtin primitives in a seperate module
        label, branch
        type
        var, const
        func
        macro

**** std:ast
        ast representation

        type Type
          String name

          isIntegerType() -> bool
          isFloatType() -> bool
          +-isString() -> bool-+
          isRecordType() -> bool
          isRecordType() -> bool

          isSubType(Type*) -> bool

**** std:ast:reflection
        type, typeOf(ast)

**** std:ast:detect
        isLabel, isBranch, ...

**** std:ast:annotations
        // Query annotations
        ast.hasAnnotation name

**** std:bindings
     // Query for bound names

     type Var
       String name
       Type type

     type Macro
       String name
       Array<String> args
       Bool isVariadic

     type Func
       String name
       Type resultType
       Pair<String, Type> args

     lookupVar(string) -> Option<Var>
     lookupMacro(string) -> Option<Macro>
     lookupFunc(string) -> Option<Func>
     lookupType(string) -> Option<Type>
     lookup(string) -> Variant<Var(Var), Func(Func), Type(Type), Macro(Macro), Undefined>
*** TODO [#A] rename "template" to "rewrite"
*** TODO [#A] Pattern matching

**** On sexpr/ast

     ast:match ast matchExpr

     matchExpr ::= case matchCase => code

     matchCase ::= pattern
     matchCase ::= var = pattern
     matchCase ::= var varName : type

     pattern ::= "expectId"
     pattern ::= (matchCase+)

**** Overloaded match macro

     match foo matchExprs+
     => typeOf(foo):match foo matchExprs+
*** TODO [#A] support for GL_RGBA32F_ARB etc.
*** TODO [#A] remove new macro in glutils, replace by new macro from shprog (move it to stdlib)
*** TODO [#A] Explicit polymorphism

    Overloading functions should be possible

    Requires the API for code analysis (see above)

**** API

    overloadable name

    overload name(param*) targetName

    param ::= type typeName
    param ::= ast

**** Example

    overloadable print
    overload print(type int) printInt
    overload print(type string) printString

**** Utils

    overloadable plus

    ofunc int plus(int l, int r) impl
    =>
    func int plus_int_int(int l, int r) impl
    overload plus(type int, type int) plus_int_int

*** TODO [#A] Some simple generic/C++-style-template support

**** std:generic

  type (param+) name decl
  => macro name, expanding into expandType

  expandType name (param+)
  => std:toplevelExpr
       std:kernel:type name decl'
  where decl' is decl with substituted type params
  (only generate type once)

  func (typeParam+) name (param*) impl
  => macro name (param*), translating into expandFunc

  expandFunc (typeParam+) name
  => func name (param*) impl
  with substituted types (and functions?)

*** TODO [#A] type classes

**** alternative instanz als keyword argument?

   typeclass Comparator<T>:
     bool compare(T, T)

   func void sort<Comparator T>(Array<T>* array)
     ...
   end sort

   instance less Comparator<int>:
     bool compare(int l, int r) => l < r

   instance greater Comparator<int>:
     bool compare(int l, int r) => l > r

   sort(intList)
   sort(intList, Comparator: greater)
*** TODO [#B] framebuffer cleanup/releasing code
*** TODO [#B] macros to get current file/line/column
*** TODO [#B] imperative control structures
    See also zomp-ce

**** DONE [#A] if/then/else
     CLOSED: [2008-06-04 Wed 02:43]

**** TODO [#B] for min to/downto/upto max
**** TODO [#B] loops mit break + continue
**** TODO [#C] loops mit broken/exhausted

   (von converged)
   for <expression>:
     ...
   exhausted:
     ...
   broken:
     ...

   exhausted block wird aufgerufen wenn loop durch ist
   broken wird aufgerufen wenn per break abgebrochen wurde
   continued ~

**** TODO [#C] finally
   begin
     code
   finally
     code
   end

**** TODO [#C] allow variable definitions within expressions?
   while (var int x = foo()) > 10
     print(x)
*** TODO [#C] check for off-by-one error in shbase function calculation
*** TODO [#C] glfw bindings auf 2.6 updaten

*** TODO [#B] Regular expressions
**** TODO [#A] Bindings for PCRE
**** TODO [#B] Special match syntax

*** TODO [#B] File I/O
**** TODO [#A] Bindings for C stdlib
**** TODO [#C] Systems of streams similar to Java/.Net/...

*** TODO [#B] Allow testing macros
    (running them on code and printing the resulting AST)

*** TODO [#B] Object system

**** vtable calls

     class Foo
       Foo(int arg) / constructor(int arg)
       var int x
       method float bar (int y) barImpl

     =>

     type Foo:vtable
       (Foo* -> void)* destructor
       (int -> float)* bar

     type Foo
       Foo:vtable* vtable
       int x
       (int -> float)* bar

     func float Foo:bar(Foo* this, int y)
       barImpl

     macro bar (var Foo f) y
       f.vtable.bar( f, y )

     func Foo:constructor(Foo* this, int arg)
       this.vtable = & Foo:vtable


     new Foo(args*) => (Foo* f = malloc Foo; Foo:constructor(f, args); f)

**** Interfaces

**** Inheritance

**** Syntax support

     Is anything special needed?

**** Represent them in zomp ast type <- what does this mean? :)

**** Message passing (on top of this)

**** Type classes / concepts based on classes? Reusing infrastructure?

**** mixins

*** TODO [#C] Compile multi file projects

**** Realize definition of project files
     A central project file which will list all linked in modules,
     settings etc.

     "zompc project.zomp release" should be enough to build the whole project

**** Define .zobj format

*** TODO [#A] named params: copy(from: file1, to: file2)

    foo: bar baz
    <=>
    (postfix: foo (bar baz)

    > :foo:bar
    prefix: fuer global namespace (nicht als operator definieren?)

    zomp:core:add
    infix: fuer namespaces

    auch sowas:?

    obj print: "fooo" to: stderr
    (jux (op: print "foo") (op: to stderr))

    (foo bar) op: blah
    (seq (jux foo bar) (op: blah))


*** TODO [#A] Tests
    einheitliches system fuer tests

*** TODO [#C] Exceptions

**** TODO [#C] exceptions: restartable conditions

**** TODO [#C] Specify exceptions using attributes?

    file = @(cfa:disable fileIsOpen) openFile "foo"

*** TODO [#A] Namespaces/Package/Module/Project System

**** TODO [#A] import push => stackPush, pop => stackPop from eve.da
**** TODO [#A] allow replacing parts of libraries
**** TODO [#A] versioned packages
**** TODO [#A] zugriffsrechte per ACLs: auch fuer class member / einzelne parameter?

*** DONE [#A] template
    CLOSED: [2007-11-24 Sat 20:12]
    Implemented as macro

*** DONE [#A] OpenGL support
    CLOSED: [2007-11-25 Sun 00:35]

** Public

*** TODO [#C] provide a (semi) public git repo

*** TODO Find collaborators

** Syntax

*** Issues
**** TODO [#A] how to parse "var x = 10"? (op= (var x) 10), (var (op= x 10))? parse (var: x = 10) as (var (op= x 10)) but (var x = 10) as (op= (var x) 10)?


**** TODO [#A] (count-1) is being parsed incorrectly

* Notes                                                                   :zomp:

** Alternative names

   There exist several brands and companies of the name "zomp". Thus alternatives should be considered.

   zump - only name which sounds more stupid than zump :)
   zompl - zero overhead meta programming language
   baremp - bare metal meta programming / bare metal programming
   bmmp
   llmp - low level meta programming
   lowmp
   zoml - zero overhead meta language
   0mp
   roomp

   self-assembly, or something inspired from nano technology?
   moleculang
   submicron
   microstruct
   meso-lang
   monolayer
   monolang
   mesolayer
   membrane
   metalipid
   nanolang, microlang, zeptolang

** Type annotations
Annotate types using meta data?

let @type(int) x = 10

Use : as infix operator (: symbol type) as a macro name:

macro inf_: symbol thetype = {
  @type(thetype) symbol
}

then:

let x :int = 10

** ; / expression separation
   Let ; be an operator/macro?

   print "1+1="; print 2;

   =>

   (op; (print "1+1=") (print 2))

   ;-macro evaluates each expression + returns value of the last one
   (problem: requires macro expansion at run time. maybe instead create a sequence expression (evalseq (print "1+1=") (print 2)) and return that?)

   Then monads are probably possible without expanding the syntax (and possibly even without any/too much runtime overhead because no closures need to be passed around)

** Annotations

   See the declare statement in lisp

   Use @attrib( valueExpr ) syntax?

** python's doctest clone
   automatically check embedded examples in documentation for correctness

** Type System

*** TODO [#C] unique/linear types
   - nach erzeugung linear, bis das erste mal eine zuweisung passiert
   - mit pattern matching bzw. on-the-fly typanpassung?
   - funktionen beeinflussen linear eigenschaft?

*** Composable type system?

**** multiple lanes/rails/...

     - independent from each other
     - type checking done on each of them

     - default property: shape (binary representation)

*** Arithmetic types (sum, product types)
*** Generic types
*** How much in kernel language, how much as macros?

*** checked/unchecked vars im type system (checked = auf konsistenz usw. geprueft)
    Als ADT realisieren?

*** pointer + vars mit scope level parametrisieren, dann bei ptr = &foo nur erlauben wenn scopelevel von ptr <= scopelevel(foo)
   (siehe cyclone, ada)

*** function types: (int,float)->float, float->int, ...

*** refinement types?
*** research: macros and formal verification

*** Security level
    A variable a has an associated security level l(a). Writing a := b requires l(b) >= l(a).
    Similarily, the relation of security levels between function's arguments and parameters can be declared.
    Might allow to do flow analysis.
    See http://cristal.inria.fr/~simonet/soft/flowcaml/manual/fcs003.html#toc5

*** linear types?

*** control flow analysis

    cfa:invariant bool fileIsOpen
      require false on: ret message: "File should be closed"
      set true on io:openFile
      set false on io:closeFile
    end

    func foo()
      file = openFile "blah" (1)
      if( cond )
        closeFile
      else
        do stuff // (2)
      end
    end func

    =>

    Error:dummy.zomp:(2): File should be closed
      cfa:invariant fileIsOpen set to true on line (1), expected to be false on ret

** Packages / Projects
*** compilation model
**** Use an VM-only approach?
     Only operation mode is having a VM which can load and execute code
     Compiling static executables works by "dumping" code
**** Distinguish imports for runtime functions from those for macros?
     "import FunctionProvider" will import functions from FunctionProvider
     "usesyntax MacroProvider" will import macros and functions for compile time, only?

     - Does this work? Is it neccessary at all?
     - Is it possible simply to strip unneeded functions on link-time?

*** packages
*** project layout
    one toplevel file, drawing in all libs, settings etc.

    project.zomp

      application RadiositySolver

      libpath ./extlib
      require ./extlib/*
      replaceLib std.strings with extlib.unicodeStrings

      sourcepath ./src
      sources
        src/utils/*.zomp


** Readings
*** ruby syntax, fortress syntax fuer nested function calls             :syntax:
*** haskell's Data.Map.lookup function: nice way to adapt the failure-handling behaviour to the calling code's policy

* Footer

** Keep flyspell happy
 LocalWords:  AST IR VM Zomp zomp simpleform expr var boundsCheck alloca SSA
 LocalWords:  bytecode  Ast ast


