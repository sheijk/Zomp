///
/// A very simple library for persistence. Allows to store hierarchical mappings
/// between string keys and string values into a file
///

requireLibs libcee stdio utils

struct Section:
  cstring name
  // <cstring>
  StringMap* settings
  // <Section>
  StringMap* subsections
end

func void Section:init(Section* this, cstring name):
  this.name = name
  this.settings = StringMap_new()
  this.subsections = StringMap_new()
end

func void* zompParse(cstring source)
func ast* parseZompSource(cstring source):
  ret (cast ast* zompParse(source))
end

func char* findOneOf(char* buffer, char* delims, bool inverted):
  pos := buffer
  while (!isNull(pos) && pos* != '\0'):
    foundDelim := false
    currentDelim := delims
    if isNotNull(delims):
      while (currentDelim* != '\0'):
        if (currentDelim* == pos*):
          foundDelim = true
        end
        ++currentDelim
      end
    end

    if (foundDelim != inverted):
      ret pos
    end

    ++pos
  end

  ret nullptr(char)
end

func char* findFirstIn(char* buffer, char* delim):
  ret findOneOf(buffer, delim, false)
end

func char* findFirstNotIn(char* buffer, char* delim):
  ret findOneOf(buffer, delim, true)
end

func char* copyStringRange(char* start, char* end_):
  // TODO well.. if we had pointer substraction right now..
  pos := start
  count := 0
  while (pos != end_):
    ++count
    ++pos
  end

  buffer := malloc char (count+1)
  strncpy(buffer, start, count)
  buffer[count] = '\0'
  return buffer
end

func void Section:loadFrom(Section* this, cstring fileName):
  buffer := nullptr char
  loadResult := zompLoadFileToMemory( fileName, &buffer )
  return if: loadResult < 0
  onReturn dealloc(buffer)

  pos := buffer
  while !(isNull(pos) || pos* == '\0'):
    tokenStart := findFirstNotIn(pos, " \n")

    tokenEnd := findFirstIn(tokenStart, " =")
    name := copyStringRange tokenStart tokenEnd

    tokenStart = findFirstNotIn(tokenEnd, " =")
    tokenEnd = findFirstIn(tokenStart, " \n")
    value := copyStringRange tokenStart tokenEnd

    if (name* != '\0' && value* != '\0'):
      StringMap_insert this.settings name (cast void* value)
    else:
      dealloc value
    end

    dealloc name

    pos = tokenEnd
  end
  return
end

func void Section:writeTo(Section* this, cstring fileName):
  file := fopen(fileName, "w")
  return if: isNull(file)
  onReturn closeFile(file)

  range := StringMap_range this.settings
  while StringMapRange_hasNext(range):
    name := StringMapRange_key(range)
    value := cast cstring StringMapRange_value(range)

    writeCString(file, name)
    writeCString(file, " = ")
    writeCString(file, value)
    writeNewline(file)

    StringMapRange_next range
  end
  return
end

func int main():
  s := new Section "testing"
  Section:loadFrom s "examples/test.cfg"
  StringMap_debugPrint s.settings
  StringMap_debugPrint s.subsections
  Section:writeTo s "examples/test2.cfg"
  dealloc s

  code := parseZompSource "a + b * 3 c"
  ast:print code 2

  ret 0
end

