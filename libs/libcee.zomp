/**
 * Libraries providing a C like feel

!verify off
!syntax indent
 */


///-----------------------------------------------------------------------------
/// Section: Untested
///-----------------------------------------------------------------------------

///
/// Declares a function. Use this to prevent emacs indentation in next line :)
///
template funcd rettype nameAndArgs
  func #rettype #nameAndArgs
end

template macro:failUnless cond
  unless #{cond}
    ret ${error expression is false #{cond}}
  end
end

macro uniqueIds purpose ids...
  var ast* code ${seq}

  forEachAstChild child ids
    ast:addChild code ${uniqueIds #child #purpose}
  end

  ret code
end

template op| l r
  int:or #l #r
end

template op& l r
  int:and #l #r
end

macro op|| l r
  uniqueId result "||"

  ret ${
    #result := false
    if #l
      #result = true
    elseif #r
      #result = true
    end
    #result
  end}
end

macro op&& l r
  uniqueId result "&&"

  ret ${
    #result := false
    if #l
      #result = #r
    end
    #result
  end}
end

template op==_str left right
  strcmp(#left, #right) == 0
end

template op!=_str left right
  strcmp(#left, #right) != 0
end

macro op:= name value
  if (getField(name, childCount) == 0)
    ret ${var2 #name #value}
  end
  ret ${error "Expected a single identifier on left hand side" ${#name := #value}}
end

// macro dummy l r
//   printlnString "applying dummy"
//   ret ${foo bar}
// end
// 
// func void p2(ast* l, ast* r)
//   printlnString "should do something now.."
// end

/// Given an ast and an ast containing placeholders _/__ the
/// shapes of both ast's are matched against each other. They match if they have
/// the same name, same number of children and all their children are matching.
///
/// The _ placeholder matches expressions without children (like 'a') while
/// the __ placeholder matches any other ast
/// _... as last argument means any number of parameters
///
/// Examples:
///   ast:matchesShape ${foo bar} ${foo bar} => true
///   ast:matchesShape ${a b c} ${__} => true
///   ast:matchesShape ${foo (some child) bar} ${foo __ bar} => true
///   ast:matchesShape ${a b} ${a} => false
///   ast:matchesShape ${a b c} ${a b} => false
///   ast:matchesShape ${a b} ${a b _} => false
///   ast:matchesShape ${a _...} ${a 1 2 3 4} => true
///
func bool ast:matchesShape(ast* codeArg, ast* templateArg)
  var ast* code codeArg
  var ast* template templateArg

  assert (template !=_ptr nullptr ast)
  assert (code !=_ptr nullptr ast)

  var cstring templateId getField(template, id)
  var int templateChildCount getField(template, childCount)
  var cstring codeId getField(code, id)
  var int codeChildCount getField(code, childCount)

  when (bool:and (templateId ==_str "_") (codeChildCount == 0))
    ret true
  end

  when (templateId ==_str "__")
    ret true
  end

  varargs := false
  lastChild := nullptr ast
  if (templateChildCount > 0)
    lastChild = ast:child template (templateChildCount - 1)
    assert (lastChild !=_ptr nullptr ast)
    if ((getField(lastChild, childCount) == 1) && (getField(lastChild, id) ==_str "postop..."))
      var ast* lastChildChild ast:child(lastChild, 0)
      var cstring lastId getField(lastChildChild, id)
      varargs = ((lastId ==_str "_") || (lastId ==_str "__"))
    end
  end

  if varargs
    if ((codeChildCount >= templateChildCount - 1) && (codeId ==_str templateId))
      for childNum2 0 (templateChildCount - 1)
        unless (ast:matchesShape (ast:child code childNum2) (ast:child template childNum2))
          ret false
        end
      end
      ret true
    end
  else
    if ((codeChildCount == templateChildCount) && (codeId ==_str templateId))
      for childNum 0 codeChildCount
        unless (ast:matchesShape (ast:child code childNum) (ast:child template childNum))
          ret false
        end
      end
      ret true
    end
  end

  ret false
end

///
/// Will return code to get the address of the denoted element
/// Accepts code of the form id(.id)*
/// Also accepts array expressions like foo[10]
/// Will probably evolve into a general way to get the address of a
/// left hand side expression
///
/// Example:
///   getMemberAddress(${a.b.c}) => (fieldptr (fieldptr a b) c)
///
func ast* getMemberAddress(ast* code)
  if (getField code childCount == 0)
    ret ${ptr #code}
  elseif ast:matchesShape(code, ${_._})
    recordExpr := ast:child(code, 0)
    fieldName := getField ast:child(code, 1) id
    ret ${fieldptr #recordExpr #fieldName}
  elseif ast:matchesShape(code, ${__._})
    nestedPtr := getMemberAddress ast:child(code, 0)
    fieldName2 := getField ast:child(code, 1) id
    ret ${fieldptr #nestedPtr #fieldName2}
  elseif ast:matchesShape(code, ${__._[__]})
    structExpr := ast:child code 0
    memberName := getField ast:child(ast:child(code, 1), 0) id
    indexExpr := ast:child(ast:child(code, 1), 1)
    memberPtr := getMemberAddress(${#structExpr.#memberName})
    ret ${ptradd (load #memberPtr) #indexExpr}
  elseif ast:matchesShape(code, ${_[__]})
    arrayExpr := ast:child code 0
    indexExpr2 := ast:child code 1
    arrayPtr := getMemberAddress(arrayExpr)
    ret ${ptradd (load #arrayPtr) #indexExpr2}
  elseif ast:matchesShape(code, ${__*})
    ptrExpr := ast:child code 0
    ret ${load #ptrExpr}
  end
  ret ${error "Do not know how to get address of this expression" #code}
end

///TODO: add support to call methods
macro op. record component
  addr := getMemberAddress ${#record.#component}

  ret ${load #addr}
end

/// Assigning values. Supports
/// a = b - for first class types
/// a.x = b - for struct members
/// ptr[10] = b - for pointers
macro op= l r
  if ast:matchesShape(l, ${_[_]})
    var ast* array ast:child(l, 0)
    var ast* index ast:child(l, 1)
    ret ${store ptradd(#array, #index) #r}
  elseif ast:matchesShape(l, ${__.__})
    laddr := getMemberAddress(l)
    ret ${store #laddr #r}
  elseif ast:matchesShape(l, ${__*})
    addr := ast:child l 0
    ret ${store #addr #r}
  else
    ret ${assign #l #r}
  end

  ret ${internal error}
end

// /// Accessing pointers like C arrays
// template postop[] array index
//   load(ptradd #array #index)
// end

macro defineArray type varname values...
  size := values.childCount
  arrayType := ast:fromString "postop[]"
  ast:addChild arrayType type
  ast:addChild arrayType ${#size}

  code := ${
    var #arrayType #varname
  end}

  valnum := 0
  forEachAstChild value values
    ast:addChild code ${zmp:array:set #varname #valnum #value}
    valnum = valnum + 1
  end

  ret code
end

template postop[] array index
  zmp:array:get #array #index
end

template op+_ptr ptr offset
  ptradd #ptr #offset
end

template zmp:array:get array index
  load ptradd(zmp:array:addr &(#array), #index)
end

template zmp:array:set array index value
  store ptradd(zmp:array:addr &(#array), #index) #value
end

/// Allocate storage and initialize variable
/// `new Foo a b c' does the same as `Foo:init(malloc Foo, a, b, c)'
macro new type args...
  uniqueId name "new"

  var ast* initCall ast:fromString(cstring:concat(getField(type, id), ":init"))
  ast:addChild initCall ast:fromString(name)
  forEachAstChild arg args
    ast:addChild initCall arg
  end

  var ast* code ${seq}
  ast:addChild code ${var (ptr #type) #name (malloc #type)}
  ast:addChild code initCall
  ast:addChild code ast:fromString(name)

  ret code
end

func void free(void* ptr)
template dealloc ptr free(cast void* #ptr)
  
template return value
  ret #value
end

template op++ lstring rstring
  cstrings:append #lstring #rstring
end

template preop++ int
  #int = #int + 1
  #int
end

template preop-- int
  #int = #int - 1
  #int
end

template postop++ int
  #int = #int + 1
  #int - 1
end

template postop-- int
  #int = #int - 1
  #int + 1
end

func int "op**"(int l, int r)
  acc := 1
  for i 0 r
    acc = acc * l
  end
  ret acc
end

macro swap a b
  uniqueId t "swap"
  ret ${
    t := #a
    #a = #b
    #b = t
  end}
end

macro preop& obj
  code := getMemberAddress obj
  ret code
end

template preop* ptr
  (load #ptr)
end

template postop* ptr
  (load #ptr)
end

template isNotNull ptr
  #ptr !=_ptr nullptr void
end

template isNull ptr
  #ptr ==_ptr nullptr void
end

macro struct name members
  unless (name.childCount == 0)
    ret ${error "Expected id" #name}
  end

  decl := ast:fromString "type"
  ast:addChild decl name

  forEachAstChild memberList members
    if ast:matchesShape(memberList, ${__ _...})
      memberType := ast:child memberList 0
      for memberNum 1 memberList.childCount
        memberName := ast:child memberList memberNum
        ast:addChild decl ${#memberType #memberName}
      end
    else
      ret ${error "Expected 'typeExpr id..." #memberList}
    end
  end

  ret decl
end

func bool isMultipleOf(int x, int m)
  ret (int:mod(x,m) == 0)
end

macro ast:foreach3 t0 t1 t2 tree code
  if (bool:not isMultipleOf(tree.childCount, 3))
    ret ${error "Can only iterate over 3-tuples if child count is a multiple of 3" tree}
  end

  uniqueId childnum "ast:foreach3"

  ret ${
    #childnum := 0
    while (#childnum + 2 < #tree.childCount)
      #t0 := ast:child #tree (#childnum+0)
      #t1 := ast:child #tree (#childnum+1)
      #t2 := ast:child #tree (#childnum+2)
      #code
      #childnum = #childnum + 3
    end
  end}
end

macro ast:foreach2 t0 t1 tree code
  if (bool:not isMultipleOf(tree.childCount, 3))
    ret ${error "Can only iterate over pairs if child count is a multiple of 2" tree}
  end

  uniqueId childnum "ast:foreach2"

  ret ${
    #childnum := 0
    while (#childnum + 1 < #tree.childCount)
      #t0 := ast:child #tree (#childnum+0)
      #t1 := ast:child #tree (#childnum+1)
      #code
      #childnum = #childnum + 2
    end
  end}
end

///
/// Will transform an expression of the form (<jux someId (<arg 0>) ..>) to
/// (<someId (<arg 0>) ...>)
///
func ast* ast:shiftLeft(ast* code)
  assert (code.childCount >= 1)
  assert (getField ast:child(code,0) childCount == 0)

  firstChild := ast:child code 0
  newcode := ast:fromString firstChild.id
  for i 1 code.childCount
    ast:addChild newcode ast:child(code,i)
  end
  ret newcode
end

///-----------------------------------------------------------------------------
/// Section: control flow
///-----------------------------------------------------------------------------

///
/// A simple loop construct. You can break from the loop using a break statement
///
/// TODO attention: do not nest (checking not possible, yet)...
macro loop code
  uniqueId start "loop_start"
  uniqueId end "loop_end"

  ret ${
    template break
      branch #end
    end

    label #start
    #code
    branch #start
    label #end
  end}
end

///
/// switch statement
///
/// Example:
///
/// switch _intExpression
///   void
/// case _intExpression
///   _code
/// ...
/// end
///
macro switch intvalue default cases...
  uniqueId value "the_value"

  first := true
  code := ${if false
    printNewline()
  end}

  ast:foreach3 case caseval casecode cases
    unless ast:matchesShape(case, ${case})
      caseNode := ast:shiftLeft ${#case #caseval #casecode}
      ret ${error "Expected 'case VAL EXPR'" #caseNode}
    end

    ast:addChild code $elseif
    ast:addChild code ${#value == #caseval}
    ast:addChild code casecode
  end

  code = ${
    var int #value #intvalue
    #code
  end}

  ret code
end

///-----------------------------------------------------------------------------
/// Section: Overloaded operators
///-----------------------------------------------------------------------------

func ast* defineOpCode(cstring type, cstring rettype, cstring opr, cstring func)
  funcname := type ++ ":" ++ func
  oprname := opr ++ "_" ++ type ++ "_" ++ type

  ret ${
    func #rettype #oprname(#type l, #type r)
      #funcname(l, r)
    end
  end}
end

alias u32:greater u32:sgreater l r
alias u32:greaterEqual u32:sgreaterEqual l r
alias u32:less u32:sless l r
alias u32:lessEqual u32:slessEqual l r
alias u32:div u32:sdiv l r

alias char:greater char:sgreater l r
alias char:greaterEqual char:sgreaterEqual l r
alias char:less char:sless l r
alias char:lessEqual char:slessEqual l r

func char char:add(char l, char r)
  ret '?'
end
func char char:sub(char l, char r)
  ret '?'
end
func char char:mul(char l, char r)
  ret '?'
end
func char char:div(char l, char r)
  ret '?'
end


alias float:div float:fdiv l r
alias float:greater float:ogreater l r
alias float:greaterEqual float:ogreaterEqual l r
alias float:less float:oless l r
alias float:lessEqual float:olessEqual l r

alias double:equal double:oequal l r
alias double:notEqual double:onotEqual l r
alias double:div double:fdiv l r
alias double:greater double:ogreater l r
alias double:greaterEqual double:ogreaterEqual l r
alias double:less double:oless l r
alias double:lessEqual double:olessEqual l r

macro overloadedOps type
  macro defop_ rettype opr name
    oprName := cstring:quote opr.id
    funcName := cstring:quote name.id

    ret ${
      ast:addChild code (defineOpCode type.id #rettype #oprName #funcName)
    end}
  end

  code := ${}

  defop_ "bool" op== equal
  defop_ "bool" op!= notEqual
  defop_ "bool" op> greater
  defop_ "bool" op>= greaterEqual
  defop_ "bool" op< less
  defop_ "bool" op<= lessEqual

  defop_ type.id op+ add
  defop_ type.id op- sub
  defop_ type.id op* mul
  defop_ type.id op/ div

  ret code
end

overloadedOps u32
overloadedOps float
overloadedOps double
overloadedOps char

template op+ l r
  zmp:cee:add #l #r
end

template op- l r
  zmp:cee:sub #l #r
end

template op* l r
  zmp:cee:mul #l #r
end

template op/ l r
  zmp:cee:div #l #r
end

template op== l r
  zmp:cee:equal #l #r
end

template op!= l r
  bool:not (#l == #r)
end

template op> l r
  zmp:cee:greater #l #r
end

template op>= l r
  zmp:cee:greaterEqual #l #r
end

template op< l r
  zmp:cee:less #l #r
end

template op<= l r
  zmp:cee:lessEqual #l #r
end

func bool op<_ptr_ptr(void* l, void* r)
  ret u32:uless(cast int l, cast int r)
end

func bool op>_ptr_ptr(void* l, void* r)
  ret u32:ugreater(cast int l, cast int r)
end

func bool op<=_ptr_ptr(void* l, void* r)
  ret u32:ulessEqual(cast int l, cast int r)
end

func bool op>=_ptr_ptr(void* l, void* r)
  ret u32:ugreaterEqual(cast int l, cast int r)
end

func bool op!=_ptr_ptr(void* l, void* r)
  ret u32:notEqual(cast int l, cast int r)
end

func bool op==_ptr_ptr(void* l, void* r)
  ret u32:equal(cast int l, cast int r)
end

func bool op==_bool_bool(bool l, bool r)
  ret bool:not(bool:xor l r)
end

///-----------------------------------------------------------------------------
/// Section: Overloaded printing
///-----------------------------------------------------------------------------

func void print_u32(int i)
  printInt i
end

func void print_float(float f)
  printFloat f
end

func void print_char(char c)
  printChar c
end

func void print_bool(bool b)
  printBool b
end

func void print_double(double d)
  printDouble d
end

func void "print_char*"(char* string)
  printString string
end

func void "print_ast*"(ast* code)
  ast:print code 0
end

macro print args...
  var astp code ${}

  forEachAstChild arg args
    ast:addChild code ${zmp:cee:print #arg}
  end

  ret code
end

macro println args...
  var astp code ${}

  forEachAstChild arg args
    ast:addChild code ${zmp:cee:print #arg}
  end

  ast:addChild code ${printNewline()}

  ret code
end

func void printBits(int bitmask)
  printString "0b"
  for i 0 32
    bitnum := 31 - i
    mask := int:shl 1 bitnum
    bit := int:lshr (bitmask & mask) bitnum
    printInt bit
  end
end



macro structlit structType fieldsAndValues...
  uniqueId structVar "struct"

  code := ${
    var #structType #structVar
  end}

  ast:foreach2 field value fieldsAndValues
    ast:addChild code ${#structVar.#field = #value}
  end

  ast:addChild code ${#structVar}
  ret code
end

///-----------------------------------------------------------------------------
/// Section: Overloaded conversion
///-----------------------------------------------------------------------------

alias toInt zmp:cee:toInt x
alias toFloat zmp:cee:toFloat x
alias toDouble zmp:cee:toDouble x
alias toChar zmp:cee:toChar x
alias toCString zmp:cee:toCString x


func int toInt_u32(int i)
  ret i
end

func int toInt_float(float f)
  float:toInt f
end

func int toInt_double(double d)
  double:toInt d
end

func int toInt_char(char c)
  ret char:zextToU32(c)
end

func int toInt_bool(bool b)
  if b
    ret 1
  end
  ret 0
end


func float toFloat_u32(u32 i)
  int:toFloat i
end

func float toFloat_double(double d)
  double:toFloat d
end

func float toFloat_float(float f)
  ret f
end

func float toFloat_bool(bool b)
  toFloat(toInt b)
end


func double toDouble_u32(int i)
  int:toDouble i
end

func double toDouble_float(float f)
  float:toDouble f
end

func double toDouble_double(double d)
  ret d
end

func double toDouble_bool(bool b)
  toDouble(toInt b)
end


func char toChar_u32(int i)
  ret u32:toChar(i)
end


func char* toCString_u32(int i)
  int2cstring i
end

func char* toCString_float(float f)
  float2cstring f
end

func char* toCString_double(double d)
  double2cstring d
end

func char* toCString_char(char c)
  char2cstring c
end

func char* toCString_bool(bool b)
  ret bool2cstring(b)
end

func char* "toCString_char*"(char* c)
  c
end

macro ofunc rettype nameAndArgs impl
  if ast:matchesShape(nameAndArgs, ${_(__...)})
    name := getField(ast:child nameAndArgs 0, id)
    newNameAndArgs := ${_()}

    for i 1 nameAndArgs.childCount
      param := ast:child nameAndArgs i

      if ast:matchesShape(param, ${__ _})
        paramType := ast:child param 0
        if (paramType.childCount > 0)
          ret ${error "ofunc: Only supporting type names which are an id atm" #paramType}
        end
        paramName := ast:child param 1
        ast:addChild newNameAndArgs ${#paramType #paramName}
        name = name ++ "_" ++ paramType.id
      else
        ret ${error "Invalid parameter, expected 'TYPE_EXPR NAME" ${#param}}
      end
    end

    nameAst := ast:child newNameAndArgs 0
    nameAst.id = name
    ret ${func #rettype #newNameAndArgs #impl}
  end

  ret ${error "Expected 'ofunc RETTYPE funcName(args...)'" ${ofunc #rettype #nameAndArgs "..."}}
end

///-----------------------------------------------------------------------------
/// Section: Assertions
///-----------------------------------------------------------------------------

macro assert testCode
  isCompare := false
  compareF := ast:fromString "op=="

  if ast:matchesShape(testCode, ${__ == __})
    isCompare = true
  elseif ast:matchesShape(testCode, ${__ ==_f __})
    isCompare = true
  elseif ast:matchesShape(testCode, ${__ ==_str __})
    isCompare = true
    compareF = ast:fromString "op==_str"
  elseif ast:matchesShape(testCode, ${__ < __})
    isCompare = true
    compareF = ast:fromString "op<"
  end

  if isCompare
    uniqueId lvar "lvar"
    uniqueId rvar "rvar"
    l := ast:child(testCode, 0)
    r := ast:child(testCode, 1)
    ret ${
      #lvar := #l
      #rvar := #r
      unless (#compareF #lvar #rvar)
        ++unittest:failedCount
        printHLine '-' 40
        printlnString "Assertion failed"
        printString "left = "
        print #lvar
        println()
        printString "right = "
        print #rvar
        println()
        ast:print ${#testCode} 0
      end
    end}
  else
    ret ${
      unless #testCode
        ++unittest:failedCount
        printHLine '-' 40
        printlnString "Assertion failed"
        ast:print ${#testCode} 0
      end
    end}
  end

  ret ${}
end


