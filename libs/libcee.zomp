/**
 * Libraries providing a C like feel

!verify off
!syntax indent
 */


template macro:failUnless cond
  unless #{cond}
    ret ${error expression is false #{cond}}
  end
end

macro uniqueIds purpose ids...
  var ast* code ${seq}

  forEachAstChild child ids
    addChild code ${uniqueIds #child #purpose}
  end

  ret code
end


/// if statement
///
/// Usage example:
///
/// if a > 10 then
///   print "It's bigger!"
/// else if a < 5 then
///   print "It's smaller!"
/// else
///   print "Neither to big nor to small. Purrfect"
/// end
macro if2 cond then onTrue remArgs...
  macro:failUnless cstring:equal(getField(then, id), "then")

  uniqueId endLabel "if_end"

  var astp code ${seq}

  addChild code ${when #cond
    #onTrue
    branch #endLabel
  end}

  var int currentArg 0
  const int argCount getField(remArgs, childCount)

  while (currentArg+3 <= argCount)
    var astp econd ast:child(remArgs, currentArg+1)
    var astp eexpr ast:child(remArgs, currentArg+2)

    addChild code ${seq
      when #econd
        #eexpr
        branch #endLabel
      end
    end}

    currentArg = currentArg + 3
  end

  when (currentArg+1 < argCount)
    var astp elseCode ast:child(remArgs, currentArg+1)

    addChild code elseCode
  end

  addChild code ${label #endLabel}

  ret code
end

template op| l r
  int:or #l #r
end

template op& l r
  int:and #l #r
end

macro op|| l r
  uniqueId result "||"

  ret ${
    #result := false
    if2 #l then
      #result = true
    elseif #r
      #result = true
    end
    #result
  end}
end

macro op&& l r
  uniqueId result "&&"

  ret ${
    #result := false
    if2 #l then
      #result = #r
    end
    #result
  end}
end

template op==_str left right
  strcmp(#left, #right) == 0
end

template op!=_str left right
  strcmp(#left, #right) != 0
end

macro op:= name value
  if2 (getField(name, childCount) == 0) then
    ret ${var2 #name #value}
  end
  ret ${error "Expected a single identifier on left hand side" ${#name := #value}}
end

// macro dummy l r
//   printlnString "applying dummy"
//   ret ${foo bar}
// end
// 
// func void p2(ast* l, ast* r)
//   printlnString "should do something now.."
// end

/// Given an ast and an ast containing placeholders _/__ the
/// shapes of both ast's are matched against each other. They match if they have
/// the same name, same number of children and all their children are matching.
///
/// The _ placeholder matches expressions without children (like 'a') while
/// the __ placeholder matches any other ast
/// _... as last argument means any number of parameters
///
/// Examples:
///   ast:matchesShape ${foo bar} ${foo bar} => true
///   ast:matchesShape ${a b c} ${__} => true
///   ast:matchesShape ${foo (some child) bar} ${foo __ bar} => true
///   ast:matchesShape ${a b} ${a} => false
///   ast:matchesShape ${a b c} ${a b} => false
///   ast:matchesShape ${a b} ${a b _} => false
///   ast:matchesShape ${a _...} ${a 1 2 3 4} => true
///
func bool ast:matchesShape(ast* codeArg, ast* templateArg)
  var ast* code codeArg
  var ast* template templateArg

  assert (template !=_ptr nullptr ast)
  assert (code !=_ptr nullptr ast)

  var cstring templateId getField(template, id)
  var int templateChildCount getField(template, childCount)
  var cstring codeId getField(code, id)
  var int codeChildCount getField(code, childCount)

  when (bool:and (templateId ==_str "_") (codeChildCount == 0))
    ret true
  end

  when (templateId ==_str "__")
    ret true
  end

  varargs := false
  lastChild := nullptr ast
  if2 (templateChildCount > 0) then
    lastChild = ast:child template (templateChildCount - 1)
    assert (lastChild !=_ptr nullptr ast)
    if2 ((getField(lastChild, childCount) == 1) && (getField(lastChild, id) ==_str "postop...")) then
      var ast* lastChildChild ast:child(lastChild, 0)
      varargs = (getField(lastChildChild, id) ==_str "_")
    end
  end

  if2 varargs then
    if2 ((codeChildCount >= templateChildCount - 1) && (codeId ==_str templateId)) then
      for childNum2 0 (templateChildCount - 1)
        unless (ast:matchesShape (ast:child code childNum2) (ast:child template childNum2))
          ret false
        end
      end
      ret true
    end
  else
    if2 ((codeChildCount == templateChildCount) && (codeId ==_str templateId)) then
      for childNum 0 codeChildCount
        unless (ast:matchesShape (ast:child code childNum) (ast:child template childNum))
          ret false
        end
      end
      ret true
    end
  end

  ret false
end

///
/// Will return code to get the address of the denoted element
/// Accepts code of the form id(.id)*
/// Also accepts array expressions like foo[10]
/// Will probably evolve into a general way to get the address of a
/// left hand side expression
///
/// Example:
///   getMemberAddress(${a.b.c}) => (fieldptr (fieldptr a b) c)
///
func ast* getMemberAddress(ast* code)
  if2 (getField code childCount == 0) then
    ret ${ptr #code}
  elseif ast:matchesShape(code, ${_._})
    recordExpr := ast:child(code, 0)
    fieldName := getField ast:child(code, 1) id
    ret ${fieldptr #recordExpr #fieldName}
  elseif ast:matchesShape(code, ${__._})
    nestedPtr := getMemberAddress ast:child(code, 0)
    fieldName2 := getField ast:child(code, 1) id
    ret ${fieldptr #nestedPtr #fieldName2}
  elseif ast:matchesShape(code, ${__._[__]})
    structExpr := ast:child code 0
    memberName := getField ast:child(ast:child(code, 1), 0) id
    indexExpr := ast:child(ast:child(code, 1), 1)
    memberPtr := getMemberAddress(${#structExpr.#memberName})
    ret ${ptradd (load #memberPtr) #indexExpr}
  elseif ast:matchesShape(code, ${_[__]})
    arrayExpr := ast:child code 0
    indexExpr2 := ast:child code 1
    arrayPtr := getMemberAddress(arrayExpr)
    ret ${ptradd (load #arrayPtr) #indexExpr2}
  elseif ast:matchesShape(code, ${__*})
    ptrExpr := ast:child code 0
    ret ${load #ptrExpr}
  end
  ret ${error "Do not know how to get address of this expression" #code}
end

///TODO: add support to call methods
macro op. record component
  addr := getMemberAddress ${#record.#component}

  ret ${load #addr}
end

/// Assigning values. Supports
/// a = b - for first class types
/// a.x = b - for struct members
/// ptr[10] = b - for pointers
macro op= l r
  if2 ast:matchesShape(l, ${_[_]}) then
    var ast* array ast:child(l, 0)
    var ast* index ast:child(l, 1)
    ret ${store ptradd(#array, #index) #r}
  elseif ast:matchesShape(l, ${__.__})
    laddr := getMemberAddress(l)
    ret ${store #laddr #r}
  else
    ret ${assign #l #r}
  end

  ret ${internal error}
end

/// Accessing pointers like C arrays
template postop[] array index
  load(ptradd #array #index)
end

/// Allocate storage and initialize variable
/// `new Foo a b c' does the same as `Foo:init(malloc Foo, a, b, c)'
macro new type args...
  uniqueId name "new"

  var ast* initCall astFromString(cstring:concat(getField(type, id), ":init"))
  addChild initCall astFromString(name)
  forEachAstChild arg args
    addChild initCall arg
  end

  var ast* code ${seq}
  addChild code ${var (ptr #type) #name (malloc #type)}
  addChild code initCall
  addChild code astFromString(name)

  ret code
end

func void free(void* ptr)
template dealloc ptr free(cast void* #ptr)

template return value
  ret #value
end

template op++ lstring rstring
  cstrings:append #lstring #rstring
end

template preop++ int
  #int = #int + 1
  #int
end

template preop-- int
  #int = #int - 1
  #int
end

template postop++ int
  #int = #int + 1
  #int - 1
end

template postop-- int
  #int = #int - 1
  #int + 1
end

template preop& obj
  ptr #obj
end

macro struct name members...
  code := simpleAst("type")
  addChild code name

  forEachAstChild member members
    addChild code member
  end

  ret code
end

