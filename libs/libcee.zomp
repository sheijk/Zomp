///
/// Library providing a C like language.
///

requireLibs basic_ops

///-----------------------------------------------------------------------------
/// Section: C functions
///-----------------------------------------------------------------------------

// attention, might not work on 64-bit.. :\
type size_t int
type int_t int

dfunc void* memset(void* ptr, int_t value, size_t bytes)
dfunc void* memcpy(void* destination, void* source, size_t bytes)
dfunc void* memmove(void* destination, void* source, size_t bytes)
dfunc int_t memcmp(void* ptr1, void* ptr2, size_t bytes)

func void free(void* ptr)
template dealloc ptr free(cast void* #ptr)

//--- math.h

// preprocessor defines
// float_t double_t HUGE_VAL HUGE_VALF HUGE_VALL INFINITY NAN
// FP_INFINITE FP_NAN FP_NORMAL FP_SUBNORMAL FP_ZERO FP_FAST_FMA FP_FAST_FMAF
// FP_FAST_FMAL FP_ILOGB0 FP_ILOGBNAN MATH_ERRNO MATH_ERREXCEPT math_errhandling

// int fpclassify(real-floating x)
// int isfinite(real-floating x)
// int isinf(real-floating x)
// int isnan(real-floating x)
// int isnormal(real-floating x)
// int signbit(real-floating x)
// double acos(double x)
// float acosf(float x)
// long double acosl(long double asin(double x)
// float asinf(float x)
// long double asinl(long double atan(double x)
// float atanf(float x)
// long double atanl(long double x)
// double atan2(double y, double x)
// float atan2f(float y, float x)
// long double atan2l(long double y, long double x)
// double cos(double x)
// float cosf(float x)
// long double cosl(long double sin(double x)
// float sinf(float x)
// long double sinl(long double tan(double x)
// float tanf(float x)
// long double tanl(long double acosh(double x)
// float acoshf(float x)
// long double acoshl(long double asinh(double x)
// float asinhf(float x)
// long double asinhl(long double atanh(double x)
// float atanhf(float x)
// long double atanhl(long double cosh(double x)
// float coshf(float x)
// long double coshl(long double sinh(double x)
// float sinhf(float x)
// long double sinhl(long double tanh(double x)
// float tanhf(float x)
// long double tanhl(long double exp(double x)
// float expf(float x)
// long double expl(long double x)
// double exp2(double x)
// float exp2f(float x)
// long double exp2l(long double x)
// double expm1(double x)
// float expm1f(float x)
// long double expm1l(long double x)
// double frexp(double value, int *exp)
// float frexpf(float value, int *exp)
// long double frexpl(long double value, int *exp)
// int ilogb(double x)
// int ilogbf(float x)
// int ilogbl(long double x)
// double ldexp(double x, int exp)
// float ldexpf(float x, int exp)
// long double ldexpl(long double x, int exp)
// double log(double x)
// float logf(float x)
// long double logl(long double x)
// double log10(double x)
// float log10f(float x)
// long double log10l(long double log1p(double x)
// float log1pf(float x)
// long double log1pl(long double log2(double x)
// float log2f(float x)
// long double log2l(long double logb(double x)
// float logbf(float x)
// long double logbl(long double modf(double value, double *iptr)
// float modff(float value, float *iptr)
// long double modfl(long double value, long double *iptr)
// double scalbn(double x, int n)
// float scalbnf(float x, int n)
// long double scalbnl(long double x, int n)
// double scalbln(double x, long int n)
// float scalblnf(float x, long int n)
// long double scalblnl(long double x, long int n)
// double cbrt(double x)
// float cbrtf(float x)
// long double cbrtl(long
dfunc double fabs(double x)
dfunc float fabsf(float x)
// long double fabsl(long double x)
// double hypot(double x, double y)
// float hypotf(float x, float y)
// long double hypotl(long double x, long double y)
// double pow(double x, double y)
// float powf(float x, float y)
// long double powl(long double x, long double y)
// double sqrt(double x)
// float sqrtf(float x)
// long double sqrtl(long double x)
// double erf(double x)
// float erff(float x)
// long double erfl(long double x)
// double erfc(double x)
// float erfcf(float x)
// long double erfcl(long double x)
// double lgamma(double x)
// float lgammaf(float x)
// long double lgammal(long double x)
// double tgamma(double x)
// float tgammaf(float x)
// long double tgammal(long double x)
// double ceil(double x)
// float ceilf(float x)
// long double ceill(long double x)
// double floor(double x)
// float floorf(float x)
// long double floorl(long double x)
// double nearbyint(double x)
// float nearbyintf(float x)
// long double nearbyintl(long double x)
// double rint(double x)
// float rintf(float x)
// long double rintl(long double x)
// long int lrint(double x)
// long int lrintf(float x)
// long int lrintl(long double x)
// long long int llrint(double x)
// long long int llrintf(float x)
// long long int llrintl(long double x)
// double round(double x)
// float roundf(float x)
// long double roundl(long double x)
// long int lround(double x)
// long int lroundf(float x)
// long int lroundl(long double x)
// long long int llround(double x)
// long long int llroundf(float x)
// long long int llroundl(long double x)
// double trunc(double x)
// float truncf(float x)
// long double truncl(long double x)
// double fmod(double x, double y)
// float fmodf(float x, float y)
// long double fmodl(long double x, long double remainder(double x, double y)
// float remainderf(float x, float y)
// long double remainderl(long double x, double remquo(double x, double y, int float remquof(float x, float y, int *quo)
// long double remquol(long double x, long double y, double y, int *quo)
// double copysign(double x, double y)
// float copysignf(float x, float y)
// long double copysignl(long double x, long double y)
// double nan(const char *tagp)
// float nanf(const char *tagp)
// long double nanl(const char *tagp)
// double nextafter(double x, double y)
// float nextafterf(float x, float y)
// long double nextafterl(long double x, long double y)
// double nexttoward(double x, long double y)
// float nexttowardf(float x, long double y)
// long double nexttowardl(long double x, long double y)
// double fdim(double x, double y)
// float fdimf(float x, float y)
// long double fdiml(long double x, double fmax(double x, double y)
// float fmaxf(float x, float y)
// long double fmaxl(long double x, double fmin(double x, double y)
// float fminf(float x, float y)
// long double fminl(long double x, double fma(double x, double y, double z)
// float fmaf(float x, float y, float z)
// long double fmal(long double x, long double y, long double z)
// int isgreater(real-floating x, real-floating y)
// int isgreaterequal(real-floating x, real-floating y)
// int isless(real-floating x, real-floating y)
// int islessequal(real-floating x, real-floating y)
// int islessgreater(real-floating x, real-floating y)
// int isunordered(real-floating x, real-floating y)


//--- stdio.h

// preprocessor symbols
// size_t FILE fpos_t NULL _IOFBF
// _IOLBF _IONBF BUFSIZ EOF FOPEN_MAX
// FILENAME_MAX TMP_MAX L_tmpnam stderr SEEK_CUR stdin SEEK_END stdout SEEK_SET

// int remove(const char *filename)
// int rename(const char *old, const char *new)
// FILE *tmpfile(void)
// char *tmpnam(char *s)
// int fclose(FILE *stream)
// int fflush(FILE *stream)
// FILE *fopen(const char * restrict filename, const char * restrict mode)
// FILE *freopen(const char * restrict filename, const char * restrict mode, FILE * restrict stream)
// void setbuf(FILE * restrict stream, char * restrict buf)
// int setvbuf(FILE * restrict stream, char * restrict buf, int mode, size_t size)
// int fprintf(FILE * restrict stream, const char * restrict format, ...)
// int fscanf(FILE * restrict stream, const char * restrict format, ...)
// int printf(const char * restrict format, ...)
// int scanf(const char * restrict format, ...)
// int snprintf(char * restrict s, size_t n, const char * restrict format, ...)
// int sprintf(char * restrict s, const char * restrict format, ...)
// int sscanf(const char * restrict s, const char * restrict format, ...)
// int vfprintf(FILE * restrict stream, const char * restrict format, va_list arg)
// int vfscanf(FILE * restrict stream, const char * restrict format, va_list arg)
// int vprintf(const char * restrict format, va_list arg)
// int vscanf(const char * restrict format, va_list arg)
// int vsnprintf(char * restrict s, size_t n, const char * restrict format, va_list int vsprintf(char * restrict s, const char * restrict format, va_list int vsscanf(const char * restrict s, const char * restrict format, int fgetc(FILE *stream)
// char *fgets(char * restrict s, int n, FILE * restrict stream)
// int fputc(int c, FILE *stream)
// int fputs(const char * restrict s, FILE * restrict stream)
// int getc(FILE *stream)
// int getchar(void)
// char *gets(char *s)
// int putc(int c, FILE *stream)
// int putchar(int c)
// int puts(const char *s)
// int ungetc(int c, FILE *stream)
// size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream)
// size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict stream)
// int fgetpos(FILE * restrict stream, fpos_t * restrict pos)
// int fseek(FILE *stream, long int offset, int whence)
// int fsetpos(FILE *stream, const fpos_t *pos)
// long int ftell(FILE *stream)
// void rewind(FILE *stream)
// void clearerr(FILE *stream)
// int feof(FILE *stream)
// int ferror(FILE *stream)
// void perror(const char *s)

//--- stdlib.h

// preprocessor
// size_t wchar_t div_t
// ldiv_t	EXIT_FAILURE MB_CUR_MAX lldiv_t	EXIT_SUCCESS NULL	RAND_MAX

// double atof(const char *nptr)
// int atoi(const char *nptr)
// long int atol(const char *nptr)
// long long int atoll(const char *nptr)
// double strtod(const char * restrict nptr, char ** restrict endptr)
// float strtof(const char * restrict nptr, char ** restrict endptr)
// long double strtold(const char * restrict nptr, char ** restrict endptr)
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base)
// long long int strtoll(const char * restrict nptr, char ** restrict endptr, int base)
// unsigned long int strtoul(const char * restrict nptr, char ** restrict endptr, int base)
// unsigned long long int strtoull( const char * restrict nptr, char ** restrict endptr, int base)
// int rand(void)
// void srand(unsigned int seed)
// void *calloc(size_t nmemb, size_t size)
// void free(void *ptr)
// void *malloc(size_t size)
// void *realloc(void *ptr, size_t size)
// void abort(void)
// int atexit(void (*func)(void))
// void exit(int status)
// void _Exit(int status)
func cstring getenv(cstring name)
func int system(cstring command)
// void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *))
// void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *))
// int abs(int j)
// long int labs(long int j)
// long long int llabs(long long int j)
// div_t div(int numer, int denom)
// ldiv_t ldiv(long int numer, long int denom)
// lldiv_t lldiv(long long int numer, long long int denom)
// int mblen(const char *s, size_t n)
// int mbtowc(wchar_t * restrict pwc, const char * restrict s, size_t n)
// int wctomb(char *s, wchar_t wchar)
// size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n)
// size_t wcstombs(char * restrict s, const wchar_t * restrict pwcs, size_t n)

//--- string.h

// preprocessor
// size_t NULL

dfunc void* memcpy(void* destination, void* source, size_t n)
dfunc void* memmove(void* destination, void* source, size_t n)
dfunc char* strcpy(char* destination, char* source)
dfunc char* strncpy(char* destination, char* source, size_t n)
dfunc char* strcat(char* destination, char* source)
dfunc char* strncat(char* destination, char* source, size_t n)
dfunc int memcmp(void* s1, void* s2, size_t n)
dfunc int strcmp(char* s1, char* s2)
dfunc int strcoll(char* s1, char* s2)
dfunc int strncmp(char* s1, char* s2, size_t n)
dfunc size_t strxfrm(char* s1, char* s2, size_t n)
dfunc void* memchr(void* s, int c, size_t n)
dfunc char* strchr(char* s, int c)
dfunc size_t strcspn(char* s1, char* s2)
dfunc char* strpbrk(char* s1, char* s2)
dfunc char* strrchr(char* s, int c)
dfunc size_t strspn(char* s1, char* s2)
dfunc char* strstr(char* s1, char* s2)
dfunc char* strtok(char* s1, char* s2)
dfunc void* memset(void* s, int c, size_t n)
dfunc char* strerror(int errnum)
dfunc size_t strlen(char* s)

///-----------------------------------------------------------------------------
/// Section: Untested
///-----------------------------------------------------------------------------

/// Returns the size of the given type on the current backend platform.
macro sizeof type:
  uniqueId null "null"
  uniqueId next "next"

  ret $:
    var #type* #null nullptr(#type)
    var #type* #next ptradd(#null, 1)
    u32:sub(cast u32 #next, cast u32 #null)
  end
end

/// initialize multiple fields
macro setFieldsTo record value fields...:
  var (ptr ast) code ${}
  forEachAstChild field fields:
    ast:addChild code ${setField #record #field #value}
  end

  ret code
end

///
/// Declares a function. Use this to prevent emacs indentation in next line :)
///
template funcd rettype nameAndArgs:
  std:base:func #rettype #nameAndArgs
end

template macro:failUnless cond:
  unless #{cond}:
    ret ${error expression is false #{cond}}
  end
end

macro uniqueIds purpose ids...:
  var ast* code ${seq}

  forEachAstChild child ids:
    ast:addChild code ${uniqueIds #child #purpose}
  end

  ret code
end

macro op|| l r:
  uniqueId result "||"

  ret $:
    #result := false
    if #l:
      #result = true
    elseif #r:
      #result = true
    end
    #result
  end
end

macro op&& l r:
  uniqueId result "&&"

  ret $:
    #result := false
    if #l:
      #result = #r
    end
    #result
  end
end

template op==_str left right:
  strcmp(#left, #right) == 0
end

template op!=_str left right:
  strcmp(#left, #right) != 0
end

macro op:= name value:
  if (getField(name, childCount) == 0):
    ret ${var2 #name #value}
  end
  ret ${error "Expected a single identifier on left hand side" ${#name := #value}}
end

/// Allow unitialized variables to be created like
///   num := undef int
macro undef type:
  uniqueId name "undef_value"
  ret $:
    var #type #name
    #name
  end
end

//------------------------------------------------------------------------------

type astList:
  ast* ast
  astList* next
end

var astList* cee:internal:onReturnCleanupCode null
var bool cee:internal:insideCeeFunc false

/// The executed code will be executed right before all return statements inside
/// the current function. Functions using onReturn must always be left with
/// return and never using ret. This can only be used inside cee functions
macro onReturn cleanupCode:
  if (bool:not cee:internal:insideCeeFunc):
    ret ${error "onReturn may only be used inside cee functions" #cleanupCode}
  end
  newList := malloc astList
  setField newList ast cleanupCode
  setField newList next cee:internal:onReturnCleanupCode
  cee:internal:onReturnCleanupCode = newList
  std:base:ret ${}
end

macro onFunctionEnd:
  ret ${}
end

macro return expr...:
  retCode := nullptr ast
  if (getField expr childCount == 1):
    retval := ast:child(expr, 0)
    retCode = ${std:base:ret #retval}
  elseif (getField expr childCount == 0):
    retCode = ast:fromString("std:base:ret")
  else:
    std:base:ret ${error "return expects one or zero arguments" #expr}
  end

  code := ${}
  ast:addChild code ${onFunctionEnd}
  current := cee:internal:onReturnCleanupCode
  while (cast void* current !=_ptr nullptr void):
    ast:addChild code getField(current,ast)
    current = getField current next
  end
  ast:addChild code retCode
  std:base:ret code
end

macro ret expr...:
  if (cast void* cee:internal:onReturnCleanupCode !=_ptr nullptr void):
    std:base:ret ${error "You can only return from functions using onReturn with return, ret is illegal" #expr}
  end

  retcode := ${std:base:ret}
  forEachAstChild e expr:
    ast:addChild retcode e
  end

  std:base:ret $:
    onFunctionEnd
    #retcode
  end
end

macro cee:internal:cleanupBeforeFunc:
  if (cee:internal:onReturnCleanupCode !=_ptr nullptr void):
    printString "warning: found cleanup code before compiling function - ignoring it. Probably evaluating the last function failed"
    printNewline()
    printString "--- Left over cleanup code:"
    printNewline()
    current := cee:internal:onReturnCleanupCode
    while (cast void* current !=_ptr nullptr void):
      ast:print getField(current,ast) 4
      current = getField current next
    end
    printString "---"
    printNewline()
    cee:internal:onReturnCleanupCode = nullptr astList
    cee:internal:insideCeeFunc = false
  end
  std:base:ret ${}
end

macro cee:internal:cleanupOnReturn:
  current := cee:internal:onReturnCleanupCode
  while (cast void* current !=_ptr nullptr void):
    free (cast void* getField(current, ast))
    current = getField(current, next)
  end
  cee:internal:onReturnCleanupCode = nullptr astList
  cee:internal:insideCeeFunc = false
  std:base:ret ${}
end

macro onFunctionBegin name:
  ret ${}
end

macro func args...:
  if (getField args childCount > 3 || getField args childCount < 2):
    ret ${error "Expected 'func rettype name(param list..) impl?" #args}
  end

  zmp:prelude:logFunctionCompilation args

  rettype := ast:child args 0
  nameAndArgs := ast:child args 1
  name := cstring:quote(getField(ast:child nameAndArgs 0, id))
  var ast* funcCode ${std:base:func #rettype #nameAndArgs}
  if (getField args childCount >= 3):
    impl := ast:child args 2
    newImpl := ${}
    ast:addChild newImpl ${onFunctionBegin #name}
    forEachAstChild child impl:
      ast:addChild newImpl child
    end
    ast:addChild funcCode newImpl
  end

  cee:internal:insideCeeFunc = true
  std:base:ret $:
    cee:internal:cleanupBeforeFunc
    #funcCode
    cee:internal:cleanupOnReturn
  end
end

/// Given an ast and an ast containing placeholders _/__ the
/// shapes of both ast's are matched against each other. They match if they have
/// the same name, same number of children and all their children are matching.
///
/// The _ placeholder matches expressions without children (like 'a') while
/// the __ placeholder matches any ast
/// _... as last argument means >= 0 parameters following
///
/// Examples:
///   ast:matchesShape ${foo bar} ${foo bar} => true
///   ast:matchesShape ${a b c} ${__} => true
///   ast:matchesShape ${foo (some child) bar} ${foo __ bar} => true
///   ast:matchesShape ${a b} ${a} => false
///   ast:matchesShape ${a b c} ${a b} => false
///   ast:matchesShape ${a b} ${a b _} => false
///   ast:matchesShape ${a _...} ${a 1 2 3 4} => true
///
func bool ast:matchesShape(ast* codeArg, ast* templateArg):
  var ast* code codeArg
  var ast* template templateArg

  assert (template !=_ptr nullptr ast)
  assert (code !=_ptr nullptr ast)

  var cstring templateId getField(template, id)
  var int templateChildCount getField(template, childCount)
  var cstring codeId getField(code, id)
  var int codeChildCount getField(code, childCount)

  when (bool:and (templateId ==_str "_") (codeChildCount == 0)):
    ret true
  end

  when (templateId ==_str "__"):
    ret true
  end

  varargs := false
  lastChild := nullptr ast
  if (templateChildCount > 0):
    lastChild = ast:child template (templateChildCount - 1)
    assert (lastChild !=_ptr nullptr ast)
    if ((getField(lastChild, childCount) == 1) && (getField(lastChild, id) ==_str "postop...")):
      var ast* lastChildChild ast:child(lastChild, 0)
      var cstring lastId getField(lastChildChild, id)
      varargs = ((lastId ==_str "_") || (lastId ==_str "__"))
    end
  end

  if varargs:
    if ((codeChildCount >= templateChildCount - 1) && (codeId ==_str templateId)):
      for childNum2 0 (templateChildCount - 1):
        unless (ast:matchesShape (ast:child code childNum2) (ast:child template childNum2)):
          ret false
        end
      end
      ret true
    end
  else:
    if ((codeChildCount == templateChildCount) && (codeId ==_str templateId)):
      for childNum 0 codeChildCount:
        unless (ast:matchesShape (ast:child code childNum) (ast:child template childNum)):
          ret false
        end
      end
      ret true
    end
  end

  ret false
end

///
/// Will return code to get the address of the denoted element
/// Accepts code of the form id(.id)*
/// Also accepts array expressions like foo[10]
/// Will probably evolve into a general way to get the address of a
/// left hand side expression
///
/// Example:
///   getMemberAddress(${a.b.c}) => (fieldptr (fieldptr a b) c)
///
/// TODO: rename to getExpressionAddress and extend to arbitrary expressions(?)
func ast* getMemberAddress(ast* code):
  if (getField code childCount == 0):
    ret ${ptr #code}
  elseif ast:matchesShape(code, ${_._}):
    recordExpr := ast:child(code, 0)
    fieldName := getField ast:child(code, 1) id
    ret ${fieldptr #recordExpr #fieldName}
  elseif ast:matchesShape(code, ${__._*}):
    nestedPtr2 := getMemberAddress ast:child( ast:child(code, 0), 0 )
    fieldName3 := ast:child( ast:child(code, 0), 1 )

    ret ${getField #nestedPtr2 #fieldName3}
  elseif ast:matchesShape(code, ${__._}):
    nestedPtr := getMemberAddress ast:child(code, 0)
    fieldName2 := getField ast:child(code, 1) id
    ret ${fieldptr #nestedPtr #fieldName2}
  elseif ast:matchesShape(code, ${__._[__]}):
    structExpr := ast:child(ast:child(code, 0), 0)
    memberName := ast:child(ast:child(code, 0), 1)
    indexExpr := ast:child(code, 1)
    memberPtr := getMemberAddress(${#structExpr.#memberName})
    ret ${ptradd (load #memberPtr) #indexExpr}
  elseif ast:matchesShape(code, ${_[__]}):
    arrayExpr := ast:child code 0
    indexExpr2 := ast:child code 1
    arrayPtr := getMemberAddress(arrayExpr)
    ret ${ptradd (load #arrayPtr) #indexExpr2}
  elseif (ast:matchesShape(code, ${__*}) || ast:matchesShape(code, ${*__})):
    ptrExpr := ast:child code 0
    ret ptrExpr
  end

  ret ${error "Do not know how to get address of this expression" #code}
end

///TODO: add support to call methods
macro op. record component:
  addr := getMemberAddress ${#record.#component}

  ret ${load #addr}
end

/// Assigning values. Supports
/// a = b - for first class types
/// a.x = b - for struct members
/// ptr[10] = b - for pointers
/// ptr* = b - for pointers
/// *ptr = b - for pointers
/// TODO: just use getMemberAddress
macro op= l r:
  if ast:matchesShape(l, ${__[__]}):
    var ast* array ast:child(l, 0)
    var ast* index ast:child(l, 1)
    var ast* arrayPtr getMemberAddress(array)
    ret ${store ptradd(*#arrayPtr, #index) #r}
  elseif ast:matchesShape(l, ${__.__}):
    laddr := getMemberAddress(l)
    ret ${store #laddr #r}
  elseif (bool:or ast:matchesShape(l, ${__*}) ast:matchesShape(l, ${*__})):
    addr := ast:child l 0
    ret ${store #addr #r}
  else:
    ret ${assign #l #r}
  end

  ret ${internal error}
end

// /// Accessing pointers like C arrays
// template postop[] array index
//   load(ptradd #array #index)
// end

macro defineArray type varname values...:
  size := values.childCount
  arrayType := ast:fromString "postop[]"
  ast:addChild arrayType type
  ast:addChild arrayType ${#size}

  code := $:
    var #arrayType #varname
  end

  valnum := 0
  forEachAstChild value values:
    ast:addChild code ${zmp:array:set #varname #valnum #value}
    valnum = valnum + 1
  end

  ret code
end

template postop[] ptr index:
  load(ptradd #ptr #index)
end

// template op+_ptr ptr offset:
//   ptradd #ptr #offset
// end

template zmp:array:get array index:
  load ptradd(zmp:array:addr &(#array), #index)
end

template zmp:array:set array index value:
  store ptradd(zmp:array:addr &(#array), #index) #value
end

// TODO rename, remove 2
func ast* cee:internal:makeInitCall(cstring typeName, ast* varPtr, ast* args):
  var ast* initCall ast:fromString(cstring:concat(typeName, ":init"))
  ast:addChild initCall varPtr
  forEachAstChild arg args:
    ast:addChild initCall arg
  end

  ret initCall
end

/// Allocate storage and initialize variable
/// `new Foo a b c' does the same as `Foo:init(malloc Foo, a, b, c)'
macro new type args...:
  uniqueId name "new"

  var ast* initCall cee:internal:makeInitCall(getField(type,id), ${#name}, args)

  ret $:
    var (ptr #type) #name (malloc #type)
    #initCall
    #name
  end
end

macro local type args...:
  uniqueId name "local"
  var ast* initCall cee:internal:makeInitCall(getField(type,id), ${ptr #name}, args)
  ret $:
    var #type #name
    #initCall
    &#name
  end
end

func void bool:init(bool* this, bool value):
  this* = value
end

func void char:init(char* this, char value):
  this* = value
end

func void int:init(int* this, int value):
  this* = value
end

func void float:init(float* this, float value):
  this* = value
end

func void double:init(double* this, double value):
  this* = value
end

template op++ lstring rstring:
  cstrings:append #lstring #rstring
end

template preop++ int:
  #int = #int + 1
  #int
end

template preop-- int:
  #int = #int - 1
  #int
end

template postop++ int:
  #int = #int + 1
  #int - 1
end

template postop-- int:
  #int = #int - 1
  #int + 1
end

func int "op**"(int l, int r):
  acc := 1
  for i 0 r:
    acc = acc * l
  end
  ret acc
end

macro swap a b:
  uniqueId t "swap"
  ret $:
    t := #a
    #a = #b
    #b = t
  end
end

macro preop& obj:
  code := getMemberAddress obj
  ret code
end

template postop& obj:
  &#obj
end

template preop* ptr:
  (load #ptr)
end

template postop* ptr:
  (load #ptr)
end

template isNotNull ptr:
  #ptr !=_ptr nullptr void
end

template isNull ptr:
  #ptr ==_ptr nullptr void
end

macro struct name members:
  unless (name.childCount == 0):
    ret ${error "Expected id (polymorphic types not supported, yet)" #name}
  end

  decl := ast:fromString "type"
  ast:addChild decl name

  forEachAstChild memberList members:
    if ast:matchesShape(memberList, ${__ _...}):
      memberType := ast:child memberList 0
      for memberNum 1 memberList.childCount:
        memberName := ast:child memberList memberNum
        ast:addChild decl ${#memberType #memberName}
      end
    else:
      ret ${error "Expected 'typeExpr id..." #memberList}
    end
  end

  ret decl
end

func bool isMultipleOf(int x, int m):
  ret (int:mod(x,m) == 0)
end

macro ast:foreach3 t0 t1 t2 tree code:
  if (bool:not isMultipleOf(tree.childCount, 3)):
    ret ${error "Can only iterate over 3-tuples if child count is a multiple of 3" tree}
  end

  uniqueId childnum "ast:foreach3"

  ret $:
    #childnum := 0
    while (#childnum + 2 < #tree.childCount):
      #t0 := ast:child #tree (#childnum+0)
      #t1 := ast:child #tree (#childnum+1)
      #t2 := ast:child #tree (#childnum+2)
      #code
      #childnum = #childnum + 3
    end
  end
end

macro ast:foreach2 t0 t1 tree code:
  if (bool:not isMultipleOf(tree.childCount, 3)):
    ret ${error "Can only iterate over pairs if child count is a multiple of 2" tree}
  end

  uniqueId childnum "ast:foreach2"

  ret $:
    #childnum := 0
    while (#childnum + 1 < #tree.childCount):
      #t0 := ast:child #tree (#childnum+0)
      #t1 := ast:child #tree (#childnum+1)
      #code
      #childnum = #childnum + 2
    end
  end
end

///
/// Will transform an expression of the form (<jux someId (<arg 0>) ..>) to
/// (<someId (<arg 0>) ...>)
///
func ast* ast:shiftLeft(ast* code):
  assert (code.childCount >= 1)
  assert (getField ast:child(code,0) childCount == 0)

  firstChild := ast:child code 0
  newcode := ast:fromString firstChild.id
  for i 1 code.childCount:
    ast:addChild newcode ast:child(code,i)
  end
  ret newcode
end

macro enum name cases:
  code := ${}
  ast:addChild code ${type #name int}

  caseNum := 0
  forEachAstChild enumCase cases:
    if ast:matchesShape(enumCase, ${_}):
      caseName := name.id ++ ":" ++ enumCase.id
      ast:addChild code ${const int #caseName #caseNum}
    else:
      ret ${error "Only identifiers allowed for enum cases" #enumCase}
    end
    ++caseNum
  end

  ret code
end

///-----------------------------------------------------------------------------
/// Section: control flow
///-----------------------------------------------------------------------------

alias do seq body...

///
/// A simple loop construct. You can break from the loop using a break
/// statement. Very experimental
///
/// TODO attention: do not nest (checking not possible, yet)...
macro cee:xp:loop code:
  uniqueId start "loop_start"
  uniqueId end "loop_end"

  ret $:
    template break:
      branch #end
    end

    label #start
    #code
    branch #start
    label #end
  end
end

/// execute code n times
macro times count code...:
  uniqueId counterVar "timesCounter"
  ret ${for #counterVar 0 #count #code}
end

///
/// switch statement
///
/// Example:
///
/// switch _intExpression
///   void
/// case _intExpression
///   _code
/// ...
/// end
///
macro switch intvalue default cases...:
  uniqueId value "the_value"

  first := true
  code := ${if false:
    printNewline()
  end}

  ast:foreach3 case caseval casecode cases:
    unless ast:matchesShape(case, ${case}):
      caseNode := ast:shiftLeft ${#case #caseval #casecode}
      ret ${error "Expected 'case VAL EXPR'" #caseNode}
    end

    ast:addChild code $elseif
    ast:addChild code ${#value == #caseval}
    ast:addChild code casecode
  end

  code = $:
    var int #value #intvalue
    #code
  end

  ret code
end

/// put multiple statements into a single line like
///   print "foo"; println()
template op; a b:
  #a
  #b
end

macro opkeyword rem...:
  code := ast:fromString "tobereplaced"

  id := "kwd"

  ast:foreach2 kwd block rem:
    id = id ++ "_" ++ kwd.id
    ast:addChild code block
  end

  code.id = id

  ret code
end

/// return unless: everything == ok
template kwd_default_unless block cond:
  unless #cond #block
end

/// return if: result == error
template kwd_default_if block condition:
  if #condition #block
end

// /// Use {} for blocks inside a single line
// /// not yet in libcee, as it can be replaced with () anyways so it might be better
// /// to safe this for other things
// macro op{} statements...:
//   code := ${seq}
//   forEachAstChild stmnt statements:
//     ast:addChild code stmnt
//   end
//   ret code
// end

///-----------------------------------------------------------------------------
/// Section: Overloaded operators
///-----------------------------------------------------------------------------

func ast* defineOpCode(cstring type, cstring rettype, cstring opr, cstring func):
  funcname := type ++ ":" ++ func
  oprname := opr ++ "_" ++ type ++ "_" ++ type

  ret $:
    func #rettype #oprname(#type l, #type r):
      #funcname(l, r)
    end
  end
end

alias u8:div u8:sdiv l r
alias u16:div u16:sdiv l r
alias u32:div u32:sdiv l r
alias u64:div u64:sdiv l r

// TODO!
func char char:add(char l, char r):
  ret '?'
end
func char char:sub(char l, char r):
  ret '?'
end
func char char:mul(char l, char r):
  ret '?'
end
func char char:div(char l, char r):
  ret '?'
end


alias float:div float:fdiv l r
alias float:greater float:ogreater l r
alias float:greaterEqual float:ogreaterEqual l r
alias float:less float:oless l r
alias float:lessEqual float:olessEqual l r

alias double:equal double:oequal l r
alias double:notEqual double:onotEqual l r
alias double:div double:fdiv l r
alias double:greater double:ogreater l r
alias double:greaterEqual double:ogreaterEqual l r
alias double:less double:oless l r
alias double:lessEqual double:olessEqual l r

macro overloadedOps type:
  macro defop_ rettype opr name:
    oprName := cstring:quote opr.id
    funcName := cstring:quote name.id

    ret $:
      ast:addChild code (defineOpCode type.id #rettype #oprName #funcName)
    end
  end

  code := ${}

  defop_ "bool" op== equal
  defop_ "bool" op!= notEqual
  defop_ "bool" op> greater
  defop_ "bool" op>= greaterEqual
  defop_ "bool" op< less
  defop_ "bool" op<= lessEqual

  defop_ type.id op+ add
  defop_ type.id op- sub
  defop_ type.id op* mul
  defop_ type.id op/ div

  ret code
end

overloadedOps u8
overloadedOps u16
overloadedOps u32
overloadedOps u64
overloadedOps float
overloadedOps double
overloadedOps char

template op+ l r:
  zmp:cee:add #l #r
end

template op- l r:
  zmp:cee:sub #l #r
end

template op* l r:
  zmp:cee:mul #l #r
end

template op/ l r:
  zmp:cee:div #l #r
end

template op| l r:
  zmp:cee:or #l #r
end

template op& l r:
  zmp:cee:and #l #r
end

template op^ l r:
  zmp:cee:xor #l #r
end

template op% l r:
  u32:mod #l #r
end

template op+= l r:
  #l = #l + #r
end

template op+.= l r:
  #l = #l +. #r
end

template op++= l r:
  #l = #l ++ #r
end

template op-= l r:
  #l = #l - #r
end

template op*= l r:
  #l = #l * #r
end

template op/= l r:
  #l = #l / #r
end

template op**= l r:
  #l = #l ** #r
end

template op&= l r:
  #l = #l & #r
end

template op|= l r:
  #l = #l | #r
end

template op^= l r:
  #l = #l ^ #r
end

template op%= l r:
  #l = #l % #r
end

template op&&= l r:
  #l = #l && #r
end

template op||= l r:
  #l = #l || #r
end

template op<<= l r:
  #l = #l << #r
end

template op>>= l r:
  #l = #l >> #r
end

template op%= l r:
  #l = #l % #r
end

template preop- v:
  zmp:cee:neg #v
end

template preop! v:
  zmp:cee:not #v
end

template op== l r:
  zmp:cee:equal #l #r
end

template op!= l r:
  bool:not (#l == #r)
end

template op> l r:
  zmp:cee:greater #l #r
end

template op>= l r:
  zmp:cee:greaterEqual #l #r
end

template op< l r:
  zmp:cee:less #l #r
end

template op<= l r:
  zmp:cee:lessEqual #l #r
end

func bool op<_ptr_ptr(void* l, void* r):
  ret u32:uless(cast int l, cast int r)
end

func bool op>_ptr_ptr(void* l, void* r):
  ret u32:ugreater(cast int l, cast int r)
end

func bool op<=_ptr_ptr(void* l, void* r):
  ret u32:ulessEqual(cast int l, cast int r)
end

func bool op>=_ptr_ptr(void* l, void* r):
  ret u32:ugreaterEqual(cast int l, cast int r)
end

func bool op!=_ptr_ptr(void* l, void* r):
  ret u32:notEqual(cast int l, cast int r)
end

func bool op==_ptr_ptr(void* l, void* r):
  ret u32:equal(cast int l, cast int r)
end

func bool op==_bool_bool(bool l, bool r):
  ret bool:not(bool:xor l r)
end

func bool op&_bool_bool(bool l, bool r):
  ret bool:and(l, r)
end

func bool op|_bool_bool(bool l, bool r):
  ret bool:or(l, r)
end

func bool op^_bool_bool(bool l, bool r):
  ret bool:xor(l, r)
end

func u32 op&_u32_u32(u32 l, u32 r):
  ret u32:and(l, r)
end

func u32 op|_u32_u32(u32 l, u32 r):
  ret u32:or(l, r)
end

func u32 op^_u32_u32(u32 l, u32 r):
  ret u32:xor(l, r)
end

func int neg_u32(int x):
  ret int:neg(x)
end

func float neg_float(float x):
  ret float:neg(x)
end

func double neg_double(double x):
  ret (0.0d - x)
end

func bool not_bool(bool x):
  ret bool:not(x)
end

///-----------------------------------------------------------------------------
/// Section: Overloaded printing
///-----------------------------------------------------------------------------

func void print_u8(u8 i):
  printInt (cast u32 i)
end

func void print_u16(u16 i):
  printInt (cast u32 i)
end

func void print_u32(int i):
  printInt i
end

func void print_u64(u64 i):
  printf("%ld", i)
  ret // work-around to avoid error when last expression does not return void
end

func void print_float(float f):
  printFloat f
end

func void print_char(char c):
  printChar c
end

func void print_bool(bool b):
  printBool b
end

func void print_double(double d):
  printDouble d
end

func void print_ptr(void* ptr):
  printPtr ptr
end

func void "print_char*"(char* string):
  printString string
end

func void "print_ast*"(ast* code):
  ast:print code 0
end

macro print args...:
  var astp code ${}

  forEachAstChild arg args:
    ast:addChild code ${zmp:cee:print #arg}
  end

  ret code
end

/// print indent levels of spaces, then pass remaining arguments to print macro
macro iprint indent args...:
  var astp code $:
    printIndent #indent
  end

  forEachAstChild arg args:
    ast:addChild code ${zmp:cee:print #arg}
  end

  ret code
end

/// as iprint but pass arguments to println macro
macro println args...:
  var astp code ${}

  forEachAstChild arg args:
    ast:addChild code ${zmp:cee:print #arg}
  end

  ast:addChild code ${printNewline()}

  ret code
end

macro iprintln indent args...:
  var astp code $:
    printIndent #indent
  end

  forEachAstChild arg args:
    ast:addChild code ${zmp:cee:print #arg}
  end

  ast:addChild code ${printNewline()}

  ret code
end

func void printBits(int bitmask):
  printString "0b"
  for i 0 32:
    bitnum := 31 - i
    mask := int:shl 1 bitnum
    bit := int:lshr (int:and bitmask mask) bitnum
    printInt bit
  end
end

std:base:func void printHLine(char chr, int count):
  times count (printChar chr)
  printNewline()
end



macro structlit structType fieldsAndValues...:
  uniqueId structVar "struct"

  code := $:
    var #structType #structVar
  end

  ast:foreach2 field value fieldsAndValues:
    ast:addChild code ${#structVar.#field = #value}
  end

  ast:addChild code ${#structVar}
  ret code
end

///-----------------------------------------------------------------------------
/// Section: Overloaded conversion
///-----------------------------------------------------------------------------

alias toInt zmp:cee:toInt x
alias toFloat zmp:cee:toFloat x
alias toDouble zmp:cee:toDouble x
alias toChar zmp:cee:toChar x
alias toCString zmp:cee:toCString x
alias toBool zmp:cee:toBool x

func int toInt_u32(int i):
  ret i
end

func int toInt_float(float f):
  float:toInt f
end

func int toInt_double(double d):
  double:toInt d
end

func int toInt_char(char c):
  ret char:zextToU32(c)
end

func int toInt_bool(bool b):
  if b:
    ret 1
  end
  ret 0
end


func float toFloat_u32(u32 i):
  int:toFloat i
end

func float toFloat_double(double d):
  double:toFloat d
end

func float toFloat_float(float f):
  ret f
end

func float toFloat_bool(bool b):
  toFloat(toInt b)
end


func double toDouble_u32(int i):
  int:toDouble i
end

func double toDouble_float(float f):
  float:toDouble f
end

func double toDouble_double(double d):
  ret d
end

func double toDouble_bool(bool b):
  toDouble(toInt b)
end


func char toChar_u32(int i):
  ret u32:toChar(i)
end


func char* toCString_u32(int i):
  int2cstring i
end

func char* toCString_float(float f):
  float2cstring f
end

func char* toCString_double(double d):
  double2cstring d
end

func char* toCString_char(char c):
  char2cstring c
end

func char* toCString_bool(bool b):
  ret bool2cstring(b)
end

func char* "toCString_char*"(char* c):
  c
end

func bool toBool_u32(u32 i):
  return (i != 0)
end

func bool toBool_float(float f):
  return (f != 0.0f)
end

func bool toBool_double(double d):
  return (d != 0.0d)
end

func bool toBool_bool(bool b):
  return b
end

/// Define an overloaded function. Currently only works for function names which
/// are listed in Expander.Overloaded_ops in source/expander.ml
macro ofunc rettype nameAndArgs impl:
  if ast:matchesShape(nameAndArgs, ${_(__...)}):
    name := getField(ast:child nameAndArgs 0, id)
    newNameAndArgs := ${_()}

    for i 1 nameAndArgs.childCount:
      param := ast:child nameAndArgs i

      if ast:matchesShape(param, ${__ _}):
        paramType := ast:child param 0
        if (paramType.childCount > 0):
          ret ${error "ofunc: Only supporting type names which are an id atm" #paramType}
        end
        paramName := ast:child param 1
        ast:addChild newNameAndArgs ${#paramType #paramName}
        name = name ++ "_" ++ paramType.id
      else:
        ret ${error "Invalid parameter, expected 'TYPE_EXPR NAME" ${#param}}
      end
    end

    nameAst := ast:child newNameAndArgs 0
    nameAst.id = name
    ret ${func #rettype #newNameAndArgs #impl}
  end

  ret ${error "Expected 'ofunc RETTYPE funcName(args...)'" ${ofunc #rettype #nameAndArgs "..."}}
end

///-----------------------------------------------------------------------------
/// Section: Assertions and testing
///-----------------------------------------------------------------------------

func bool isCompareCode(ast* testCode):
  isCompare := false

  if (testCode.childCount == 2):
    compareF := testCode.id
    if (compareF ==_str "op==" ||
        compareF ==_str "op!=" ||
        compareF ==_str "op==_f" ||
        compareF ==_str "op!=_f" ||
        compareF ==_str "op==_str" ||
        compareF ==_str "op!=_str" ||
        compareF ==_str "op<" ||
        compareF ==_str "op<=" ||
        compareF ==_str "op>" ||
        compareF ==_str "op>="):
      return true
    end
  end

  return false
end

macro assert testCode:
  isCompare := isCompareCode(testCode)

  if isCompare:
    uniqueId lvar "lvar"
    uniqueId rvar "rvar"
    compareF := testCode.id
    l := ast:child(testCode, 0)
    r := ast:child(testCode, 1)
    ret $:
      #lvar := #l
      #rvar := #r
      unless (#compareF #lvar #rvar):
        printHLine '-' 40
        printlnString "Assertion failed"
        printString "left = "
        print #lvar
        println()
        printString "right = "
        print #rvar
        println()
        ast:print ${#testCode} 0
      end
    end
  else:
    ret $:
      unless #testCode:
        printHLine '-' 40
        printlnString "Assertion failed"
        ast:print ${#testCode} 0
      end
    end
  end

  ret ${}
end

///-----------------------------------------------------------------------------
/// Section: enums
///-----------------------------------------------------------------------------

macro enum name fields:
  code := $:
    type #name:
      int value
    end
  end

  value := -1

  forEachAstChild field fields:
    qualifiedName := ""
    if ast:matchesShape(field, ${_}):
      qualifiedName = name.id ++ ":" ++ field.id
      value = value + 1
    elseif ast:matchesShape(field, ${_ = _}):
      qualifiedName = name.id ++ ":" ++ getField(ast:child field 0, id)
      value = parseInt getField(ast:child field 1, id)
    else:
      ret ${error "expected 'Identifier' or 'Identifier = IntValue'" #field}
    end

    ast:addChild code ${const #name #qualifiedName #name(value = #value)}
  end

  toIntF := "toInt_" ++ name.id
  ast:addChild code $:
    func int #toIntF(#name enumValue):
      return enumValue.value
    end
  end

  opEqualF := "op==_" ++ name.id ++ "_" ++ name.id
  ast:addChild code $:
    func bool #opEqualF(#name l, #name r):
      return (l.value == r.value)
    end
  end

  opNotEqualF := "op!=_" ++ name.id ++ "_" ++ name.id
  ast:addChild code $:
    func bool #opNotEqualF(#name l, #name r):
      return (l.value != r.value)
    end
  end

  // TODO: print symbolic name instead of int
  quotedName := cstring:quote name.id
  printF := "print_" ++ name.id
  ast:addChild code $:
    func void #printF(#name enumValue):
      print #quotedName "(value = " enumValue.value ")"
    end
  end

  ret code
end


