/**
 * Common math utilities for 3d graphics

!verify off
 */

require "libs/libcee.zomp"

///-----------------------------------------------------------------------------
/// Section: Constants
///-----------------------------------------------------------------------------

var float math:e 2.71828182845904523536028747135266250
var float math:log2e 1.44269504088896340735992468100189214
var float math:log10e 0.434294481903251827651128918916605082
var float math:ln2 0.693147180559945309417232121458176568
var float math:ln10 2.30258509299404568401799145468436421
var float math:pi 3.14159265358979323846264338327950288
var float math:pi_2 1.57079632679489661923132169163975144
var float math:pi_4 0.785398163397448309615660845819875721
var float math:sqrt2 1.41421356237309504880168872420969808
var float math:sqrt1_2 0.707106781186547524400844362104849039

///-----------------------------------------------------------------------------
/// Section: Util functions
///-----------------------------------------------------------------------------

func float sqrf(float x)
  x * x
end

func float posmod(float x, float divisor)
  mod := fmodf(x, divisor)

  if (mod < 0.0)
    mod = divisor - float:neg(mod)
  end

  ret mod
end

///-----------------------------------------------------------------------------
/// Section: vector math
///-----------------------------------------------------------------------------

struct v3f
  float x y z
end

func v3f mv3f(float x, float y, float z)
  ret (structlit v3f x x y y z z)
end

func void v3f:print(v3f this)
  print "v3f(x=" this.x ", y=" this.y ", z=" this.z ")"
end

ofunc void print(v3f this)
  v3f:print this
end

func float v3f:length(v3f this)
  ret sqrtf(sqrf this.x + sqrf this.y + sqrf this.z)
end

func void v3f:set(v3f* this, float x, float y, float z)
  this.x = x
  this.y = y
  this.z = z
end

ofunc bool op==(v3f l, v3f r)
  ret ((l.x==r.x) && (l.y==r.y) && (l.z==r.z))
end

ofunc v3f op+(v3f l, v3f r)
  ret (structlit v3f x (l.x+r.x) y (l.y+r.y) z (l.z+r.z))
end

ofunc v3f op-(v3f l, v3f r)
  ret (structlit v3f x (l.x-r.x) y (l.y-r.y) z (l.z-r.z))
end

func float op*_dot(v3f l, v3f r)
  ret (l.x*r.x + l.y*r.y + l.z*r.z)
end

func v3f op*_cross(v3f l, v3f r)
  ret (structlit v3f x (l.y*r.z - l.z*r.y) y (l.z*r.x - l.x*r.z) z (l.x*r.y - l.y*r.x))
end

ofunc v3f op*(v3f v, float factor)
  ret (structlit v3f x (v.x * factor) y (v.y * factor) z (v.z * factor))
end

ofunc v3f op*(float factor, v3f v)
  ret (v * factor)
end

func v3f v3f:normalized(v3f v)
  l := 1.0 / v3f:length(v)
  ret mv3f(v.x * l, v.y * l, v.z * l)
end

///-----------------------------------------------------------------------------
/// Section: triangles
///-----------------------------------------------------------------------------

func float triangleArea(v3f v1, v3f v2, v3f v3)
  a := v1 *_cross v2
  b := v2 *_cross v3
  c := v3 *_cross v1

  ret (0.5 * v3f:length(a+b+c))
end

///-----------------------------------------------------------------------------
/// Section: bounding boxes
///-----------------------------------------------------------------------------

struct AABB
  v3f min max
end

func void AABB:init(AABB* this)
  this.min.x = 0.0
  this.min.y = 0.0
  this.min.z = 0.0
  this.max.x = 0.0
  this.max.y = 0.0
  this.max.z = 0.0
end

func void AABB:print(AABB* this)
  print "AABB(min: x=" this.min.x ", y=" this.min.y ", z=" this.min.z
  print " max: x=" this.max.x ", y=" this.max.y ", z=" this.max.z ")"
end

func void AABB:diagonal(v3f* result, AABB* this)
  result.x = this.max.x - this.min.x
  result.y = this.max.y - this.min.y
  result.z = this.max.z - this.min.z
end

func float AABB:diagonalLength(AABB* this)
  var v3f diag
  AABB:diagonal &diag this
  ret v3f:length(diag)
end

///-----------------------------------------------------------------------------
/// Section: coordinate systems
///-----------------------------------------------------------------------------

struct OrthoBasis3D
  v3f xaxis yaxis zaxis
end

ofunc void print(OrthoBasis3D basis)
  println "OrthoBasis3D"
  println "  xaxis = " basis.xaxis
  println "  yaxis = " basis.yaxis
  println "  zaxis = " basis.zaxis
end

func OrthoBasis3D makeOrthoBasis(v3f vec)
  var OrthoBasis3D basis
  var v3f v

  xa := fabsf vec.x
  ya := fabsf vec.y
  za := fabsf vec.z

  if ((xa <= ya) && (xa <= za))
    println "x"
    v = mv3f 0. float:neg(vec.z) vec.y
  elseif ((ya <= xa) && (ya <= za))
    println "y"
    v = mv3f float:neg(vec.z) 0. vec.x
  elseif ((za <= xa) && (za <= ya))
    println "z"
    v = mv3f float:neg(vec.y) vec.x 0.
  end

  println v

  basis.xaxis = vec
  basis.yaxis = v * (1.0 / v3f:length v)
  basis.zaxis = basis.xaxis *_cross basis.yaxis

  ret basis
end

///-----------------------------------------------------------------------------
/// Section: compatibility
///-----------------------------------------------------------------------------

// deprecated
struct float3
  float x y z
end

func void float3:print(float3* this)
  print "float3(x=" this.x ", y=" this.y ", z=" this.z ")"
end

func float float3:length(float3* this)
  ret sqrtf(sqrf this.x + sqrf this.y + sqrf this.z)
end

