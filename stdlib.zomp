///
/// The Zomp prelude
/// Contains definitions and methods which are available everywhere
///

/*
!verify off
*/

type int u32

///-----------------------------------------------------------------------------
/// Section: Content of stdlib.c
///-----------------------------------------------------------------------------

std:base:func void printInt(int i)
std:base:func void printString(char* s)
std:base:func void printFloat(float f)
std:base:func void printDouble(double d)
std:base:func void printChar(char c)
std:base:func void printPtr(void* ptr)
std:base:func void printNewline()
std:base:func void flushStdout()

std:base:func char* int2cstring(int i)
std:base:func char* float2cstring(float f)
std:base:func char* double2cstring(double d)
std:base:func char* char2cstring(char c)

std:base:func char* copyString(char* str)

///-----------------------------------------------------------------------------
/// Section: ZompVM
///-----------------------------------------------------------------------------

std:base:func int zompLoadLib(char* libname)
std:base:func bool zompRequestedPause()
std:base:func void zompSetRequestPause(bool request)

std:base:func int zompLoadFileToMemory(char* filename, char** content)

std:base:func void stdlibHello()

///-----------------------------------------------------------------------------
/// Section: C library
///-----------------------------------------------------------------------------

std:base:func void exit(int exitCode)

std:base:func double sin(double x)
std:base:func double cos(double x)
std:base:func float sinf(float x)
std:base:func float cosf(float x)

std:base:func float atanf(float x)
std:base:func float asinf(float x)
std:base:func float acosf(float x)

std:base:func int abs(int x)
std:base:func float fabsf(float l)

std:base:func float fmodf(float num, float divisor)

std:base:func float sqrtf(float x)

///-----------------------------------------------------------------------------
/// Section: Utility functions
///-----------------------------------------------------------------------------

std:base:func bool bool:not(bool b)
  bool:xor true b
end

std:base:func int square(int x)
  u32:mul x x
end

std:base:func float squaref(float x)
  float:mul x x
end

std:base:func void printBool(bool b)
  branch b true false

  label true
  printChar 't'
  branch end

  label false
  printChar 'f'

  label end
end

macroReplace funcln name type printF
  std:base:func void name(type v)
    printF v
    printNewline()
  end
end

funcln printlnInt int printInt
funcln printlnString char* printString
funcln printlnFloat float printFloat

macroReplace getField record componentName
  load (fieldptr record componentName)
end

macroReplace setField record componentName value
  store (fieldptr record componentName) value
end

///-----------------------------------------------------------------------------
/// Section: String functions
///-----------------------------------------------------------------------------


type cstring (ptr char)

std:base:func int strcmp(cstring l, cstring r)
std:base:func int strncmp(cstring l, cstring r, int maxChars)
std:base:func cstring strcpy(cstring dest, cstring source)
std:base:func int strlen(cstring str)

std:base:func cstring u32:toCString(int x)
  int2cstring x
end

type string
  int length
  char* chars
end

type pstring string*

std:base:func int length(cstring s)
  var char* ptr s
  var int count -1

  var char c 'x'
  var bool b true

  label start
  assign c (load ptr)

  assign ptr (ptradd ptr 1)
  assign count (u32:add count 1)
  assign b (char:equal c '\0')
  branch b end start

  label end

  std:base:ret count
end

std:base:func string* makestring(cstring cstr)
  var (ptr string) pstr (malloc string)
  store (fieldptr pstr length) (length cstr)
  store (fieldptr pstr chars) cstr
  std:base:ret pstr
end

std:base:func string* newString(int length, char init)
  var (ptr char) chars (malloc char (u32:add 1 length))
  store (ptradd chars length) '\0'
  var int index 0
  var bool reachedEnd false
  label start
  store (ptradd chars index) init
  assign index (u32:add index 1)
  assign reachedEnd (u32:ugreaterEqual index length)
  branch reachedEnd end start
  label end

  var (ptr string) result (malloc string)
  store (fieldptr result length) length
  store (fieldptr result chars) chars
  std:base:ret result
end

std:base:func string* append(string* l, string* r)
  var int length (u32:add (getField l length) (getField r length))
  var (ptr string) result (newString length 'x')
  var (ptr char) chars (getField result chars)
  var (ptr char) leftChars (getField l chars)
  var int leftLength (getField l length)
  var (ptr char) rightChars (getField r chars)
  var int rightLength (getField r length)

  var int index 0

  label lbegin
  store (ptradd chars index) (load (ptradd leftChars index))
  assign index (u32:add index 1)
  var bool test (u32:uless index leftLength)
  branch test lbegin lend
  label lend

  assign index 0
  label rbegin
  store (ptradd chars (u32:add leftLength index)) (load (ptradd rightChars index))
  assign index (u32:add index 1)
  var bool test2 (u32:uless index rightLength)
  branch test2 rbegin rend
  label rend

  std:base:ret result
end


/// print count spaces
std:base:func void printIndent(int count)
  var int counter count
  label start
  var bool t (u32:ugreater counter 0)
  branch t goon end
  label goon
  printChar ' '
  assign counter (u32:sub counter 1)
  branch start
  label end
end

std:base:func bool cstring:equal(cstring l, cstring r)
  std:base:ret (u32:equal 0 (strcmp l r))
end

std:base:func cstring cstring:quote(cstring unquoted)
  var int unquotedLength (length unquoted)
  var cstring quoted (malloc char (u32:add unquotedLength 3))

  strcpy (ptradd quoted 1) unquoted
  store quoted '"' // "
  store (ptradd quoted (u32:add unquotedLength 1)) '"' // "
  store (ptradd quoted (u32:add unquotedLength 2)) '\0'

  std:base:ret quoted
end


///-----------------------------------------------------------------------------
/// Section: Abstract syntax tree representation
///-----------------------------------------------------------------------------

type ast
  cstring id
  int childCount
  ast** childs
end
type astp ast*

std:base:func cstring cstrings:append(cstring l, cstring r)

std:base:func ast* ast:fromString(cstring name)
  var ast* a (malloc ast)

  store (fieldptr a id) (cstrings:append name "")
  store (fieldptr a childCount) 0
  store (fieldptr a childs) (nullptr ast*)

  std:base:ret a
end

std:base:func (ptr ast) seqAst()
  ast:fromString "seq"
end

std:base:func (ptr ast) ast:fromInt(int i)
  ast:fromString (int2cstring i)
end

std:base:func astp ast:fromFloat(float f)
  ast:fromString (float2cstring f)
end

std:base:func void ast:print((ptr ast) a, int indent)
  printIndent indent
  printString (load (fieldptr a id))
  printString " ["
  printInt (getField a childCount)
  printString " childs]"
  printNewline()

  var int index 0
  label start
  var bool t (u32:uless index (getField a childCount))
  branch t goon end
  label goon
  var (ptr ast) child (load (ptradd (getField a childs) index))
  ast:print child (u32:add indent 4)
  assign index (u32:add index 1)
  branch start
  label end
end

std:base:func void ast:addChild((ptr ast) tree, (ptr ast) child)
  var int oldChildCount (getField tree childCount)
  var int newChildCount (u32:add 1 oldChildCount)
  var (ptr (ptr ast)) newChilds (malloc (ptr ast) newChildCount)

  var int index 0
  label start
  var bool t (u32:uless index oldChildCount)
  branch t goon end
  label goon
  store (ptradd newChilds index) (load (ptradd (getField tree childs) index))
  assign index (u32:add index 1)
  branch start
  label end

  store (ptradd newChilds oldChildCount) child

  setField tree childs newChilds
  setField tree childCount newChildCount
end

/// get pointer to index-th child of parent
std:base:func astp ast:child((ptr ast) parent, int index)
  var (ptr ast) child (load (ptradd (getField parent childs) index))
  std:base:ret child
end

///-----------------------------------------------------------------------------
/// Section: Macro support
///-----------------------------------------------------------------------------

var cstring macroRest "postop..."

std:base:func cstring macroAstId(astp macroCurrentAst)
  var cstring name (getField (cast (ptr ast) macroCurrentAst) id)
  std:base:ret name
end

std:base:func int macroAstChildCount(astp macroCurrentAst)
  getField macroCurrentAst childCount
end

std:base:func astp macroAstChild(astp tree, int num)
  // var (ptr ast) tree (cast (ptr ast) treeaddr)
  var (ptr ast) child (load (ptradd (getField tree childs) num))
  // var int i (cast int child)
  // std:base:ret i
  std:base:ret child
end

std:base:func astp testMacro2(astp lastArg)
  std:base:ret ${native (nested tree) (with (args a b c #lastArg))}
end

std:base:func int macroExec()
  var astp tree (testMacro2 ${foo bar})
  var int i (cast int tree)
  std:base:ret i
end

std:base:func astp macroTest()
  std:base:ret ${macro test}
end

var int lastid 0

std:base:func int newUniqueId()
  assign lastid (u32:add lastid 1)
  std:base:ret lastid
end

std:base:func cstring cstrings:append(cstring l, cstring r)
  var (ptr string) lstr (makestring l)
  var (ptr string) rstr (makestring r)
  var (ptr string) appended (append lstr rstr)
  std:base:ret (getField appended chars)
end

std:base:func cstring newUniqueName()
  var int id (newUniqueId)
  var cstring numstr (int2cstring id)
  std:base:ret (cstrings:append "_tmp_" numstr)
end

std:base:func cstring newUniqueNameFor(cstring purpose)
  var cstring name (newUniqueName)
  std:base:ret (cstrings:append (cstrings:append name "_") purpose)
end

macro uniqueId name purpose
  std:base:ret ${var cstring #name (newUniqueNameFor #purpose)}
end

/// workaround until "const" is properly supported
macro const type name default
  std:base:ret ${var #type #name #default}
end

macro ret expr
  std:base:ret ${std:base:ret #expr}
end

///-----------------------------------------------------------------------------
/// Section: control flow
///-----------------------------------------------------------------------------

macro for index min supremum code
  uniqueId startLabel "for_start"
  uniqueId endLabel "for_exit"
  uniqueId testResult "for_testvar"
  uniqueId execLabel "for_body"

  ret ${
    var int #index #min
    var bool #testResult false

    label #startLabel

    assign #testResult (u32:sless #index #supremum)
    branch #testResult #execLabel #endLabel

    label #execLabel
    #code
    assign #index (u32:add #index 1)
    branch #startLabel

    label #endLabel
  end}
end

macro while test body...
  uniqueId begin "while_begin"
  uniqueId exit "while_exit"
  uniqueId goon "while_body"
  uniqueId testVar "while_testvar"

  ret ${
    var bool #testVar true
    label #begin
    assign #testVar (#test)
    branch #testVar #goon #exit
    label #goon
    #body
    branch #begin
    label #exit
  end}
end

macro when test onTrue
  uniqueId trueLabel "when_block"
  uniqueId endLabel "when_end"
  uniqueId testResult "when_testresult"

  var ast* result ${
    var bool #testResult #test
    branch #testResult #trueLabel #endLabel
    label #trueLabel
    #onTrue
    label #endLabel
  end}
  ret result
end

macro unless test onFalse
  uniqueId testResult "unless_testresult"
  uniqueId falseLabel "unless_block"
  uniqueId endLabel "unless_end"

  ret ${
    var bool #testResult #test
    branch #testResult #endLabel #falseLabel
    label #falseLabel
    #onFalse
    label #endLabel
  end}
end

/// if statement
///
/// Usage example:
///
/// if a > 10 then
///   print "It's bigger!"
/// else if a < 5 then
///   print "It's smaller!"
/// else
///   print "Neither to big nor to small. Purrfect"
/// end
macro if cond onTrue remArgs...
  uniqueId endLabel "if_end"

  var astp code ${seq}

  ast:addChild code ${when #cond
    #onTrue
    branch #endLabel
  end}

  var int currentArg 0
  const int argCount getField(remArgs, childCount)

  while (u32:slessEqual (u32:add currentArg 3) argCount)
    var astp econd ast:child(remArgs, u32:add currentArg 1)
    var astp eexpr ast:child(remArgs, u32:add currentArg 2)

    ast:addChild code ${seq
      when #econd
        #eexpr
        branch #endLabel
      end
    end}

    assign currentArg u32:add(currentArg, 3)
  end

  when (u32:sless (u32:add currentArg 1) argCount)
    var astp elseCode ast:child(remArgs, u32:add currentArg 1)

    ast:addChild code elseCode
  end

  ast:addChild code ${label #endLabel}

  ret code
end

///TODO: generalize for arbitrary types once this is possible in zomp
macro ifExprInt test onTrue onFalse
  uniqueId trueLabel "iftrue"
  uniqueId falseLabel "iffalse"
  uniqueId endLabel "ifend"
  uniqueId testResult "iftestresult"
  uniqueId resultVar "ifResult"

  var (ptr ast) result ${
    var int #resultVar 0
    var bool #testResult #test
    branch #testResult #trueLabel #falseLabel

    label #trueLabel
    assign #resultVar #onTrue
    branch #endLabel

    label #falseLabel
    assign #resultVar #onFalse

    label #endLabel
    #resultVar
  end}
  ret result
end

macro times count code...
  uniqueId counterVar "timesCounter"
  ret ${for #counterVar 0 #count #code}
end

/// execute code for each node of ast
macro forEachAstChild childVar tree code
  uniqueId count "count"
  uniqueId index "index"

  ret ${
    const int #count (getField #tree childCount)
    for #index 0 #count
      const (ptr ast) #childVar (ast:child #tree #index)
      #code
    end
  end}
end

/// A template is like a macro but is defined in another way.
/// Instead of writing a function which produces the final ast
/// you simply write down the produced ast directly. You can
/// use antiquotes to calculate parts of the ast from arbitrary
/// code expressions
macro template name argsAndImpl...
  var (ptr ast) t (ast:fromString "macro")
  ast:addChild t name

  const int argCount (getField argsAndImpl childCount)
  for argnum 0 argCount
    const (ptr ast) arg (ast:child argsAndImpl argnum)
    var bool firstArg (u32:uless argnum (u32:sub argCount 1))
    when firstArg
      ast:addChild t arg
    end
    unless firstArg
      var (ptr ast) foo (ast:fromString "quote")
      ast:addChild foo arg
      var (ptr ast) reti (ast:fromString "ret")
      ast:addChild reti foo
      ast:addChild t reti
    end
  end

  ret t
end

macro compilerMessage text...
  printString "[message] "
  forEachAstChild child text
    printString (getField child id)
    printString " "
  end
  printNewline()
  ret ${}
end

std:base:func void compiler:printWarning(cstring message)
  printString "Warning: "
  printString message
  printNewline()
end

template compiler:error message... (ret ${error #message})

/// quickly define a test function to be run with C-c,t in emacs
template testf impl... (std:base:func void test seq #impl)

macro assert checkCode
  ret ${
    when (bool:not (#checkCode))
      printlnString "Assertion failed"
      ast:print ${#checkCode} 0
      exit 1
    end
  end}
end

std:base:func void printHLine(char chr, int count)
  times count (printChar chr)
  printNewline()
end

macro cstring:concat firstString strings...
  var (ptr ast) code ${}
  uniqueId resultString "cstring_concat"

  ast:addChild code ${var cstring #resultString #firstString}

  forEachAstChild string strings
    ast:addChild code ${assign #resultString (cstrings:append #resultString #string)}
  end

  ast:addChild code ${#resultString}

  ret code
end


///-----------------------------------------------------------------------------
/// Section: Unit tests
///-----------------------------------------------------------------------------

var int unittest:failedCount 0

/// Executes the given expression and prints an error
/// message containing the passed ast if it does not
/// evaluate to true
macro unittest:assert testCode
  ret ${
    unless #testCode
      assign unittest:failedCount (int:add unittest:failedCount 1)
      printHLine '-' 40
      printlnString "error: Assertion failed"
      ast:print ${#testCode} 0
    end
  end}
end

/// Calls unittest:assert on all childs of the passed
/// sequence expression
macro unittest:assertAll checks
  var (ptr ast) code ${}
  forEachAstChild check checks
    when (cstring:equal (getField check id) "opseq")
      printlnString "Warning: unittest:assertAll found opseq expression. This might indicate using this from indent syntax code which is not supported"
    end
    ast:addChild code ${unittest:assert #check}
  end

  ret code
end


/// Will define a function name_tests_nr which will
/// call all unittest:assert on all given testCases
macro unittest:testCasesFor name testCases...
  var cstring testName (cstring:concat "test_" (getField name id) "_" (u32:toCString (newUniqueId)))

  var astp impl (ast:fromString "unittest:assertAll")
  forEachAstChild testCase testCases
    ast:addChild impl testCase
  end
  var ast* decl ast:fromString("opcall")
  ast:addChild decl ast:fromString(testName)
  var astp funcDecl ${std:base:func void #decl
    #impl
  end}

  ret funcDecl
end

std:base:func cstring unittest:newTestFuncNameFor(cstring funcName)
  cstring:concat "test_" funcName "_" (u32:toCString (newUniqueId))
end

macro unittest:testFunc funcName impl
  var cstring testFuncName (unittest:newTestFuncNameFor (getField funcName id))
  var ast* decl ast:fromString("opcall")
  ast:addChild decl ast:fromString(testFuncName)
  ret ${std:base:func void #decl #impl}
end

///-----------------------------------------------------------------------------
/// Section: More
///-----------------------------------------------------------------------------

/// Prints the passed ast to stdout at compile time
/// and will return it at run time. Can be used to debug
/// a specific macro using mret instead of ret
template mret code
  printNewline()
  ast:print #code 0
  ret #code
end

template pret code
  printNewline()
  ast:print #code 0
  ret ${}
end

// not supported for now
// /// Will define a function which will be executed only on
// /// the first call and will print a warning on subsequent calls
// macro runOnceFunc rettype name args impl
//   uniqueId initialized (cstrings:append (getField name id) "_already_called")
//
//   ret ${
//     var bool #initialized false
//     func #rettype #name #args
//       when #initialized
//         printString (getField ${#name} id)
//         printString " was already called before!"
//         printNewline
//       end
//       unless #initialized
//         assign #initialized true
//         #impl
//       end
//     end
//   end}
// end

///-----------------------------------------------------------------------------
/// Section: Additional AST functions
///-----------------------------------------------------------------------------

std:base:func void ast:setChild(ast* parent, int index, ast* newChild)
  assert (u32:uless index (getField parent childCount))
  var (ptr (ptr ast)) childptrAddr (ptradd (getField parent childs) index)
  store childptrAddr newChild
end

std:base:func void ast:replace(ast* tree, cstring placeholder, ast* replacement)
  const int count (getField tree childCount)
  for childNum 0 count
    var (ptr ast) child (ast:child tree childNum)
    when (cstring:equal placeholder (getField child id))
      ast:setChild tree childNum replacement
    end
  end

  forEachAstChild c tree
    ast:replace c placeholder replacement
  end
end

std:base:func void ast:replaceId(ast* tree, cstring placeholder, cstring newid)
  when (cstring:equal (getField tree id) placeholder)
    setField tree id newid
  end

  forEachAstChild child tree
    ast:replaceId child placeholder newid
  end
end

macro setFieldsTo record value fields...
  var (ptr ast) code ${}
  forEachAstChild field fields
    ast:addChild code ${setField #record #field #value}
  end

  ret code
end

///-----------------------------------------------------------------------------
/// Section: Floating point support
///-----------------------------------------------------------------------------

macro float:aliasNoQNAN funcName
  var cstring macroName (cstrings:append "float:" (getField funcName id))
  var astp orderedName (ast:fromString (cstrings:append "float:o" (getField funcName id)))
  ast:addChild orderedName $${#l}
  ast:addChild orderedName $${#r}

  var astp macroDef ${macro #macroName l r
    ret ${orderedName}
  end}
  ast:replace macroDef "orderedName" orderedName
  ret macroDef
end

float:aliasNoQNAN equal
float:aliasNoQNAN notEqual
float:aliasNoQNAN less
float:aliasNoQNAN greater
float:aliasNoQNAN lessEqual
float:aliasNoQNAN greaterEqual


std:base:func int main()

std:base:func void runMain()
  const int retval main()
  printNewline()
  printString "main() returned "
  printlnInt retval
end

testf runMain()

template float:neg x (float:sub 0. #x)

///-----------------------------------------------------------------------------
/// Section: Additional operators and basic math functions
///-----------------------------------------------------------------------------

std:base:func int u32:mod(int v, int div)
  u32:urem v div
end

std:base:func int u32:neg(int x)
  ret u32:sub(0, x)
end

std:base:func char* bool2cstring(bool b)
  var char* result nullptr(char)

  if b
    assign result "true"
  else
    assign result "false"
  end

  ret copyString(result)
end

template op+ l r (u32:add #l #r)
template op- l r (u32:sub #l #r)
template op* l r (u32:mul #l #r)
template op/ l r (u32:sdiv #l #r)

template op== l r (u32:equal #l #r)
template op!= l r (u32:notEqual #l #r)

template op> l r (u32:sgreater #l #r)
template op< l r (u32:sless #l #r)
template op>= l r (u32:sgreaterEqual #l #r)
template op<= l r (u32:slessEqual #l #r)

template op==_ptr l r (cast int #l == cast int #r)
template op!=_ptr l r (cast int #l != cast int #r)

macro addMappedChilds parent mapf childs...
  var (ptr ast) code ${}
  forEachAstChild child childs
    var (ptr ast) map (ast:fromString (getField mapf id))
    ast:addChild map child
    ast:addChild code ${ast:addChild #parent #map}
  end
  ret code
end

template static:id foo #foo

macro ast:addChilds parent childs...
  var (ptr ast) code ${addMappedChilds #parent static:id}
  forEachAstChild child childs
    ast:addChild code child
  end
  ret code
end

macro defineOp op func
  var (ptr ast) def $template
  ast:addChild def (ast:fromString (getField op id))
  addMappedChilds def ast:fromString "l" "r"
  var (ptr ast) impl func
  ast:addChild impl $${#l}
  ast:addChild impl $${#r}
  ast:addChild def impl
  ret def
end

macro defineOpNS op postfix func namespace
  template id astx (getField #astx id)

  var cstring funcName (cstring:concat (id namespace) ":" (id func))
  var cstring opName (cstring:concat (id op) (id postfix))

  ret ${defineOp #opName #funcName}
end

macro defineFloatOps postfix namespace
  ret ${
    defineOpNS op+ #postfix add #namespace
    defineOpNS op- #postfix sub #namespace
    defineOpNS op* #postfix mul #namespace
    defineOpNS op/ #postfix fdiv #namespace

    defineOpNS op== #postfix equal #namespace
    defineOpNS op!= #postfix notEqual #namespace

    defineOpNS op> #postfix ogreater #namespace
    defineOpNS op>= #postfix ogreaterEqual #namespace
    defineOpNS op< #postfix oless #namespace
    defineOpNS op<= #postfix olessEqual #namespace
  end}
end

defineFloatOps _f float
defineFloatOps _d double

template op= l r (assign #l #r)

macro compareFunc type name compareF
  var cstring typeName (getField type id)

  var (ptr ast) compareCode compareF
  ast:addChilds compareCode $l $r

  ret ${std:base:func #typeName #name(#typeName l, #typeName r)
    var bool cmp #compareCode
    branch cmp lgreater rgreater
    label lgreater
    ret l
    label rgreater
    ret r
  end}
end

// TODO: replace this with branchless impl once this makes a difference
compareFunc int u32:max op>
compareFunc int u32:min op<

compareFunc float float:max op>_f
compareFunc float float:min op<_f

compareFunc double double:max op>_d
compareFunc double double:min op<_d

std:base:func float float:clamp(float min, float max, float x)
  float:min max (float:max min x)
end

std:base:func int u32:clamp(int min, int max, int x)
  u32:min max (u32:max min x)
end

std:base:func bool float:equalDelta(float delta, float l, float r)
  const float diff (fabsf (l -_f r))
  ret (diff <=_f delta)
end

///-----------------------------------------------------------------------------
/// Section: Arrays
///-----------------------------------------------------------------------------

template zmp:array:get array index
  load ptradd(zmp:array:addr ptr(#array), #index)
end

template zmp:array:set array index value
  store ptradd(zmp:array:addr ptr(#array), #index) #value
end

///-----------------------------------------------------------------------------
/// Section: Deprecation
///-----------------------------------------------------------------------------

macro deprecatedNoVarArgs name replacementName warningCode args...
  var astp code ${macro #name}
  forEachAstChild arg args
    ast:addChild code arg
  end

  var astp impl ${}
  ast:addChild code impl

  // ast:addChild impl ${compiler:printWarning #warning}
  ast:addChild impl warningCode

  var astp call (ast:fromString (getField replacementName id))
  forEachAstChild arg2 args
    var astp antiquoteArg $${antiquote}
    ast:addChild antiquoteArg arg2
    ast:addChild call antiquoteArg
  end
  ast:addChild impl ${ret ${#call}}

  ret code
end

macro deprecatedVarArgs name replacementName warningCode
  var astp code ${macro #name args...}

  var cstring replName (cstring:quote (getField replacementName id))

  var astp impl ${}
  ast:addChild code impl
  ast:addChild impl ${
    #warningCode
    // compiler:printWarning #warning

    var astp call (ast:fromString #replName)
    forEachAstChild child args
      ast:addChild call child
    end

    ret call
  end}

  ret code
end

macro deprecated name replacementName args...
  var cstring warning (cstring:quote (cstring:concat (getField name id) " is deprecated. Use " (getField replacementName id) " instead."))
  var astp warningCode ${compiler:printWarning #warning}

  var bool isVarArg false

  const int argsChildCount (getField args childCount)

  when (argsChildCount > 0)
    when (cstring:equal macroRest (getField (ast:child args (argsChildCount - 1)) id))
      isVarArg = true
    end
  end

  var astp code (nullptr ast)

  when isVarArg
    code = ${deprecatedVarArgs #name #replacementName #warningCode}
  end
  unless isVarArg
    code = ${deprecatedNoVarArgs #name #replacementName #warningCode}
    forEachAstChild arg args
      ast:addChild code arg
    end
  end

  ret code
end

///-----------------------------------------------------------------------------
/// Section: Deprecated functions
///-----------------------------------------------------------------------------

deprecated astChild ast:child parent index
deprecated simpleAst ast:fromString name
deprecated printAst ast:print t indent
deprecated addChild ast:addChild tree child

///-----------------------------------------------------------------------------
/// Section: Aliasing int to u32
///-----------------------------------------------------------------------------

macro alias name replacementName args...
  var astp warningCode ${}
  var bool isVarArg false

  const int argsChildCount (getField args childCount)

  when (argsChildCount > 0)
    when (cstring:equal macroRest (getField (ast:child args (argsChildCount - 1)) id))
      isVarArg = true
    end
  end

  var astp code (nullptr ast)

  when isVarArg
    code = ${deprecatedVarArgs #name #replacementName #warningCode}
  end
  unless isVarArg
    code = ${deprecatedNoVarArgs #name #replacementName #warningCode}
    forEachAstChild arg args
      ast:addChild code arg
    end
  end

  ret code
end

alias int:equal u32:equal l r
alias int:notEqual u32:notEqual l r
alias int:less u32:less l r
alias int:lessEqual u32:lessEqual l r
alias int:greater u32:greater l r
alias int:greaterEqual u32:greaterEqual l r
alias int:shl u32:shl l r
alias int:lshr u32:lshr l r
alias int:ashr u32:ashr l r

alias int:add u32:add l r
alias int:sub u32:sub l r
alias int:mul u32:mul l r
alias int:sdiv u32:sdiv l r
alias int:udif u32:udif l r
alias int:urem u32:urem l r
alias int:srem u32:srem l r
alias int:and u32:and l r
alias int:or u32:or l r
alias int:xor u32:xor l r

alias int:clamp u32:clamp min max x
alias int:neg u32:neg x
alias int:mod u32:mod l r
alias int:toCString u32:toCString x
alias int:min u32:min l r
alias int:max u32:max l r

///-----------------------------------------------------------------------------
/// Section: external libraries
///-----------------------------------------------------------------------------

macro linkclib fileNames...
  var astp code seqAst()
  forEachAstChild fileName fileNames
    ast:addChild code ${zmp:compiler:linkclib #fileName}
  end

  ret code
end

type LoadedLibList
  cstring name
  LoadedLibList* next
end

var LoadedLibList* zmpx:lib:includedLibs null

std:base:func void printAllLoadedLibs()
  printlnString "Loaded libs:"

  var LoadedLibList* list zmpx:lib:includedLibs
  while (list !=_ptr nullptr LoadedLibList)
    printString "  "
    printlnString getField(list, name)

    list = getField list next
  end
end

var bool requireLibDebug false

macro static:setRequireLibDebug value
  if (cstring:equal getField(value,id) "true")
    requireLibDebug = true
  elseif (cstring:equal getField(value,id) "false")
    requireLibDebug = false
  else
    ret ${error #value "Expecting 'true' or 'false'"}
  end

  ret ${}
end

/// Load the given lib. Expects a quoated relative path name. Libs already
/// loaded will not be loaded again
macro zmpx:lib:requireLib lib
  var cstring libName getField(lib, id)

  var bool alreadyLoaded false

  var LoadedLibList* list zmpx:lib:includedLibs
  while (list !=_ptr nullptr LoadedLibList)
    when (cstring:equal (getField list name) libName)
      alreadyLoaded = true
    end

    list = getField list next
  end

  var ast* code ${}

  unless alreadyLoaded
    var LoadedLibList* newlist malloc(LoadedLibList)
    setField newlist name libName
    setField newlist next zmpx:lib:includedLibs
    assign zmpx:lib:includedLibs newlist
    assign code ${include #libName}
  end

  when requireLibDebug
    printString "Loading library "
    printString libName
    if alreadyLoaded
      printString " (already loaded, ignored)"
    end
    printNewline()
    flushStdout()
  end

  ret code
end

/// Will load the given libs. Expects quoted paths relative to the compilers
/// working directory. Libs already loaded will not be loaded, again
macro require libs...
  var ast* code ${}

  forEachAstChild lib libs
    ast:addChild code ${zmpx:lib:requireLib #lib}
  end

  ret code
end

/// Load file from library directory
/// Usage:
///   requireLibs libcee math
/// Each lib will be loaded once
macro requireLibs names...
  var ast* code ${require}
  forEachAstChild child names
    var cstring qualifiedName cstring:quote(cstring:concat("libs/", getField child id, ".zomp"))
    ast:addChild code ast:fromString(qualifiedName)
  end
  ret code
end

///-----------------------------------------------------------------------------
/// Section: language default bindings
///-----------------------------------------------------------------------------

/// Declare a function. Use this to avoid auto indentation on newline :)
template dfunc returnType nameAndOps
  std:base:func #returnType #nameAndOps
end

macro func args...
  var ast* code ${std:base:func}
  forEachAstChild child args
    ast:addChild code child
  end
  ret code
end

