
/*
!verify off
*/

/// external (C) functions ----------------------------------------

(type int u32)

(func void printInt ((int i)))
(func void printString (((ptr char) s)))
(func void printFloat ((float f)))
(func void printDouble ((double d)))
(func void printChar ((char c)))
(func void printNewline ())

(func (ptr char) int2cstring ((int i)))

// (func void zompLoadLib ((string libname)))
// (func bool zompCheckNativeSymbol ((string libname)))

(func void stdlibHello ())
(func void zompHello ())

(func void exit ((int exitCode)))

(func double sin ((double x)))
(func double cos ((double x)))
(func float sinf ((float x)))
(func float cosf ((float x)))

(func float atanf ((float x)))
(func float asinf ((float x)))
(func float acosf ((float x)))

(func int abs ((int x)))
(func float fabsf ((float l)))

(func float fmodf ((float num) (float divisor)))

(func float sqrtf ((float x)))

(func int zompLoadLib (((ptr char) dllname)))

/// utility functions ----------------------------------------

(func bool bool.not ((bool b)) ((bool.xor true b)))

(func int square((int x)) ((int.mul x x)))
(func float squaref((float x)) ((float.mul x x)))

(func void printBool ((bool b)) (
  (branch b true false)
   
  (label true)
  (printChar 't')
  (printNewline)
  (branch end)
  
  (label false)
  (printChar 'f')
  (printNewline)

  (label end)
  ))

(macroReplace funcln name type code
  (func void name ((type v)) (
    code
    (printNewline)
    ))
  )

(func void println () ((printNewline)))

(funcln printlnInt int (printInt v))
(funcln printlnString (ptr char) (printString v))

(macroReplace getField record componentName (
  (load (fieldptr record componentName))
  ))

(macroReplace setField record componentName value (
  (store (fieldptr record componentName) value)
  ))
  
/// string functions ----------------------------------------

(type cstring (ptr char))

(func int strcmp ((cstring l) (cstring r)))
(func cstring strcpy ((cstring dest) (cstring source)))

(func cstring int:toCString ((int x)) ((int2cstring x) ))

(type string
  (int length)
  ((ptr char) chars)
  )
(type pstring (ptr string))

(func int length ((cstring s)) (
  (var (ptr char) ptr s)
  (var int count -1)

  (var char c 'x')
  (var bool b true)
  
  (label start)
  (assign c (load ptr))

  (assign ptr (ptradd ptr 1))
  (assign count (int.add count 1))
  (assign b (char.equal c '\0'))
  (branch b end start)
  
  (label end)
  
  (ret count)
  ))

(func (ptr string) makestring ((cstring cstr)) (
  (var (ptr string) pstr (malloc string))
  (store (fieldptr pstr length) (length cstr))
  (store (fieldptr pstr chars) cstr)
  (ret pstr)
  ))

(func (ptr string) newString ((int length) (char init)) (
  (var (ptr char) chars (malloc char (int.add 1 length)))
  (store (ptradd chars length) '\0')
  (var int index 0)
  (var bool reachedEnd false)
  (label start)
  (store (ptradd chars index) init)
  (assign index (int.add index 1))
  (assign reachedEnd (int.ugreaterEqual index length))
  (branch reachedEnd end start)
  (label end)
  
  (var (ptr string) result (malloc string))
  (store (fieldptr result length) length)
  (store (fieldptr result chars) chars)
  (ret result)
  ))

(func (ptr string) append (((ptr string) l) ((ptr string) r)) (
  (var int length (int.add (getField l length) (getField r length)))
  (var (ptr string) result (newString length 'x'))
  (var (ptr char) chars (getField result chars))
  (var (ptr char) leftChars (getField l chars))
  (var int leftLength (getField l length))
  (var (ptr char) rightChars (getField r chars))
  (var int rightLength (getField r length))

  (var int index 0)
  
  (label lbegin)
  (store (ptradd chars index) (load (ptradd leftChars index)))
  (assign index (int.add index 1))
  (var bool test (int.uless index leftLength))
  (branch test lbegin lend)
  (label lend)

  (assign index 0)
  (label rbegin)
  (store (ptradd chars (int.add leftLength index)) (load (ptradd rightChars index)))
  (assign index (int.add index 1))
  (var bool test2 (int.uless index rightLength))
  (branch test2 rbegin rend)
  (label rend)
  
  (ret result)
  ))


/// print 2*count spaces
(func void printIndent ((int count)) (
  (var int counter count)
  (label start)
  (var bool t (int.ugreater counter 0))
  (branch t goon end)
  (label goon)
  (printChar ' ') (printChar ' ')
  (assign counter (int.sub counter 1))
  (branch start)
  (label end)
  ))

(func bool cstring.equal ((cstring l) (cstring r)) (
  (ret (int.equal 0 (strcmp l r)))
  ))

(func cstring cstring:quote ((cstring unquoted)) (
  (var int unquotedLength (length unquoted))
  (var cstring quoted (malloc char (int.add unquotedLength 3)))

  (strcpy (ptradd quoted 1) unquoted)
  (store quoted '"')
  (store (ptradd quoted (int.add unquotedLength 1)) '"')
  (store (ptradd quoted (int.add unquotedLength 2)) '\0')

  (ret quoted)
  ))


/// ast ----------------------------------------

(type ast
  (cstring id)
  (int childCount)
  ((ptr (ptr ast)) childs) )
(type astp (ptr ast))

(func (ptr ast) simpleAst ((cstring name)) (
  (var (ptr ast) a (malloc ast))

  (store (fieldptr a id) name)
  (store (fieldptr a childCount) 0)
  (store (fieldptr a childs) (nullptr (ptr ast)))
  
  (ret a)

  ))

(func (ptr ast) astFromString ((cstring name)) (
  (simpleAst name) ))

(func (ptr ast) seqAst () (
  (astFromString "seq") ))

(func (ptr ast) astFromInt ((int i)) (
  (var cstring asString (int2cstring i))
  (simpleAst asString) ))

(func void ast:print (((ptr ast) a) (int indent)) (
  (printIndent indent)
  (printString (load (fieldptr a id)))
  (printString " [")
  (printInt (getField a childCount))
  (printString " childs]")
  (println)

  (var int index 0)
  (label start)
  (var bool t (int.uless index (getField a childCount)))
  (branch t goon end)
  (label goon)
  (var (ptr ast) child (load (ptradd (getField a childs) index)))
  (ast:print child (int.add indent 1))
  (assign index (int.add index 1))
  (branch start)
  (label end)
  ))

(func void addChild ( ((ptr ast) tree) ((ptr ast) child) ) (
  (var int oldChildCount (getField tree childCount))
  (var int newChildCount (int.add 1 oldChildCount))
  (var (ptr (ptr ast)) newChilds (malloc (ptr ast) newChildCount))

  (var int index 0)
  (label start)
  (var bool t (int.uless index oldChildCount))
  (branch t goon end)
  (label goon)
  (store (ptradd newChilds index) (load (ptradd (getField tree childs) index)))
  (assign index (int.add index 1))
  (branch start)
  (label end)

  (store (ptradd newChilds oldChildCount) child)

  (setField tree childs newChilds)
  (setField tree childCount newChildCount)
  ))

/// get pointer to index-th child of parent
(func astp ast:child (((ptr ast) parent) (int index)) (
  (var (ptr ast) child (load (ptradd (getField parent childs) index)))
  (ret child) ))

/// macro support ----------------------------------------

(func cstring macroAstId ((int macroCurrentAst)) (
  (getField (cast (ptr ast) macroCurrentAst) id) ))

(func int macroAstChildCount ((int macroCurrentAst)) (
  (getField (cast (ptr ast) macroCurrentAst) childCount) ))

(func int macroAstChild ((int treeaddr) (int num)) (
  (var (ptr ast) tree (cast (ptr ast) treeaddr))
  (var (ptr ast) child (load (ptradd (getField tree childs) num)))
  (var int i (cast int child))
  (ret i)
  ))

(func astp testMacro2 ((astp lastArg)) (
  (ret `(native (nested tree) (with (args a b c #lastArg))))
  ))

(func int macroExec () (
  (var astp tree (testMacro2 `(foo bar)))
  (var int i (cast int tree))
  (ret i)
  ))

(func astp macroTest () (
  (ret `(macro test))
  ))

(var int lastid 0)

(func int newUniqueId () (
  (assign lastid (int.add lastid 1))
  (ret lastid) ))

(func cstring cstrings.append ((cstring l) (cstring r)) (
  (var (ptr string) lstr (makestring l))
  (var (ptr string) rstr (makestring r))
  (var (ptr string) appended (append lstr rstr))
  (ret (getField appended chars))
  ))

(func cstring newUniqueName () (
  (var int id (newUniqueId))
  (var cstring numstr (int2cstring id))
  (ret (cstrings.append "_tmp_" numstr)) ))

(func cstring newUniqueNameFor ((cstring purpose)) (
  (var cstring name (newUniqueName))
  (ret (cstrings.append (cstrings.append name "_") purpose)) ))

(macro macrotst (
  (ret `(3))
//   (printlnString "Applying macro macrotst")
//   (ret `(printlnString "Running code"))
  ))
(macro ymacrotst (
  (ret `(printInt 999))
  ))
  
(macro uniqueId name purpose (
  (ret `(var cstring #name (newUniqueNameFor #purpose)))
  ))

(macro if test onTrue onFalse (
  (uniqueId trueLabel "iftrue")
  (uniqueId falseLabel "iffalse")
  (uniqueId endLabel "ifend")
  (uniqueId testResult "iftestresult")
  
  (var (ptr ast) result `(
    (var bool #testResult #test)
    (branch #testResult #trueLabel #falseLabel)
    (label #trueLabel)
    #onTrue
    (branch #endLabel)
    (label #falseLabel)
    #onFalse
    (label #endLabel)
    ))
  (ret result)
  ))

(macro ift condition onTrue `(if #condition #onTrue ()))

(macro ifnot condition onFalse
  `(if (bool.not #condition) #onFalse ()))

///TODO: generalize for arbitrary types once this is possible in zomp
(macro ifExprInt test onTrue onFalse (
  (uniqueId trueLabel "iftrue")
  (uniqueId falseLabel "iffalse")
  (uniqueId endLabel "ifend")
  (uniqueId testResult "iftestresult")
  (uniqueId resultVar "ifResult")
  
  (var (ptr ast) result `(
    (var int #resultVar 0)
    (var bool #testResult #test)
    (branch #testResult #trueLabel #falseLabel)
    
    (label #trueLabel)
    (assign #resultVar #onTrue)
    (branch #endLabel)
    
    (label #falseLabel)
    (assign #resultVar #onFalse)
    
    (label #endLabel)
    #resultVar
    ))
  (ret result)
  ))

(macro for index min max code (
  (uniqueId startLabel "for_start")
  (uniqueId endLabel "for_exit")
  (uniqueId testResult "for_testvar")
  (uniqueId execLabel "for_body")

  (ret `(
    (var int #index #min)
    (var bool #testResult false)
    
    (label #startLabel)
    
    (assign #testResult (int.sless #index #max))
    (branch #testResult #execLabel #endLabel)
    
    (label #execLabel)
    #code
    (assign #index (int.add #index 1))
    (branch #startLabel)
    
    (label #endLabel)
    ))
  ))

(macro while test body ... (
  (uniqueId begin "while_begin")
  (uniqueId exit "while_exit")
  (uniqueId goon "while_body")
  (uniqueId testVar "while_testvar")
  
  (ret `(
    (var bool #testVar true)
    (label #begin)
    (assign #testVar (#test))
    (branch #testVar #goon #exit)
    (label #goon)
    #body
    (branch #begin)
    (label #exit)
    ))
  ))

(macro times count code ... (
  (uniqueId counterVar "timesCounter")
  (ret `(for #counterVar 0 #count #code))
  ))
  
/// execute code for each node of ast
(macro forEachAstChild childVar tree code (
  (uniqueId count "count")
  (uniqueId index "index")
  
  (ret `(
    (const int #count (getField #tree childCount))
    (for #index 0 #count (
      (const (ptr ast) #childVar (ast:child #tree #index))
      #code
      ))
    ))
  ))
  
/// workaround until "const" is properly supported
(macro const type name default (
  (ret `(var #type #name #default))
  ))

/// A template is like a macro but is defined in another way.
/// Instead of writing a function which produces the final ast
/// you simply write down the produced ast directly. You can
/// use antiquotes to calculate parts of the ast from arbitrary
/// code expressions
(macro template name argsAndImpl ... (
  (var (ptr ast) t (simpleAst "macro"))
  (addChild t name)

  (const int argCount (getField argsAndImpl childCount))
  (for argnum 0 argCount (
    (const (ptr ast) arg (ast:child argsAndImpl argnum))
    (if (int.uless argnum (int.sub argCount 1))
      (addChild t arg)
      (addChild t (
        (var (ptr ast) foo (simpleAst "quote"))
        (addChild foo arg)
        (var (ptr ast) reti (simpleAst "ret"))
        (addChild reti foo)
        reti))
      )
    ))

  (ret t)
  ))

(template when cond onTrue (if #cond #onTrue ()))
(template unless cond onFalse (if #cond () #onFalse))

(macro compilerMessage text ... (
  (printString "[message] ")
  (forEachAstChild child text (
    (printString (getField child id))
    (printString " ") ))
  (println)
  (ret `())
  ))

(func void compiler:printWarning ((cstring message)) (
  (printString "Warning: ")
  (printString message)
  (println)
  ))

/// quickly define a test function to be run with C-c,t in emacs
(template testf impl ...
  (func void test () #impl) )

(macro assert checkCode (
  (ret `(
    (if (bool.not (#checkCode))
      ((printlnString "Assertion failed")
       (ast:print `#checkCode 0)
       (exit 1))
      ())
    ))
  ))

(func void printHLine ((char chr) (int count)) (
  (times count (printChar chr))
  (println)
  ))

(macro cstring:concat firstString strings ... (
  (var (ptr ast) code `())
  (uniqueId resultString "cstring_concat")

  (addChild code `(var cstring #resultString #firstString))
  
  (forEachAstChild string strings (
    (addChild code `(assign #resultString (cstrings.append #resultString #string)))
    ))
  
  (addChild code `(#resultString))
  
  (ret code)
  ))

//------------------------------------------------------------------------------
// unit tests

/// Executes the given expression and prints an error
/// message containing the passed ast if it does not
/// evaluate to true
(macro unittest:assert testCode (
  (ret `(
    (if #testCode
      // then
      ()
      // else
      ((printHLine '-' 40)
       (printlnString "Assertion failed")
       (ast:print `#testCode 0)))
     ))
  ))

/// Calls unittest.assert on all childs of the passed
/// sequence expression
(macro unittest:assertAll checks ... (
  (var (ptr ast) code `())
  (forEachAstChild check checks (
    (addChild code `(unittest:assert #check))
    ))
  (ret code)
  ))

/// Will define a function name_tests_nr which will
/// call all unittest:assert on all given testCases
(macro unittest:testCasesFor name testCases ... (
  (var cstring testName (cstring:concat "test_" (getField name id) "_" (int:toCString (newUniqueId))))
  
  (var astp impl (astFromString "unittest:assertAll"))
  (forEachAstChild testCase testCases (
    (addChild impl testCase)
    ))
  (var astp funcDecl `(func void #testName () (#impl)))

  (ret funcDecl)
  ))

(func cstring unittest:newTestFuncNameFor ((cstring funcName)) (
  (cstring:concat "test_" funcName "_" (int:toCString (newUniqueId)))
  ))

(macro unittest:testFunc funcName impl (
  (var cstring testFuncName (unittest:newTestFuncNameFor (getField funcName id)))
  
  (ret `(func void #testFuncName () #impl))
  ))

//------------------------------------------------------------------------------

/// Prints the passed ast to stdout at compile time
/// and will return it at run time. Can be used to debug
/// a specific macro using mret instead of ret
(macro mret code (
  (ret `(
    (ast:print #code 0)
    (ret #code)
    ))
  ))

/// Will define a function which will be executed only on
/// the first call and will print a warning on subsequent calls
(macro runOnceFunc rettype name args impl (
  (uniqueId initialized (cstrings.append (getField name id) "_already_called"))

  (ret `(
    (var bool #initialized false)
    (func #rettype #name #args (
      (if #initialized
        ((printString (getField `#name id))
          (printString " was already called before!")
          (println))
        ((assign #initialized true)
          #impl))
      ))
    ))
  ))


/// additional ast functions --------------------------------

(func void ast.setChild
  (((ptr ast) parent) (int index) ((ptr ast) newChild))
  (
  (assert (int.uless index (getField parent childCount)))
  (var (ptr (ptr ast)) childptrAddr (ptradd (getField parent childs) index))
  (store childptrAddr newChild)
  ))

(func void ast.replace (
  ((ptr ast) tree)
  (cstring placeholder)
  ((ptr ast) replacement) )
  (
  (const int count (getField tree childCount))
  (for childNum 0 count (
    (var (ptr ast) child (ast:child tree childNum))
    (if (cstring.equal placeholder (getField child id))
      ( (ast.setChild tree childNum replacement) )
      ())
    ))
  (forEachAstChild c tree (
    (ast.replace c placeholder replacement)
    ))
  ))

(func void ast:replaceId ((astp tree) (cstring placeholder) (cstring newid)) (
  (if (cstring.equal (getField tree id) placeholder)
    (setField tree id newid) ())

  (forEachAstChild child tree (
    (ast:replaceId child placeholder newid)
    ))
  ))

(macro setFieldsTo value fields ... (
  (var (ptr ast) code `())
  (forEachAstChild field fields (
    (addChild code `(setField fbo #field #value))
    ))
  (ret code)
  ))

/// floating point support --------------------------------

(macro float.aliasNoQNAN funcName (
  (var cstring macroName (cstrings.append "float." (getField funcName id)))
  (var astp orderedName (simpleAst (cstrings.append "float.o" (getField funcName id))))
  (addChild orderedName ``#l)
  (addChild orderedName ``#r)

  (var astp macroDef `(macro #macroName l r (
                        (ret `(orderedName)))) )
  (ast.replace macroDef "orderedName" orderedName)
  (ret macroDef)
  ))

(float.aliasNoQNAN equal)
(float.aliasNoQNAN notEqual)
(float.aliasNoQNAN less)
(float.aliasNoQNAN greater)
(float.aliasNoQNAN lessEqual)
(float.aliasNoQNAN greaterEqual)

(func int main ())

(func void runMain () (
  (const int retval (main))
  (println)
  (printString "main() returned ") (printlnInt retval)
  ))

(testf (runMain))

(template float.neg x (float.sub 0. #x))

/// additional operators and basic math functions

(func int int:mod ((int v) (int div)) (
  (int.urem v div)
  ))
(macro int:neg x ((ret `(int.sub 0 #x))))

(template op+ l r (int.add #l #r))
(template op- l r (int.sub #l #r))
(template op* l r (int.mul #l #r))
(template op/ l r (int.sdiv #l #r))

(template op== l r (int.equal #l #r))
(template op!= l r (int.notEqual #l #r))

(template op> l r (int.sgreater #l #r))
(template op< l r (int.sless #l #r))
(template op>= l r (int.sgreaterEqual #l #r))
(template op<= l r (int.slessEqual #l #r))

(macro addMappedChilds parent mapf childs ... (
  (var (ptr ast) code `())
  (forEachAstChild child childs (
    (var (ptr ast) map (simpleAst (getField mapf id)))
    (addChild map child)
    (addChild code `(addChild #parent #map))
    ))
  (ret code)
  ))

(template static:id foo (#foo))
  
(macro addChilds parent childs ... (
  (var (ptr ast) code `(addMappedChilds #parent static:id))
  (forEachAstChild child childs (
    (addChild code child)
    ))
  (ret code)
  ))

(macro defineOp op func (
  (var (ptr ast) def `(template))
  (addChild def (simpleAst (getField op id)))
  (addMappedChilds def simpleAst "l" "r")
  (var (ptr ast) impl func)
  (addChild impl ``#l)
  (addChild impl ``#r)
  (addChild def impl)
  (ret def)
  ))

(macro defineOpNS op postfix func namespace (
  (template id astx (getField #astx id))
  
  (var cstring funcName (cstring:concat (id namespace) "." (id func)))
  (var cstring opName (cstring:concat (id op) (id postfix)))

  (ret `(defineOp #opName #funcName))
  ))

(macro defineFloatOps postfix namespace (
  (var (ptr ast) code `())

  (addChilds code
    `(defineOpNS op+ #postfix add #namespace)
    `(defineOpNS op- #postfix sub #namespace)
    `(defineOpNS op* #postfix mul #namespace)
    `(defineOpNS op/ #postfix fdiv #namespace)

    `(defineOpNS op== #postfix equal #namespace)
    `(defineOpNS op!= #postfix notEqual #namespace)

    `(defineOpNS op> #postfix ogreater #namespace)
    `(defineOpNS op>= #postfix ogreaterEqual #namespace)
    `(defineOpNS op< #postfix oless #namespace)
    `(defineOpNS op<= #postfix olessEqual #namespace)
    )

  (ret code)
  ))

(defineFloatOps _f float)
(defineFloatOps _d double)

(template op= l r (assign #l #r))

(macro compareFunc type name compareF (
  (var cstring typeName (getField type id))

  (var (ptr ast) compareCode compareF)
  (addChilds compareCode `l `r)

  (ret `(func #typeName #name ((#typeName l) (#typeName r)) (
    (var bool cmp #compareCode)
    (branch cmp lgreater rgreater)
    (label lgreater)
    (ret l)
    (label rgreater)
    (ret r)
    )))
  ))

(compareFunc int int:max op>)
(compareFunc int int:min op<)

(compareFunc float float:max op>_f)
(compareFunc float float:min op<_f)

(compareFunc double double:max op>_d)
(compareFunc double double:min op<_d)

(func float float:clamp((float min) (float max) (float x)) (
  (float:min max (float:max min x))
  ))

(func int int:clamp((int min) (int max) (int x)) (
  (int:min max (int:max min x))
  ))

(func bool float:equalDelta ((float delta) (float l) (float r)) (
  (const float diff (fabsf (l -_f r)))
  (ret (diff <=_f delta))
  ))

/// deprecation -------------------------------

(macro deprecatedNoVarArgs name replacementName warning args ... (
  (var astp code `(macro #name))
  (forEachAstChild arg args (
    (addChild code arg)
    ))

  (var astp impl `())
  (addChild code impl)

  (addChild impl `(compiler:printWarning #warning))

  (var astp call (astFromString (getField replacementName id)))
  (forEachAstChild arg2 args (
    (var astp antiquoteArg ``(antiquote))
    (addChild antiquoteArg arg2)
    (addChild call antiquoteArg)
    ))
  (addChild impl `(ret `(#call)))

  (ret code)
  ))

(macro deprecatedVarArgs name replacementName warning (
  (var astp code `(macro #name args ...))

  (var cstring replName (cstring:quote (getField replacementName id)))

  (var astp impl `())
  (addChild code impl)
  (addChild impl `(
    (compiler:printWarning #warning)

    (var astp call (astFromString #replName))
    (forEachAstChild child args (
      (addChild call child)
      ))

    (ret call)
    ))
  
  (ret code)
  ))


(macro deprecated name replacementName args ... (
  (var cstring warning (cstring:quote (cstring:concat
    (getField name id)
    " is deprecated. Use "
    (getField replacementName id)
    " instead."
    )))

  (var bool isVarArg false)

  (const int argsChildCount (getField args childCount))

  (if (argsChildCount > 0)
    (if (cstring.equal "op..." (getField (ast:child args (argsChildCount - 1)) id))
      (isVarArg = true)
      () )
    () )

  (var astp code (nullptr ast))

  (if isVarArg
    (
      (code = `(deprecatedVarArgs #name #replacementName #warning))
      )
    (
      (code = `(deprecatedNoVarArgs #name #replacementName #warning))
      (forEachAstChild arg args (
        (addChild code arg)
        ))
      )
    )
  (ret code)
  ))

/// support for indent based syntax --------------

(macro opseq args ... (
  args
  ))

(macro opjux first args ... (
  (var astp code first)
  (forEachAstChild child args (
    (addChild code child)
    ))

  (ret code)
  ))

(macro opcall first args ... (
  (var astp code first)
  (forEachAstChild child args (
    (addChild code child)))
  (ret code)
  ))

/// deprecated functions ------------------------

(deprecated unittest.assert unittest:assert check)
(deprecated unittest.assertAll unittest:assertAll "blah" check ...)

(deprecated astChild ast:child parent index)
(deprecated printAst ast:print t indent)


/* /// default test function

*/

/*

!load libglfw.dylib dlltest.dylib

(func void test () (
  (println)
  (if (int.uless 2 4)
    (printlnString "yippieh!")
    (printlnString "wtf?")
    )
  ))

(macro inline3 code (
  (var (ptr ast) tree (simpleAst "seq"))
  (printlnString "Warning: you suck!")
  (addChild tree code)
  (addChild tree code)
  (addChild tree code)
  (ret `(
    (printlnString "doing it three times!")
    #tree ))
  ))

(var cstring yippieh "yippieh!")
  
(macro tmacro2 arg
  (insert macro #arg) )

(macro tmacro3 arg0 arg1
  (foo bar #arg0 #arg1) )
*/

/*
(func int testast2 () (
  (var (ptr ast) tree `(this is a (simple ast) (for testing purposes)))
  (ret (cast int tree))
  ))

(func void test () (
  (var int t (testast2))
  
  (println)
  (printString (macroAstId t)) (printInt (macroAstChildCount t)) (println)
  (printlnString (macroAstId (macroAstChild t 2)))
))
*/


