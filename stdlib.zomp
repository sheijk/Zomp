///
/// The Zomp prelude
/// Contains definitions and methods which are available everywhere
///

/*
!verify off
*/

type int u32

///-----------------------------------------------------------------------------
/// Content of stdlib.c
///-----------------------------------------------------------------------------

func void printInt(int i)
func void printString(char* s)
func void printFloat(float f)
func void printDouble(double d)
func void printChar(char c)
func void printNewline()

func char* int2cstring(int i)

func int zompLoadLib(char* libname)
// (func bool zompCheckNativeSymbol (((ptr char) libname)))

func void stdlibHello()
// (func void zompHello ())

///-----------------------------------------------------------------------------
/// C library
///-----------------------------------------------------------------------------

func void exit(int exitCode)

func double sin(double x)
func double cos(double x)
func float sinf(float x)
func float cosf(float x)

func float atanf(float x)
func float asinf(float x)
func float acosf(float x)

func int abs(int x)
func float fabsf(float l)

func float fmodf(float num, float divisor)

func float sqrtf(float x)

///-----------------------------------------------------------------------------
/// Utility functions
///-----------------------------------------------------------------------------

func bool bool:not(bool b)
  bool:xor true b
end

func int square(int x)
  int:mul x x
end

func float squaref(float x)
  float:mul x x
end

func void printBool(bool b)
  branch b true false

  label true
  printChar 't'
  branch end

  label false
  printChar 'f'

  label end
end

macroReplace funcln name type printF
  func void name(type v)
    printF v
    printNewline()
  end
end

func void println()
  printNewline()
end

funcln printlnInt int printInt
funcln printlnString char* printString
funcln printlnFloat float printFloat

macroReplace getField record componentName
  load (fieldptr record componentName)
end

macroReplace setField record componentName value
  store (fieldptr record componentName) value
end

///-----------------------------------------------------------------------------
/// String functions
///-----------------------------------------------------------------------------


type cstring (ptr char)

func int strcmp(cstring l, cstring r)
func cstring strcpy(cstring dest, cstring source)

func cstring int:toCString(int x)
  int2cstring x
end

type string
  int length
  char* chars
end

type pstring string*

func int length(cstring s)
  var char* ptr s
  var int count -1

  var char c 'x'
  var bool b true

  label start
  assign c (load ptr)

  assign ptr (ptradd ptr 1)
  assign count (int:add count 1)
  assign b (char:equal c '\0')
  branch b end start

  label end

  ret count
end

func string* makestring(cstring cstr)
  var (ptr string) pstr (malloc string)
  store (fieldptr pstr length) (length cstr)
  store (fieldptr pstr chars) cstr
  ret pstr
end

func string* newString(int length, char init)
  var (ptr char) chars (malloc char (int:add 1 length))
  store (ptradd chars length) '\0'
  var int index 0
  var bool reachedEnd false
  label start
  store (ptradd chars index) init
  assign index (int:add index 1)
  assign reachedEnd (int:ugreaterEqual index length)
  branch reachedEnd end start
  label end

  var (ptr string) result (malloc string)
  store (fieldptr result length) length
  store (fieldptr result chars) chars
  ret result
end

func string* append(string* l, string* r)
  var int length (int:add (getField l length) (getField r length))
  var (ptr string) result (newString length 'x')
  var (ptr char) chars (getField result chars)
  var (ptr char) leftChars (getField l chars)
  var int leftLength (getField l length)
  var (ptr char) rightChars (getField r chars)
  var int rightLength (getField r length)

  var int index 0

  label lbegin
  store (ptradd chars index) (load (ptradd leftChars index))
  assign index (int:add index 1)
  var bool test (int:uless index leftLength)
  branch test lbegin lend
  label lend

  assign index 0
  label rbegin
  store (ptradd chars (int:add leftLength index)) (load (ptradd rightChars index))
  assign index (int:add index 1)
  var bool test2 (int:uless index rightLength)
  branch test2 rbegin rend
  label rend

  ret result
end


/// print 2*count spaces
func void printIndent(int count)
  var int counter count
  label start
  var bool t (int:ugreater counter 0)
  branch t goon end
  label goon
  printChar ' '
  printChar ' '
  assign counter (int:sub counter 1)
  branch start
  label end
end

func bool cstring:equal(cstring l, cstring r)
  ret (int:equal 0 (strcmp l r))
end

func cstring cstring:quote(cstring unquoted)
  var int unquotedLength (length unquoted)
  var cstring quoted (malloc char (int:add unquotedLength 3))

  strcpy (ptradd quoted 1) unquoted
  store quoted '"' // "
  store (ptradd quoted (int:add unquotedLength 1)) '"' // "
  store (ptradd quoted (int:add unquotedLength 2)) '\0'

  ret quoted
end


///-----------------------------------------------------------------------------
/// Abstract syntax tree representation
///-----------------------------------------------------------------------------

type ast
  cstring id
  int childCount
  ast** childs
end
type astp ast*

func cstring cstrings:append(cstring l, cstring r)

func ast* ast:fromString(cstring name)
  var ast* a (malloc ast)

  store (fieldptr a id) (cstrings:append name "")
  store (fieldptr a childCount) 0
  store (fieldptr a childs) (nullptr ast*)

  ret a
end

func (ptr ast) seqAst()
  ast:fromString "seq"
end

func (ptr ast) ast:fromInt(int i)
  var cstring asString (int2cstring i)
  ast:fromString asString
end

func void ast:print((ptr ast) a, int indent)
  printIndent indent
  printString (load (fieldptr a id))
  printString " ["
  printInt (getField a childCount)
  printString " childs]"
  println

  var int index 0
  label start
  var bool t (int:uless index (getField a childCount))
  branch t goon end
  label goon
  var (ptr ast) child (load (ptradd (getField a childs) index))
  ast:print child (int:add indent 1)
  assign index (int:add index 1)
  branch start
  label end
end

func void ast:addChild((ptr ast) tree, (ptr ast) child)
  var int oldChildCount (getField tree childCount)
  var int newChildCount (int:add 1 oldChildCount)
  var (ptr (ptr ast)) newChilds (malloc (ptr ast) newChildCount)

  var int index 0
  label start
  var bool t (int:uless index oldChildCount)
  branch t goon end
  label goon
  store (ptradd newChilds index) (load (ptradd (getField tree childs) index))
  assign index (int:add index 1)
  branch start
  label end

  store (ptradd newChilds oldChildCount) child

  setField tree childs newChilds
  setField tree childCount newChildCount
end

/// get pointer to index-th child of parent
func astp ast:child((ptr ast) parent, int index)
  var (ptr ast) child (load (ptradd (getField parent childs) index))
  ret child
end

///-----------------------------------------------------------------------------
/// Macro support
///-----------------------------------------------------------------------------

var cstring macroRest "postop..."

func cstring macroAstId(int macroCurrentAst)
  var cstring name (getField (cast (ptr ast) macroCurrentAst) id)
  ret name
end

func int macroAstChildCount(int macroCurrentAst)
  getField (cast (ptr ast) macroCurrentAst) childCount
end

func int macroAstChild(int treeaddr, int num)
  var (ptr ast) tree (cast (ptr ast) treeaddr)
  var (ptr ast) child (load (ptradd (getField tree childs) num))
  var int i (cast int child)
  ret i
end

func astp testMacro2(astp lastArg)
  ret ${native (nested tree) (with (args a b c #lastArg))}
end

func int macroExec()
  var astp tree (testMacro2 ${foo bar})
  var int i (cast int tree)
  ret i
end

func astp macroTest()
  ret ${macro test}
end

var int lastid 0

func int newUniqueId()
  assign lastid (int:add lastid 1)
  ret lastid
end

func cstring cstrings:append(cstring l, cstring r)
  var (ptr string) lstr (makestring l)
  var (ptr string) rstr (makestring r)
  var (ptr string) appended (append lstr rstr)
  ret (getField appended chars)
end

func cstring newUniqueName()
  var int id (newUniqueId)
  var cstring numstr (int2cstring id)
  ret (cstrings:append "_tmp_" numstr)
end

func cstring newUniqueNameFor(cstring purpose)
  var cstring name (newUniqueName)
  ret (cstrings:append (cstrings:append name "_") purpose)
end

macro testmacro args...
  var astp code ${was}

  var int count (getField args childCount)
  var int index 0
  label start

  var (ptr ast) child (ast:child args index)
  ast:addChild code child

  assign index (int:add index 1)
  var bool test (int:uless index count)
  branch test start end
  label end

  ret code
end

macro testmacro0
  ret ${foo bar}
end

macro testmacro1 arg
  var astp code ${foo bar}
  printInt (cast int arg)

  var bool test (int:equal 0 (cast int arg))
  branch test error continue

  label error
  ret ${arg is 0}

  label continue
  println
  ast:addChild code arg
  ast:print code 4
  ret code
end

macro uniqueId name purpose
  ret ${var cstring #name (newUniqueNameFor #purpose)}
end

macro if test onTrue onFalse
  uniqueId trueLabel "iftrue"
  uniqueId falseLabel "iffalse"
  uniqueId endLabel "ifend"
  uniqueId testResult "iftestresult"

  var (ptr ast) result ${
    var bool #testResult #test
    branch #testResult #trueLabel #falseLabel
    label #trueLabel
    #onTrue
    branch #endLabel
    label #falseLabel
    #onFalse
    label #endLabel
  end}
  ret result
end

macro ift condition onTrue
  ${if #condition #onTrue void}
end

macro ifnot condition onFalse
  ${if (bool:not #condition) #onFalse void}
end

///TODO: generalize for arbitrary types once this is possible in zomp
macro ifExprInt test onTrue onFalse
  uniqueId trueLabel "iftrue"
  uniqueId falseLabel "iffalse"
  uniqueId endLabel "ifend"
  uniqueId testResult "iftestresult"
  uniqueId resultVar "ifResult"

  var (ptr ast) result ${
    var int #resultVar 0
    var bool #testResult #test
    branch #testResult #trueLabel #falseLabel

    label #trueLabel
    assign #resultVar #onTrue
    branch #endLabel

    label #falseLabel
    assign #resultVar #onFalse

    label #endLabel
    #resultVar
  end}
  ret result
end

macro for index min max code
  uniqueId startLabel "for_start"
  uniqueId endLabel "for_exit"
  uniqueId testResult "for_testvar"
  uniqueId execLabel "for_body"

  ret ${
    var int #index #min
    var bool #testResult false

    label #startLabel

    assign #testResult (int:sless #index #max)
    branch #testResult #execLabel #endLabel

    label #execLabel
    #code
    assign #index (int:add #index 1)
    branch #startLabel

    label #endLabel
  end}
end

macro while test body...
  uniqueId begin "while_begin"
  uniqueId exit "while_exit"
  uniqueId goon "while_body"
  uniqueId testVar "while_testvar"

  ret ${
    var bool #testVar true
    label #begin
    assign #testVar (#test)
    branch #testVar #goon #exit
    label #goon
    #body
    branch #begin
    label #exit
  end}
end

macro times count code...
  uniqueId counterVar "timesCounter"
  ret ${for #counterVar 0 #count #code}
end

/// execute code for each node of ast
macro forEachAstChild childVar tree code
  uniqueId count "count"
  uniqueId index "index"

  ret ${
    const int #count (getField #tree childCount)
    for #index 0 #count
      const (ptr ast) #childVar (ast:child #tree #index)
      #code
    end
  end}
end

/// workaround until "const" is properly supported
macro const type name default
  ret ${var #type #name #default}
end

macro when cond onTrue
  ret ${if #cond #onTrue void}
end

macro unless cond onFalse
  ret ${if #cond void #onFalse}
end

/// A template is like a macro but is defined in another way.
/// Instead of writing a function which produces the final ast
/// you simply write down the produced ast directly. You can
/// use antiquotes to calculate parts of the ast from arbitrary
/// code expressions
macro template name argsAndImpl...
  var (ptr ast) t (ast:fromString "macro")
  ast:addChild t name

  const int argCount (getField argsAndImpl childCount)
  for argnum 0 argCount
    const (ptr ast) arg (ast:child argsAndImpl argnum)
    var bool firstArg (int:uless argnum (int:sub argCount 1))
    when firstArg
      ast:addChild t arg
    end
    unless firstArg
      var (ptr ast) foo (ast:fromString "quote")
      ast:addChild foo arg
      var (ptr ast) reti (ast:fromString "ret")
      ast:addChild reti foo
      ast:addChild t reti
    end
  end

  ret t
end

macro compilerMessage text...
  printString "[message] "
  forEachAstChild child text
    printString (getField child id)
    printString " "
  end
  println()
  ret ${}
end

func void compiler:printWarning(cstring message)
  printString "Warning: "
  printString message
  println()
end

template compiler:error message... (ret ${error #message})

/// quickly define a test function to be run with C-c,t in emacs
template testf impl... (func void test seq #impl)

macro assert checkCode
  ret ${
    when (bool:not (#checkCode))
      printlnString "Assertion failed"
      ast:print ${#checkCode} 0
      exit 1
    end
  end}
end

func void printHLine(char chr, int count)
  times count (printChar chr)
  println()
end

macro cstring:concat firstString strings...
  var (ptr ast) code ${}
  uniqueId resultString "cstring_concat"

  ast:addChild code ${var cstring #resultString #firstString}

  forEachAstChild string strings
    ast:addChild code ${assign #resultString (cstrings:append #resultString #string)}
  end

  ast:addChild code ${#resultString}

  ret code
end


///-----------------------------------------------------------------------------
/// Unit tests
///-----------------------------------------------------------------------------

/// Executes the given expression and prints an error
/// message containing the passed ast if it does not
/// evaluate to true
macro unittest:assert testCode
  ret ${
    unless #testCode
      printHLine '-' 40
      printlnString "error: Assertion failed"
      ast:print ${#testCode} 0
    end
  end}
end

/// Calls unittest:assert on all childs of the passed
/// sequence expression
macro unittest:assertAll checks
  var (ptr ast) code ${}
  forEachAstChild check checks
    when (cstring:equal (getField check id) "opseq")
      printlnString "Warning: unittest:assertAll found opseq expression. This might indicate using this from indent syntax code which is not supported"
    end
    ast:addChild code ${unittest:assert #check}
  end

  ret code
end


/// Will define a function name_tests_nr which will
/// call all unittest:assert on all given testCases
macro unittest:testCasesFor name testCases...
  var cstring testName (cstring:concat "test_" (getField name id) "_" (int:toCString (newUniqueId)))

  var astp impl (ast:fromString "unittest:assertAll")
  forEachAstChild testCase testCases
    ast:addChild impl testCase
  end
  var ast* decl ast:fromString("opcall")
  ast:addChild decl ast:fromString(testName)
  var astp funcDecl ${func void #decl
    #impl
  end}

  ret funcDecl
end

func cstring unittest:newTestFuncNameFor(cstring funcName)
  cstring:concat "test_" funcName "_" (int:toCString (newUniqueId))
end

macro unittest:testFunc funcName impl
  var cstring testFuncName (unittest:newTestFuncNameFor (getField funcName id))
  var ast* decl ast:fromString("opcall")
  ast:addChild decl ast:fromString(testFuncName)
  ret ${func void #decl #impl}
end

///-----------------------------------------------------------------------------
/// More
///-----------------------------------------------------------------------------

/// Prints the passed ast to stdout at compile time
/// and will return it at run time. Can be used to debug
/// a specific macro using mret instead of ret
macro mret code
  ret ${
    ast:print #code 0
    ret #code
  end}
end

// not supported for now
// /// Will define a function which will be executed only on
// /// the first call and will print a warning on subsequent calls
// macro runOnceFunc rettype name args impl
//   uniqueId initialized (cstrings:append (getField name id) "_already_called")
//
//   ret ${
//     var bool #initialized false
//     func #rettype #name #args
//       when #initialized
//         printString (getField ${#name} id)
//         printString " was already called before!"
//         println
//       end
//       unless #initialized
//         assign #initialized true
//         #impl
//       end
//     end
//   end}
// end

///-----------------------------------------------------------------------------
/// Additional AST functions
///-----------------------------------------------------------------------------

func void ast:setChild(ast* parent, int index, ast* newChild)
  assert (int:uless index (getField parent childCount))
  var (ptr (ptr ast)) childptrAddr (ptradd (getField parent childs) index)
  store childptrAddr newChild
end

func void ast:replace(ast* tree, cstring placeholder, ast* replacement)
  const int count (getField tree childCount)
  for childNum 0 count
    var (ptr ast) child (ast:child tree childNum)
    when (cstring:equal placeholder (getField child id))
      ast:setChild tree childNum replacement
    end
  end

  forEachAstChild c tree
    ast:replace c placeholder replacement
  end
end

func void ast:replaceId(ast* tree, cstring placeholder, cstring newid)
  when (cstring:equal (getField tree id) placeholder)
    setField tree id newid
  end

  forEachAstChild child tree
    ast:replaceId child placeholder newid
  end
end

macro setFieldsTo record value fields...
  var (ptr ast) code ${}
  forEachAstChild field fields
    ast:addChild code ${setField #record #field #value}
  end

  ret code
end

///-----------------------------------------------------------------------------
/// Floating point support
///-----------------------------------------------------------------------------

macro float:aliasNoQNAN funcName
  var cstring macroName (cstrings:append "float:" (getField funcName id))
  var astp orderedName (ast:fromString (cstrings:append "float:o" (getField funcName id)))
  ast:addChild orderedName $${#l}
  ast:addChild orderedName $${#r}

  var astp macroDef ${macro #macroName l r
    ret ${orderedName}
  end}
  ast:replace macroDef "orderedName" orderedName
  ret macroDef
end

float:aliasNoQNAN equal
float:aliasNoQNAN notEqual
float:aliasNoQNAN less
float:aliasNoQNAN greater
float:aliasNoQNAN lessEqual


func int main()

func void runMain()
  const int retval main()
  println()
  printString "main() returned "
  printlnInt retval
end

testf runMain()

template float:neg x (float:sub 0. #x)

///-----------------------------------------------------------------------------
/// Additional operators and basic math functions
///-----------------------------------------------------------------------------

func int int:mod(int v, int div)
  int:urem v div
end

macro int:neg x
  ret ${int:sub 0 #x}
end

template op+ l r (int:add #l #r)
template op- l r (int:sub #l #r)
template op* l r (int:mul #l #r)
template op/ l r (int:sdiv #l #r)

template op== l r (int:equal #l #r)
template op!= l r (int:notEqual #l #r)

template op> l r (int:sgreater #l #r)
template op< l r (int:sless #l #r)
template op>= l r (int:sgreaterEqual #l #r)
template op<= l r (int:slessEqual #l #r)

template op==_ptr l r (cast int #l == cast int #r)
template op!=_ptr l r (cast int #l != cast int #r)

macro addMappedChilds parent mapf childs...
  var (ptr ast) code ${}
  forEachAstChild child childs
    var (ptr ast) map (ast:fromString (getField mapf id))
    ast:addChild map child
    ast:addChild code ${ast:addChild #parent #map}
  end
  ret code
end

template static:id foo #foo

macro ast:addChilds parent childs...
  var (ptr ast) code ${addMappedChilds #parent static:id}
  forEachAstChild child childs
    ast:addChild code child
  end
  ret code
end

macro defineOp op func
  var (ptr ast) def $template
  ast:addChild def (ast:fromString (getField op id))
  addMappedChilds def ast:fromString "l" "r"
  var (ptr ast) impl func
  ast:addChild impl $${#l}
  ast:addChild impl $${#r}
  ast:addChild def impl
  ret def
end

macro defineOpNS op postfix func namespace
  template id astx (getField #astx id)

  var cstring funcName (cstring:concat (id namespace) ":" (id func))
  var cstring opName (cstring:concat (id op) (id postfix))

  ret ${defineOp #opName #funcName}
end

macro defineFloatOps postfix namespace
  ret ${
    defineOpNS op+ #postfix add #namespace
    defineOpNS op- #postfix sub #namespace
    defineOpNS op* #postfix mul #namespace
    defineOpNS op/ #postfix fdiv #namespace

    defineOpNS op== #postfix equal #namespace
    defineOpNS op!= #postfix notEqual #namespace

    defineOpNS op> #postfix ogreater #namespace
    defineOpNS op>= #postfix ogreaterEqual #namespace
    defineOpNS op< #postfix oless #namespace
    defineOpNS op<= #postfix olessEqual #namespace
  end}
end

defineFloatOps _f float
defineFloatOps _d double

template op= l r (assign #l #r)

macro compareFunc type name compareF
  var cstring typeName (getField type id)

  var (ptr ast) compareCode compareF
  ast:addChilds compareCode $l $r

  ret ${func #typeName #name(#typeName l, #typeName r)
    var bool cmp #compareCode
    branch cmp lgreater rgreater
    label lgreater
    ret l
    label rgreater
    ret r
  end}
end

// TODO: replace this with branchless impl once this makes a difference
compareFunc int int:max op>
compareFunc int int:min op<

compareFunc float float:max op>_f
compareFunc float float:min op<_f

compareFunc double double:max op>_d
compareFunc double double:min op<_d

func float float:clamp(float min, float max, float x)
  float:min max (float:max min x)
end

func int int:clamp(int min, int max, int x)
  int:min max (int:max min x)
end

func bool float:equalDelta(float delta, float l, float r)
  const float diff (fabsf (l -_f r))
  ret (diff <=_f delta)
end

///-----------------------------------------------------------------------------
/// Arrays
///-----------------------------------------------------------------------------

template zmp:array:get array index
  load ptradd(zmp:array:addr ptr(#array), #index)
end

template zmp:array:set array index value
  store ptradd(zmp:array:addr ptr(#array), #index) #value
end

///-----------------------------------------------------------------------------
/// Deprecation
///-----------------------------------------------------------------------------

macro deprecatedNoVarArgs name replacementName warning args...
  var astp code ${macro #name}
  forEachAstChild arg args
    ast:addChild code arg
  end

  var astp impl ${}
  ast:addChild code impl

  ast:addChild impl ${compiler:printWarning #warning}

  var astp call (ast:fromString (getField replacementName id))
  forEachAstChild arg2 args
    var astp antiquoteArg $${antiquote}
    ast:addChild antiquoteArg arg2
    ast:addChild call antiquoteArg
  end
  ast:addChild impl ${ret ${#call}}

  ret code
end

macro deprecatedVarArgs name replacementName warning
  var astp code ${macro #name args...}

  var cstring replName (cstring:quote (getField replacementName id))

  var astp impl ${}
  ast:addChild code impl
  ast:addChild impl ${
    compiler:printWarning #warning

    var astp call (ast:fromString #replName)
    forEachAstChild child args
      ast:addChild call child
    end

    ret call
  end}

  ret code
end

macro deprecated name replacementName args...
  var cstring warning (cstring:quote (cstring:concat (getField name id) " is deprecated. Use " (getField replacementName id) " instead."))

  var bool isVarArg false

  const int argsChildCount (getField args childCount)

  when (argsChildCount > 0)
    when (cstring:equal macroRest (getField (ast:child args (argsChildCount - 1)) id))
      isVarArg = true
    end
  end

  var astp code (nullptr ast)

  when isVarArg
    code = ${deprecatedVarArgs #name #replacementName #warning}
  end
  unless isVarArg
    code = ${deprecatedNoVarArgs #name #replacementName #warning}
    forEachAstChild arg args
      ast:addChild code arg
    end
  end

  ret code
end

///-----------------------------------------------------------------------------
/// Deprecated functions
///-----------------------------------------------------------------------------

deprecated astChild ast:child parent index
deprecated simpleAst ast:fromString name
deprecated printAst ast:print t indent
deprecated addChild ast:addChild tree child

macro linkclib fileNames...
  var astp code seqAst()
  forEachAstChild fileName fileNames
    ast:addChild code ${zmp:compiler:linkclib #fileName}
  end

  ret code
end

